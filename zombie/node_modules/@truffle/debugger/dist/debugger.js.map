{"version":3,"file":"debugger.js","mappings":"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","sources":["webpack/universalModuleDefinition","/Users/radish/projects/truffle/node_modules/colors/lib/colors.js","/Users/radish/projects/truffle/node_modules/colors/lib/custom/trap.js","/Users/radish/projects/truffle/node_modules/colors/lib/custom/zalgo.js","/Users/radish/projects/truffle/node_modules/colors/lib/extendStringPrototype.js","/Users/radish/projects/truffle/node_modules/colors/lib/index.js","/Users/radish/projects/truffle/node_modules/colors/lib/maps/america.js","/Users/radish/projects/truffle/node_modules/colors/lib/maps/rainbow.js","/Users/radish/projects/truffle/node_modules/colors/lib/maps/random.js","/Users/radish/projects/truffle/node_modules/colors/lib/maps/zebra.js","/Users/radish/projects/truffle/node_modules/colors/lib/styles.js","/Users/radish/projects/truffle/node_modules/colors/lib/system/has-flag.js","/Users/radish/projects/truffle/node_modules/colors/lib/system/supports-colors.js","/Users/radish/projects/truffle/packages/compile-common/dist/src/compilations.js","/Users/radish/projects/truffle/packages/compile-common/dist/src/errors.js","/Users/radish/projects/truffle/packages/compile-common/dist/src/index.js","/Users/radish/projects/truffle/packages/compile-common/dist/src/shims/LegacyToNew.js","/Users/radish/projects/truffle/packages/compile-common/dist/src/shims/NewToLegacy.js","/Users/radish/projects/truffle/packages/compile-common/dist/src/shims/index.js","/Users/radish/projects/truffle/packages/compile-common/dist/src/sources.js","/Users/radish/projects/truffle/packages/compile-common/dist/src/types.js","/Users/radish/projects/truffle/packages/debugger/debugger.js","external commonjs \"debug\"","external commonjs \"@truffle/abi-utils\"","external commonjs \"@truffle/codec\"","external commonjs \"json-stable-stringify\"","/Users/radish/projects/truffle/packages/debugger/lib/helpers/index.js","external commonjs \"redux\"","external commonjs \"redux-saga\"","/Users/radish/projects/truffle/packages/debugger/lib/store/common.js","/Users/radish/projects/truffle/packages/debugger/lib/store/index.js","/Users/radish/projects/truffle/packages/debugger/lib/controller/actions/index.js","/Users/radish/projects/truffle/packages/debugger/lib/session/actions/index.js","external commonjs \"reselect-tree\"","external commonjs \"json-pointer\"","external commonjs \"lodash/merge\"","external commonjs \"semver\"","/Users/radish/projects/truffle/packages/debugger/lib/trace/selectors/index.js","external commonjs \"bn.js\"","/Users/radish/projects/truffle/packages/debugger/lib/evm/selectors/index.js","external commonjs \"@truffle/source-map-utils\"","/Users/radish/projects/truffle/packages/debugger/lib/sourcemapping/selectors/index.js","external commonjs \"lodash/zipWith\"","/Users/radish/projects/truffle/packages/debugger/lib/stacktrace/selectors/index.js","/Users/radish/projects/truffle/packages/debugger/lib/data/selectors/index.js","/Users/radish/projects/truffle/packages/debugger/lib/txlog/selectors/index.js","/Users/radish/projects/truffle/packages/debugger/lib/session/selectors/index.js","external commonjs \"redux-saga/effects\"","/Users/radish/projects/truffle/packages/debugger/lib/trace/actions/index.js","/Users/radish/projects/truffle/packages/debugger/lib/data/actions/index.js","/Users/radish/projects/truffle/packages/debugger/lib/evm/actions/index.js","/Users/radish/projects/truffle/packages/debugger/lib/web3/actions/index.js","external commonjs \"web3\"","/Users/radish/projects/truffle/packages/debugger/lib/web3/adapter.js","/Users/radish/projects/truffle/packages/debugger/lib/web3/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/trace/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/evm/sagas/index.js","external commonjs \"lodash/sum\"","/Users/radish/projects/truffle/packages/debugger/lib/data/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/txlog/actions/index.js","/Users/radish/projects/truffle/packages/debugger/lib/txlog/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/sourcemapping/actions/index.js","/Users/radish/projects/truffle/packages/debugger/lib/sourcemapping/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/stacktrace/actions/index.js","/Users/radish/projects/truffle/packages/debugger/lib/stacktrace/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/controller/selectors/index.js","/Users/radish/projects/truffle/packages/debugger/lib/controller/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/ast/selectors/index.js","/Users/radish/projects/truffle/packages/debugger/lib/ast/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/session/sagas/index.js","/Users/radish/projects/truffle/packages/debugger/lib/data/reducers.js","/Users/radish/projects/truffle/packages/debugger/lib/evm/reducers.js","/Users/radish/projects/truffle/packages/debugger/lib/sourcemapping/reducers.js","/Users/radish/projects/truffle/packages/debugger/lib/trace/reducers.js","/Users/radish/projects/truffle/packages/debugger/lib/controller/reducers.js","/Users/radish/projects/truffle/packages/debugger/lib/stacktrace/reducers.js","/Users/radish/projects/truffle/packages/debugger/lib/txlog/reducers.js","/Users/radish/projects/truffle/packages/debugger/lib/session/reducers.js","/Users/radish/projects/truffle/packages/debugger/lib/session/index.js","/Users/radish/projects/truffle/packages/debugger/lib/debugger.js","/Users/radish/projects/truffle/packages/error/dist/src/index.js","external node-commonjs \"os\"","external node-commonjs \"path\"","external node-commonjs \"util\"","webpack/bootstrap","webpack/runtime/compat get default export","webpack/runtime/define property getters","webpack/runtime/hasOwnProperty shorthand","webpack/runtime/make namespace object","webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Debugger\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Debugger\"] = factory();\n\telse\n\t\troot[\"Debugger\"] = factory();\n})(global, () => {\nreturn ","/*\n\nThe MIT License (MIT)\n\nOriginal Library\n  - Copyright (c) Marak Squires\n\nAdditional functionality\n - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar colors = {};\nmodule['exports'] = colors;\n\ncolors.themes = {};\n\nvar util = require('util');\nvar ansiStyles = colors.styles = require('./styles');\nvar defineProps = Object.defineProperties;\nvar newLineRegex = new RegExp(/[\\r\\n]+/g);\n\ncolors.supportsColor = require('./system/supports-colors').supportsColor;\n\nif (typeof colors.enabled === 'undefined') {\n  colors.enabled = colors.supportsColor() !== false;\n}\n\ncolors.enable = function() {\n  colors.enabled = true;\n};\n\ncolors.disable = function() {\n  colors.enabled = false;\n};\n\ncolors.stripColors = colors.strip = function(str) {\n  return ('' + str).replace(/\\x1B\\[\\d+m/g, '');\n};\n\n// eslint-disable-next-line no-unused-vars\nvar stylize = colors.stylize = function stylize(str, style) {\n  if (!colors.enabled) {\n    return str+'';\n  }\n\n  var styleMap = ansiStyles[style];\n\n  // Stylize should work for non-ANSI styles, too\n  if(!styleMap && style in colors){\n    // Style maps like trap operate as functions on strings;\n    // they don't have properties like open or close.\n    return colors[style](str);\n  }\n\n  return styleMap.open + str + styleMap.close;\n};\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\nvar escapeStringRegexp = function(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return str.replace(matchOperatorsRe, '\\\\$&');\n};\n\nfunction build(_styles) {\n  var builder = function builder() {\n    return applyStyle.apply(builder, arguments);\n  };\n  builder._styles = _styles;\n  // __proto__ is used because we must return a function, but there is\n  // no way to create a function with a different prototype.\n  builder.__proto__ = proto;\n  return builder;\n}\n\nvar styles = (function() {\n  var ret = {};\n  ansiStyles.grey = ansiStyles.gray;\n  Object.keys(ansiStyles).forEach(function(key) {\n    ansiStyles[key].closeRe =\n      new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n    ret[key] = {\n      get: function() {\n        return build(this._styles.concat(key));\n      },\n    };\n  });\n  return ret;\n})();\n\nvar proto = defineProps(function colors() {}, styles);\n\nfunction applyStyle() {\n  var args = Array.prototype.slice.call(arguments);\n\n  var str = args.map(function(arg) {\n    // Use weak equality check so we can colorize null/undefined in safe mode\n    if (arg != null && arg.constructor === String) {\n      return arg;\n    } else {\n      return util.inspect(arg);\n    }\n  }).join(' ');\n\n  if (!colors.enabled || !str) {\n    return str;\n  }\n\n  var newLinesPresent = str.indexOf('\\n') != -1;\n\n  var nestedStyles = this._styles;\n\n  var i = nestedStyles.length;\n  while (i--) {\n    var code = ansiStyles[nestedStyles[i]];\n    str = code.open + str.replace(code.closeRe, code.open) + code.close;\n    if (newLinesPresent) {\n      str = str.replace(newLineRegex, function(match) {\n        return code.close + match + code.open;\n      });\n    }\n  }\n\n  return str;\n}\n\ncolors.setTheme = function(theme) {\n  if (typeof theme === 'string') {\n    console.log('colors.setTheme now only accepts an object, not a string.  ' +\n      'If you are trying to set a theme from a file, it is now your (the ' +\n      'caller\\'s) responsibility to require the file.  The old syntax ' +\n      'looked like colors.setTheme(__dirname + ' +\n      '\\'/../themes/generic-logging.js\\'); The new syntax looks like '+\n      'colors.setTheme(require(__dirname + ' +\n      '\\'/../themes/generic-logging.js\\'));');\n    return;\n  }\n  for (var style in theme) {\n    (function(style) {\n      colors[style] = function(str) {\n        if (typeof theme[style] === 'object') {\n          var out = str;\n          for (var i in theme[style]) {\n            out = colors[theme[style][i]](out);\n          }\n          return out;\n        }\n        return colors[theme[style]](str);\n      };\n    })(style);\n  }\n};\n\nfunction init() {\n  var ret = {};\n  Object.keys(styles).forEach(function(name) {\n    ret[name] = {\n      get: function() {\n        return build([name]);\n      },\n    };\n  });\n  return ret;\n}\n\nvar sequencer = function sequencer(map, str) {\n  var exploded = str.split('');\n  exploded = exploded.map(map);\n  return exploded.join('');\n};\n\n// custom formatter methods\ncolors.trap = require('./custom/trap');\ncolors.zalgo = require('./custom/zalgo');\n\n// maps\ncolors.maps = {};\ncolors.maps.america = require('./maps/america')(colors);\ncolors.maps.zebra = require('./maps/zebra')(colors);\ncolors.maps.rainbow = require('./maps/rainbow')(colors);\ncolors.maps.random = require('./maps/random')(colors);\n\nfor (var map in colors.maps) {\n  (function(map) {\n    colors[map] = function(str) {\n      return sequencer(colors.maps[map], str);\n    };\n  })(map);\n}\n\ndefineProps(colors, init());\n","module['exports'] = function runTheTrap(text, options) {\n  var result = '';\n  text = text || 'Run the trap, drop the bass';\n  text = text.split('');\n  var trap = {\n    a: ['\\u0040', '\\u0104', '\\u023a', '\\u0245', '\\u0394', '\\u039b', '\\u0414'],\n    b: ['\\u00df', '\\u0181', '\\u0243', '\\u026e', '\\u03b2', '\\u0e3f'],\n    c: ['\\u00a9', '\\u023b', '\\u03fe'],\n    d: ['\\u00d0', '\\u018a', '\\u0500', '\\u0501', '\\u0502', '\\u0503'],\n    e: ['\\u00cb', '\\u0115', '\\u018e', '\\u0258', '\\u03a3', '\\u03be', '\\u04bc',\n      '\\u0a6c'],\n    f: ['\\u04fa'],\n    g: ['\\u0262'],\n    h: ['\\u0126', '\\u0195', '\\u04a2', '\\u04ba', '\\u04c7', '\\u050a'],\n    i: ['\\u0f0f'],\n    j: ['\\u0134'],\n    k: ['\\u0138', '\\u04a0', '\\u04c3', '\\u051e'],\n    l: ['\\u0139'],\n    m: ['\\u028d', '\\u04cd', '\\u04ce', '\\u0520', '\\u0521', '\\u0d69'],\n    n: ['\\u00d1', '\\u014b', '\\u019d', '\\u0376', '\\u03a0', '\\u048a'],\n    o: ['\\u00d8', '\\u00f5', '\\u00f8', '\\u01fe', '\\u0298', '\\u047a', '\\u05dd',\n      '\\u06dd', '\\u0e4f'],\n    p: ['\\u01f7', '\\u048e'],\n    q: ['\\u09cd'],\n    r: ['\\u00ae', '\\u01a6', '\\u0210', '\\u024c', '\\u0280', '\\u042f'],\n    s: ['\\u00a7', '\\u03de', '\\u03df', '\\u03e8'],\n    t: ['\\u0141', '\\u0166', '\\u0373'],\n    u: ['\\u01b1', '\\u054d'],\n    v: ['\\u05d8'],\n    w: ['\\u0428', '\\u0460', '\\u047c', '\\u0d70'],\n    x: ['\\u04b2', '\\u04fe', '\\u04fc', '\\u04fd'],\n    y: ['\\u00a5', '\\u04b0', '\\u04cb'],\n    z: ['\\u01b5', '\\u0240'],\n  };\n  text.forEach(function(c) {\n    c = c.toLowerCase();\n    var chars = trap[c] || [' '];\n    var rand = Math.floor(Math.random() * chars.length);\n    if (typeof trap[c] !== 'undefined') {\n      result += trap[c][rand];\n    } else {\n      result += c;\n    }\n  });\n  return result;\n};\n","// please no\nmodule['exports'] = function zalgo(text, options) {\n  text = text || '   he is here   ';\n  var soul = {\n    'up': [\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '',\n    ],\n    'down': [\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n    ],\n    'mid': [\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '',\n      '', '', '', '',\n      '', '', ' ',\n    ],\n  };\n  var all = [].concat(soul.up, soul.down, soul.mid);\n\n  function randomNumber(range) {\n    var r = Math.floor(Math.random() * range);\n    return r;\n  }\n\n  function isChar(character) {\n    var bool = false;\n    all.filter(function(i) {\n      bool = (i === character);\n    });\n    return bool;\n  }\n\n\n  function heComes(text, options) {\n    var result = '';\n    var counts;\n    var l;\n    options = options || {};\n    options['up'] =\n      typeof options['up'] !== 'undefined' ? options['up'] : true;\n    options['mid'] =\n      typeof options['mid'] !== 'undefined' ? options['mid'] : true;\n    options['down'] =\n      typeof options['down'] !== 'undefined' ? options['down'] : true;\n    options['size'] =\n      typeof options['size'] !== 'undefined' ? options['size'] : 'maxi';\n    text = text.split('');\n    for (l in text) {\n      if (isChar(l)) {\n        continue;\n      }\n      result = result + text[l];\n      counts = {'up': 0, 'down': 0, 'mid': 0};\n      switch (options.size) {\n        case 'mini':\n          counts.up = randomNumber(8);\n          counts.mid = randomNumber(2);\n          counts.down = randomNumber(8);\n          break;\n        case 'maxi':\n          counts.up = randomNumber(16) + 3;\n          counts.mid = randomNumber(4) + 1;\n          counts.down = randomNumber(64) + 3;\n          break;\n        default:\n          counts.up = randomNumber(8) + 1;\n          counts.mid = randomNumber(6) / 2;\n          counts.down = randomNumber(8) + 1;\n          break;\n      }\n\n      var arr = ['up', 'mid', 'down'];\n      for (var d in arr) {\n        var index = arr[d];\n        for (var i = 0; i <= counts[index]; i++) {\n          if (options[index]) {\n            result = result + soul[index][randomNumber(soul[index].length)];\n          }\n        }\n      }\n    }\n    return result;\n  }\n  // don't summon him\n  return heComes(text, options);\n};\n\n","var colors = require('./colors');\n\nmodule['exports'] = function() {\n  //\n  // Extends prototype of native string object to allow for \"foo\".red syntax\n  //\n  var addProperty = function(color, func) {\n    String.prototype.__defineGetter__(color, func);\n  };\n\n  addProperty('strip', function() {\n    return colors.strip(this);\n  });\n\n  addProperty('stripColors', function() {\n    return colors.strip(this);\n  });\n\n  addProperty('trap', function() {\n    return colors.trap(this);\n  });\n\n  addProperty('zalgo', function() {\n    return colors.zalgo(this);\n  });\n\n  addProperty('zebra', function() {\n    return colors.zebra(this);\n  });\n\n  addProperty('rainbow', function() {\n    return colors.rainbow(this);\n  });\n\n  addProperty('random', function() {\n    return colors.random(this);\n  });\n\n  addProperty('america', function() {\n    return colors.america(this);\n  });\n\n  //\n  // Iterate through all default styles and colors\n  //\n  var x = Object.keys(colors.styles);\n  x.forEach(function(style) {\n    addProperty(style, function() {\n      return colors.stylize(this, style);\n    });\n  });\n\n  function applyTheme(theme) {\n    //\n    // Remark: This is a list of methods that exist\n    // on String that you should not overwrite.\n    //\n    var stringPrototypeBlacklist = [\n      '__defineGetter__', '__defineSetter__', '__lookupGetter__',\n      '__lookupSetter__', 'charAt', 'constructor', 'hasOwnProperty',\n      'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString',\n      'valueOf', 'charCodeAt', 'indexOf', 'lastIndexOf', 'length',\n      'localeCompare', 'match', 'repeat', 'replace', 'search', 'slice',\n      'split', 'substring', 'toLocaleLowerCase', 'toLocaleUpperCase',\n      'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight',\n    ];\n\n    Object.keys(theme).forEach(function(prop) {\n      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {\n        console.log('warn: '.red + ('String.prototype' + prop).magenta +\n          ' is probably something you don\\'t want to override.  ' +\n          'Ignoring style name');\n      } else {\n        if (typeof(theme[prop]) === 'string') {\n          colors[prop] = colors[theme[prop]];\n          addProperty(prop, function() {\n            return colors[prop](this);\n          });\n        } else {\n          var themePropApplicator = function(str) {\n            var ret = str || this;\n            for (var t = 0; t < theme[prop].length; t++) {\n              ret = colors[theme[prop][t]](ret);\n            }\n            return ret;\n          };\n          addProperty(prop, themePropApplicator);\n          colors[prop] = function(str) {\n            return themePropApplicator(str);\n          };\n        }\n      }\n    });\n  }\n\n  colors.setTheme = function(theme) {\n    if (typeof theme === 'string') {\n      console.log('colors.setTheme now only accepts an object, not a string. ' +\n        'If you are trying to set a theme from a file, it is now your (the ' +\n        'caller\\'s) responsibility to require the file.  The old syntax ' +\n        'looked like colors.setTheme(__dirname + ' +\n        '\\'/../themes/generic-logging.js\\'); The new syntax looks like '+\n        'colors.setTheme(require(__dirname + ' +\n        '\\'/../themes/generic-logging.js\\'));');\n      return;\n    } else {\n      applyTheme(theme);\n    }\n  };\n};\n","var colors = require('./colors');\nmodule['exports'] = colors;\n\n// Remark: By default, colors will add style properties to String.prototype.\n//\n// If you don't wish to extend String.prototype, you can do this instead and\n// native String will not be touched:\n//\n//   var colors = require('colors/safe);\n//   colors.red(\"foo\")\n//\n//\nrequire('./extendStringPrototype')();\n","module['exports'] = function(colors) {\n  return function(letter, i, exploded) {\n    if (letter === ' ') return letter;\n    switch (i%3) {\n      case 0: return colors.red(letter);\n      case 1: return colors.white(letter);\n      case 2: return colors.blue(letter);\n    }\n  };\n};\n","module['exports'] = function(colors) {\n  // RoY G BiV\n  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];\n  return function(letter, i, exploded) {\n    if (letter === ' ') {\n      return letter;\n    } else {\n      return colors[rainbowColors[i++ % rainbowColors.length]](letter);\n    }\n  };\n};\n\n","module['exports'] = function(colors) {\n  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green',\n    'blue', 'white', 'cyan', 'magenta', 'brightYellow', 'brightRed',\n    'brightGreen', 'brightBlue', 'brightWhite', 'brightCyan', 'brightMagenta'];\n  return function(letter, i, exploded) {\n    return letter === ' ' ? letter :\n      colors[\n          available[Math.round(Math.random() * (available.length - 2))]\n      ](letter);\n  };\n};\n","module['exports'] = function(colors) {\n  return function(letter, i, exploded) {\n    return i % 2 === 0 ? letter : colors.inverse(letter);\n  };\n};\n","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar styles = {};\nmodule['exports'] = styles;\n\nvar codes = {\n  reset: [0, 0],\n\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  grey: [90, 39],\n\n  brightRed: [91, 39],\n  brightGreen: [92, 39],\n  brightYellow: [93, 39],\n  brightBlue: [94, 39],\n  brightMagenta: [95, 39],\n  brightCyan: [96, 39],\n  brightWhite: [97, 39],\n\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  bgGray: [100, 49],\n  bgGrey: [100, 49],\n\n  bgBrightRed: [101, 49],\n  bgBrightGreen: [102, 49],\n  bgBrightYellow: [103, 49],\n  bgBrightBlue: [104, 49],\n  bgBrightMagenta: [105, 49],\n  bgBrightCyan: [106, 49],\n  bgBrightWhite: [107, 49],\n\n  // legacy styles for colors pre v1.0.0\n  blackBG: [40, 49],\n  redBG: [41, 49],\n  greenBG: [42, 49],\n  yellowBG: [43, 49],\n  blueBG: [44, 49],\n  magentaBG: [45, 49],\n  cyanBG: [46, 49],\n  whiteBG: [47, 49],\n\n};\n\nObject.keys(codes).forEach(function(key) {\n  var val = codes[key];\n  var style = styles[key] = [];\n  style.open = '\\u001b[' + val[0] + 'm';\n  style.close = '\\u001b[' + val[1] + 'm';\n});\n","/*\nMIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n'use strict';\n\nmodule.exports = function(flag, argv) {\n  argv = argv || process.argv;\n\n  var terminatorPos = argv.indexOf('--');\n  var prefix = /^-{1,2}/.test(flag) ? '' : '--';\n  var pos = argv.indexOf(prefix + flag);\n\n  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n'use strict';\n\nvar os = require('os');\nvar hasFlag = require('./has-flag.js');\n\nvar env = process.env;\n\nvar forceColor = void 0;\nif (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {\n  forceColor = false;\n} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true')\n           || hasFlag('color=always')) {\n  forceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n  forceColor = env.FORCE_COLOR.length === 0\n    || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n  if (level === 0) {\n    return false;\n  }\n\n  return {\n    level: level,\n    hasBasic: true,\n    has256: level >= 2,\n    has16m: level >= 3,\n  };\n}\n\nfunction supportsColor(stream) {\n  if (forceColor === false) {\n    return 0;\n  }\n\n  if (hasFlag('color=16m') || hasFlag('color=full')\n      || hasFlag('color=truecolor')) {\n    return 3;\n  }\n\n  if (hasFlag('color=256')) {\n    return 2;\n  }\n\n  if (stream && !stream.isTTY && forceColor !== true) {\n    return 0;\n  }\n\n  var min = forceColor ? 1 : 0;\n\n  if (process.platform === 'win32') {\n    // Node.js 7.5.0 is the first version of Node.js to include a patch to\n    // libuv that enables 256 color output on Windows. Anything earlier and it\n    // won't work. However, here we target Node.js 8 at minimum as it is an LTS\n    // release, and Node.js 7 is not. Windows 10 build 10586 is the first\n    // Windows release that supports 256 colors. Windows 10 build 14931 is the\n    // first release that supports 16m/TrueColor.\n    var osRelease = os.release().split('.');\n    if (Number(process.versions.node.split('.')[0]) >= 8\n        && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n      return Number(osRelease[2]) >= 14931 ? 3 : 2;\n    }\n\n    return 1;\n  }\n\n  if ('CI' in env) {\n    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {\n      return sign in env;\n    }) || env.CI_NAME === 'codeship') {\n      return 1;\n    }\n\n    return min;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return (/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0\n    );\n  }\n\n  if ('TERM_PROGRAM' in env) {\n    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n    switch (env.TERM_PROGRAM) {\n      case 'iTerm.app':\n        return version >= 3 ? 3 : 2;\n      case 'Hyper':\n        return 3;\n      case 'Apple_Terminal':\n        return 2;\n      // No default\n    }\n  }\n\n  if (/-256(color)?$/i.test(env.TERM)) {\n    return 2;\n  }\n\n  if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n    return 1;\n  }\n\n  if ('COLORTERM' in env) {\n    return 1;\n  }\n\n  if (env.TERM === 'dumb') {\n    return min;\n  }\n\n  return min;\n}\n\nfunction getSupportLevel(stream) {\n  var level = supportsColor(stream);\n  return translateLevel(level);\n}\n\nmodule.exports = {\n  supportsColor: getSupportLevel,\n  stdout: getSupportLevel(process.stdout),\n  stderr: getSupportLevel(process.stderr),\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.emptyWorkflowCompileResult = exports.promoteCompileResult = void 0;\nfunction promoteCompileResult(result) {\n    const { compilations } = result;\n    const contracts = compilations.flatMap(compilation => compilation.contracts);\n    return { compilations, contracts };\n}\nexports.promoteCompileResult = promoteCompileResult;\nfunction emptyWorkflowCompileResult() {\n    return { compilations: [], contracts: [] };\n}\nexports.emptyWorkflowCompileResult = emptyWorkflowCompileResult;\n//# sourceMappingURL=compilations.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompileError = void 0;\nconst colors_1 = __importDefault(require(\"colors\"));\nconst error_1 = __importDefault(require(\"@truffle/error\"));\nclass CompileError extends error_1.default {\n    constructor(message) {\n        // Note we trim() because solc likes to add extra whitespace.\n        var fancy_message = message.trim() + \"\\n\\n\" + colors_1.default.red(\"Compilation failed. See above.\");\n        var normal_message = message.trim();\n        super(normal_message);\n        this.message = fancy_message; //?? I don't understand this, I just found it here\n    }\n}\nexports.CompileError = CompileError;\n//# sourceMappingURL=errors.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Compilations = exports.Errors = exports.Sources = exports.Shims = void 0;\nexports.Shims = __importStar(require(\"./shims\"));\nexports.Sources = __importStar(require(\"./sources\"));\nexports.Errors = __importStar(require(\"./errors\"));\nexports.Compilations = __importStar(require(\"./compilations\"));\n__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forBytecode = exports.forContract = exports.forContracts = void 0;\nfunction forContracts(contracts) {\n    // convert to list\n    return Object.values(contracts).map(forContract);\n}\nexports.forContracts = forContracts;\nfunction forContract(contract) {\n    const { contractName, contract_name, sourcePath, source, sourceMap, deployedSourceMap, legacyAST, ast, abi, metadata, bytecode, deployedBytecode, compiler, devdoc, userdoc, immutableReferences, generatedSources, deployedGeneratedSources, db } = contract;\n    return {\n        contractName: contract_name || contractName,\n        sourcePath,\n        source,\n        sourceMap,\n        deployedSourceMap,\n        legacyAST,\n        ast,\n        abi,\n        metadata,\n        bytecode: bytecode ? forBytecode(bytecode) : undefined,\n        deployedBytecode: deployedBytecode\n            ? forBytecode(deployedBytecode)\n            : undefined,\n        compiler,\n        devdoc,\n        userdoc,\n        immutableReferences,\n        generatedSources,\n        deployedGeneratedSources,\n        db\n    };\n}\nexports.forContract = forContract;\nfunction forBytecode(bytecode) {\n    if (typeof bytecode === \"object\") {\n        return bytecode;\n    }\n    const linkReferences = [];\n    const bytes = bytecode\n        .slice(2) // remove 0x prefix\n        .replace(/__[^_]+_*/g, (linkReference, characterOffset) => {\n        const match = linkReference.match(/__([^_]+)_*/);\n        if (match === null) {\n            //this can't actually happen, but strictNullChecks requires it\n            throw new Error(\"Could not extract link reference name\");\n        }\n        const name = match[1];\n        const characterLength = linkReference.length;\n        const offset = characterOffset / 2;\n        const length = characterLength / 2;\n        linkReferences.push({\n            offsets: [offset],\n            name,\n            length\n        });\n        return \"0\".repeat(characterLength);\n    });\n    return { bytes, linkReferences };\n}\nexports.forBytecode = forBytecode;\n//# sourceMappingURL=LegacyToNew.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forBytecode = exports.forContract = void 0;\nfunction forContract(contract) {\n    const { contractName, sourcePath, source, sourceMap, deployedSourceMap, legacyAST, ast, abi, metadata, bytecode, deployedBytecode, compiler, devdoc, userdoc, immutableReferences, generatedSources, deployedGeneratedSources, db } = contract;\n    return {\n        contract_name: contractName,\n        sourcePath,\n        source,\n        sourceMap,\n        deployedSourceMap,\n        legacyAST,\n        ast,\n        abi,\n        metadata,\n        bytecode: forBytecode(bytecode),\n        deployedBytecode: forBytecode(deployedBytecode),\n        unlinked_binary: forBytecode(bytecode),\n        compiler,\n        devdoc,\n        userdoc,\n        immutableReferences,\n        generatedSources,\n        deployedGeneratedSources,\n        db\n    };\n}\nexports.forContract = forContract;\nfunction forBytecode(bytecode) {\n    if (!bytecode) {\n        return bytecode;\n    }\n    if (typeof bytecode === \"string\") {\n        return bytecode;\n    }\n    let { bytes, linkReferences } = bytecode;\n    linkReferences = linkReferences || [];\n    // inline link references - start by flattening the offsets\n    const flattenedLinkReferences = linkReferences\n        // map each link ref to array of link refs with only one offset\n        .map(({ offsets, length, name }) => offsets.map(offset => ({ offset, length, name })))\n        // flatten\n        .reduce((a, b) => [...a, ...b], []);\n    // then overwite bytes with link reference\n    bytes = flattenedLinkReferences.reduce((bytes, { offset, name, length }) => {\n        // length is a byte offset\n        const characterLength = length * 2;\n        let linkId = `__${name.slice(0, characterLength - 2)}`;\n        while (linkId.length < characterLength) {\n            linkId += \"_\";\n        }\n        const start = offset * 2;\n        return `${bytes.substring(0, start)}${linkId}${bytes.substring(start + characterLength)}`;\n    }, bytes);\n    return `0x${bytes}`;\n}\nexports.forBytecode = forBytecode;\n//# sourceMappingURL=NewToLegacy.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NewToLegacy = exports.LegacyToNew = void 0;\nexports.LegacyToNew = __importStar(require(\"./LegacyToNew\"));\nexports.NewToLegacy = __importStar(require(\"./NewToLegacy\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectSources = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * Collects sources, targets into collections with OS-independent paths,\n * along with a reverse mapping to the original path (for post-processing)\n *\n * @param originalSources - { [originalSourcePath]: contents }\n * @param originalTargets - originalSourcePath[]\n * @param baseDirectory - a directory to remove as a prefix\n * @param replacement - what to replace it with\n * @return { sources, targets, originalSourcePaths }\n */\nfunction collectSources(originalSources, originalTargets = [], baseDirectory = \"\", replacement = \"/\") {\n    const mappedResults = Object.entries(originalSources)\n        .filter(([originalSourcePath, _]) => !path.isAbsolute(originalSourcePath) ||\n        originalSourcePath.startsWith(baseDirectory))\n        .map(([originalSourcePath, contents]) => ({\n        originalSourcePath,\n        contents,\n        sourcePath: getPortableSourcePath(replaceRootDirectory(originalSourcePath, baseDirectory, replacement))\n    }))\n        .map(({ originalSourcePath, sourcePath, contents }) => ({\n        sources: {\n            [sourcePath]: contents\n        },\n        // include transformed form as target if original is a target\n        targets: originalTargets.includes(originalSourcePath) ? [sourcePath] : [],\n        originalSourcePaths: {\n            [sourcePath]: originalSourcePath\n        }\n    }));\n    const defaultAccumulator = {\n        sources: {},\n        targets: [],\n        originalSourcePaths: {}\n    };\n    return mappedResults.reduce((accumulator, result) => ({\n        sources: Object.assign({}, accumulator.sources, result.sources),\n        targets: [...accumulator.targets, ...result.targets],\n        originalSourcePaths: Object.assign({}, accumulator.originalSourcePaths, result.originalSourcePaths)\n    }), defaultAccumulator);\n}\nexports.collectSources = collectSources;\n/**\n * @param sourcePath - string\n * @return string - operating system independent path\n * @private\n */\nfunction getPortableSourcePath(sourcePath) {\n    let replacement = sourcePath;\n    //on Windows, replace backslashes with forward slashes\n    if (path.sep === \"\\\\\") {\n        replacement = sourcePath.replace(/\\\\/g, \"/\");\n    }\n    // Turn G:/.../ into /G/.../ for Windows\n    if (replacement.length >= 2 && replacement[1] === \":\") {\n        replacement = \"/\" + replacement;\n        replacement = replacement.replace(\":\", \"\");\n    }\n    return replacement;\n}\nfunction replaceRootDirectory(sourcePath, rootDirectory, replacement) {\n    //make sure root directory ends in a separator\n    if (!rootDirectory.endsWith(path.sep)) {\n        rootDirectory = rootDirectory + path.sep;\n    }\n    return sourcePath.startsWith(rootDirectory)\n        ? replacement + sourcePath.slice(rootDirectory.length) //remove prefix\n        : sourcePath;\n}\n//# sourceMappingURL=sources.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","var Debugger = require(\"./lib/debugger\").default;\n\nmodule.exports = Debugger;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"debug\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@truffle/abi-utils\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@truffle/codec\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"json-stable-stringify\");","import * as Codec from \"@truffle/codec\";\nimport stringify from \"json-stable-stringify\";\n\n/** AST node types that are skipped by stepNext() to filter out some noise */\nexport function isDeliberatelySkippedNodeType(node) {\n  const skippedTypes = [\n    \"ContractDefinition\",\n    \"VariableDeclaration\",\n    \"YulVariableDeclaration\",\n    \"YulBlock\"\n  ];\n  return skippedTypes.includes(node.nodeType);\n}\n\n//HACK\n//these aren't the only types of skipped nodes, but determining all skipped\n//nodes would be too difficult\nexport function isSkippedNodeType(node) {\n  const otherSkippedTypes = [\n    \"VariableDeclarationStatement\",\n    \"Mapping\",\n    \"Block\",\n    \"InlineAssembly\", //definitely do *not* add to deliberately skipped!\n    \"YulTypedName\"\n  ];\n  return (\n    isDeliberatelySkippedNodeType(node) ||\n    otherSkippedTypes.includes(node.nodeType) ||\n    node.nodeType.includes(\"TypeName\") || //HACK\n    //skip string literals too -- we'll handle that manually\n    (node.typeDescriptions !== undefined && //seems this sometimes happens?\n      Codec.Ast.Utils.typeClass(node) === \"stringliteral\")\n  );\n}\n\nexport function prefixName(prefix, fn) {\n  Object.defineProperty(fn, \"name\", {\n    value: `${prefix}.${fn.name}`,\n    configurable: true\n  });\n\n  return fn;\n}\n\nexport function makePath(sourceId, pointer) {\n  return `${sourceId}:${pointer}`;\n}\n\n/**\n * returns a new array which is a copy of array but with\n * elements popped from the top until numToRemove elements\n * satisfying the predicate have been removed (or until the\n * array is empty)\n */\nexport function popNWhere(array, numToRemove, predicate) {\n  let newArray = array.slice();\n  //I'm going to write this the C way, hope you don't mind :P\n  while (numToRemove > 0 && newArray.length > 0) {\n    let top = newArray[newArray.length - 1];\n    if (predicate(top)) {\n      numToRemove--;\n    }\n    newArray.pop();\n  }\n  return newArray;\n}\n\n/**\n * @return 0x-prefix string of keccak256 hash\n */\nexport function keccak256(...args) {\n  return Codec.Conversion.toHexString(\n    Codec.Evm.Utils.keccak256(...args),\n    Codec.Evm.Utils.WORD_SIZE\n  );\n}\n\n/**\n * Given an object, return a stable hash by first running it through a stable\n * stringify operation before hashing\n */\nexport function stableKeccak256(obj) {\n  return keccak256({ type: \"string\", value: stringify(obj) });\n}\n\n/*\n * used by data; takes an id object and a ref (pointer) and returns a full\n * corresponding assignment object\n */\nexport function makeAssignment(idObj, ref) {\n  let id = stableKeccak256(idObj);\n  return { ...idObj, id, ref };\n}\n\n/*\n * Given a mmemonic, determine whether it's the mnemonic of a calling\n * instruction (does NOT include creation instructions)\n */\nexport function isCallMnemonic(op) {\n  const calls = [\"CALL\", \"DELEGATECALL\", \"STATICCALL\", \"CALLCODE\"];\n  return calls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that take only 6 args instead of 7\n */\nexport function isShortCallMnemonic(op) {\n  const shortCalls = [\"DELEGATECALL\", \"STATICCALL\"];\n  return shortCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that delegate storage\n */\nexport function isDelegateCallMnemonicBroad(op) {\n  const delegateCalls = [\"DELEGATECALL\", \"CALLCODE\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that delegate everything\n */\nexport function isDelegateCallMnemonicStrict(op) {\n  const delegateCalls = [\"DELEGATECALL\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for static calls\n */\nexport function isStaticCallMnemonic(op) {\n  const delegateCalls = [\"STATICCALL\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * Given a mmemonic, determine whether it's the mnemonic of a creation\n * instruction\n */\nexport function isCreateMnemonic(op) {\n  const creates = [\"CREATE\", \"CREATE2\"];\n  return creates.includes(op);\n}\n\n/*\n * Given a mmemonic, determine whether it's the mnemonic of a self-destruct\n * instruction\n */\nexport function isSelfDestructMnemonic(op) {\n  const creates = [\"SELFDESTRUCT\", \"SUICIDE\"]; //latter name shouldn't be used anymore but let's be safe\n  return creates.includes(op);\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"redux\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"redux-saga\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:store:common\");\n\nimport { compose, createStore, applyMiddleware } from \"redux\";\nimport createSagaMiddleware from \"redux-saga\";\n\nexport default function configureStore(\n  reducer,\n  saga,\n  sagaArgs,\n  initialState,\n  composeEnhancers\n) {\n  const sagaMiddleware = createSagaMiddleware();\n\n  if (!composeEnhancers) {\n    composeEnhancers = compose;\n  }\n\n  let store = createStore(\n    reducer,\n    initialState,\n\n    composeEnhancers(applyMiddleware(sagaMiddleware))\n  );\n\n  sagaMiddleware.run(saga, ...sagaArgs);\n\n  return { store, sagaMiddleware };\n}\n","import configureStore from \"./common\";\nexport default configureStore;\n","export const ADVANCE = \"CONTROLLER_ADVANCE\";\nexport function advance(count) {\n  return { type: ADVANCE, count };\n}\n\nexport const STEP_NEXT = \"CONTROLLER_STEP_NEXT\";\nexport function stepNext() {\n  return { type: STEP_NEXT };\n}\n\nexport const STEP_OVER = \"CONTROLLER_STEP_OVER\";\nexport function stepOver() {\n  return { type: STEP_OVER };\n}\n\nexport const STEP_INTO = \"CONTROLLER_STEP_INTO\";\nexport function stepInto() {\n  return { type: STEP_INTO };\n}\n\nexport const STEP_OUT = \"CONTROLLER_STEP_OUT\";\nexport function stepOut() {\n  return { type: STEP_OUT };\n}\n\nexport const RESET = \"CONTROLLER_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const INTERRUPT = \"CONTROLLER_INTERRUPT\";\nexport function interrupt() {\n  return { type: INTERRUPT };\n}\n\nexport const RUN_TO_END = \"CONTROLLER_RUN_TO_END\";\nexport function runToEnd() {\n  return {\n    type: RUN_TO_END\n  };\n}\n\nexport const CONTINUE = \"CONTROLLER_CONTINUE\";\nexport function continueUntilBreakpoint(breakpoints) {\n  //\"continue\" is not a legal name\n  return {\n    type: CONTINUE,\n    breakpoints\n  };\n}\n\nexport const ADD_BREAKPOINT = \"CONTROLLER_ADD_BREAKPOINT\";\nexport function addBreakpoint(breakpoint) {\n  return {\n    type: ADD_BREAKPOINT,\n    breakpoint\n  };\n}\n\nexport const REMOVE_BREAKPOINT = \"CONTROLLER_REMOVE_BREAKPOINT\";\nexport function removeBreakpoint(breakpoint) {\n  return {\n    type: REMOVE_BREAKPOINT,\n    breakpoint\n  };\n}\n\nexport const REMOVE_ALL_BREAKPOINTS = \"CONTROLLER_REMOVE_ALL_BREAKPOINTS\";\nexport function removeAllBreakpoints() {\n  return {\n    type: REMOVE_ALL_BREAKPOINTS\n  };\n}\n\nexport const SET_INTERNAL_STEPPING = \"CONTROLLER_SET_INTERNAL_STEPPING\";\nexport function setInternalStepping(status) {\n  return {\n    type: SET_INTERNAL_STEPPING,\n    status\n  };\n}\n\nexport const START_STEPPING = \"CONTROLLER_START_STEPPING\";\nexport function startStepping() {\n  return {\n    type: START_STEPPING\n  };\n}\n\nexport const DONE_STEPPING = \"CONTROLLER_DONE_STEPPING\";\nexport function doneStepping() {\n  return {\n    type: DONE_STEPPING\n  };\n}\n","export const START = \"SESSION_START\";\nexport function start(provider, txHash) {\n  return {\n    type: START,\n    provider,\n    txHash //OPTIONAL\n  };\n}\n\nexport const LOAD_TRANSACTION = \"SESSION_LOAD_TRANSACTION\";\nexport function loadTransaction(txHash, options) {\n  return {\n    type: LOAD_TRANSACTION,\n    txHash,\n    options\n  };\n}\n\nexport const INTERRUPT = \"SESSION_INTERRUPT\";\nexport function interrupt() {\n  return { type: INTERRUPT };\n}\n\nexport const UNLOAD_TRANSACTION = \"SESSION_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n\nexport const READY = \"SESSION_READY\";\nexport function ready() {\n  return {\n    type: READY\n  };\n}\n\nexport const WAIT = \"SESSION_WAIT\";\nexport function wait() {\n  return {\n    type: WAIT\n  };\n}\n\nexport const ERROR = \"SESSION_ERROR\";\nexport function error(error) {\n  return {\n    type: ERROR,\n    error\n  };\n}\n\nexport const RECORD_CONTRACTS = \"SESSION_RECORD_CONTRACTS\";\nexport function recordContracts(contexts, sources, contracts) {\n  return {\n    type: RECORD_CONTRACTS,\n    contexts,\n    sources,\n    contracts\n  };\n}\n\nexport const SAVE_TRANSACTION = \"SESSION_SAVE_TRANSACTION\";\nexport function saveTransaction(transaction) {\n  return {\n    type: SAVE_TRANSACTION,\n    transaction\n  };\n}\n\nexport const SAVE_RECEIPT = \"SESSION_SAVE_RECEIPT\";\nexport function saveReceipt(receipt) {\n  return {\n    type: SAVE_RECEIPT,\n    receipt\n  };\n}\n\nexport const SAVE_BLOCK = \"SESSION_SAVE_BLOCK\";\nexport function saveBlock(block) {\n  return {\n    type: SAVE_BLOCK,\n    block\n  };\n}\n\nexport const SET_LIGHT_MODE = \"SESSION_SET_LIGHT_MODE\";\nexport function setLightMode() {\n  return { type: SET_LIGHT_MODE };\n}\n\nexport const SET_FULL_MODE = \"SESSION_SET_FULL_MODE\";\nexport function setFullMode() {\n  return { type: SET_FULL_MODE };\n}\n\nexport const START_FULL_MODE = \"SESSION_START_FULL_MODE\";\nexport function startFullMode() {\n  return {\n    type: START_FULL_MODE\n  };\n}\n\nexport const ADD_COMPILATIONS = \"SESSION_ADD_COMPILATIONS\";\nexport function addCompilations(sources, contexts, contracts) {\n  return {\n    type: ADD_COMPILATIONS,\n    sources,\n    contexts,\n    contracts\n  };\n}\n\nexport const SET_STORAGE_VISIBILITY = \"SESSION_SET_STORAGE_VISIBILITY\";\nexport function setStorageVisibility(visibility) {\n  return {\n    type: SET_STORAGE_VISIBILITY,\n    visibility\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"reselect-tree\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"json-pointer\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/merge\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"semver\");","import { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nconst PAST_END_OF_TRACE = {\n  depth: -1, //this is the part that matters!\n  //the rest of this is just to look like a trace step\n  error: \"\",\n  gas: 0,\n  memory: [],\n  stack: [],\n  storage: {},\n  gasCost: 0,\n  op: \"STOP\",\n  pc: -1 //this is not at all valid but that's fine\n};\n\nlet trace = createSelectorTree({\n  /**\n   * trace.index\n   *\n   * current step index\n   */\n  index: state => state.trace.proc.index,\n\n  /**\n   * trace.loaded\n   * is a trace loaded?\n   */\n  loaded: createLeaf([\"/steps\"], steps => steps !== null),\n\n  /**\n   * trace.finished\n   * is the trace finished?\n   */\n  finished: state => state.trace.proc.finished,\n\n  /**\n   * trace.finishedOrUnloaded\n   *\n   * is the trace finished, including if it's unloaded?\n   */\n  finishedOrUnloaded: createLeaf(\n    [\"/finished\", \"/loaded\"],\n    (finished, loaded) => finished || !loaded\n  ),\n\n  /**\n   * trace.steps\n   *\n   * all trace steps\n   */\n  steps: state => state.trace.transaction.steps,\n\n  /**\n   * trace.stepsRemaining\n   *\n   * number of steps remaining in trace\n   */\n  stepsRemaining: createLeaf(\n    [\"./steps\", \"./index\"],\n    (steps, index) => steps.length - index\n  ),\n\n  /**\n   * trace.step\n   *\n   * current trace step\n   * HACK: if no steps,\n   * we will return a spoofed \"past end\" step\n   */\n  step: createLeaf(\n    [\"./steps\", \"./index\"],\n    (steps, index) =>\n      steps ? (steps.length > 0 ? steps[index] : PAST_END_OF_TRACE) : null //null if no tx loaded\n  ),\n\n  /**\n   * trace.next\n   *\n   * next trace step\n   * HACK: if at the end,\n   * we will return a spoofed \"past end\" step\n   */\n  next: createLeaf([\"./steps\", \"./index\"], (steps, index) =>\n    index < steps.length - 1 ? steps[index + 1] : PAST_END_OF_TRACE\n  ),\n\n  /**\n   * trace.nextOfSameDepth\n   * next trace step that's at the same depth as this one\n   * NOTE: if there is none, will return undefined\n   * (should not be used in such cases)\n   * NOTE: for additional correctness, will stop searching once\n   * it hits something of *lower* depth (yes that makes the name\n   * a little misleading, but the idea is to find the return step\n   * for a given call step)\n   */\n  nextOfSameDepth: createLeaf([\"./steps\", \"./index\"], (steps, index) => {\n    let depth = steps[index].depth;\n    for (let step of steps.slice(index + 1)) {\n      //start searching after current step\n      //using a manual for loop here instead of .find in order to\n      //cut off the search early if needed\n      if (step.depth === depth) {\n        return step;\n      }\n      if (step.depth < depth) {\n        return undefined;\n      }\n    }\n    return undefined;\n  }),\n\n  /**\n   * trace.application\n   */\n  application: {\n    /**\n     * trace.application.submoduleCount\n     */\n    submoduleCount: state => state.trace.application.submoduleCount\n  }\n});\n\nexport default trace;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"bn.js\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport BN from \"bn.js\";\n\nimport trace from \"lib/trace/selectors\";\n\nimport * as Codec from \"@truffle/codec\";\nimport {\n  keccak256,\n  isCallMnemonic,\n  isCreateMnemonic,\n  isShortCallMnemonic,\n  isDelegateCallMnemonicBroad,\n  isDelegateCallMnemonicStrict,\n  isStaticCallMnemonic,\n  isSelfDestructMnemonic\n} from \"lib/helpers\";\n\nconst ZERO_WORD = \"00\".repeat(Codec.Evm.Utils.WORD_SIZE);\n\nfunction determineFullContext(\n  { address, binary },\n  instances,\n  search,\n  contexts\n) {\n  let contextId;\n  let isConstructor = Boolean(binary);\n  if (address) {\n    //if we're in a call to a deployed contract, we must have recorded\n    //the context in the codex, so we don't need to do any further\n    //searching\n    ({ context: contextId, binary } = instances[address]);\n  } else if (isConstructor) {\n    //otherwise, if we're in a constructor, we'll need to actually do a\n    //search\n    contextId = search(binary);\n  } else {\n    //exceptional case: no transaction is loaded\n    return null;\n  }\n\n  if (contextId != undefined) {\n    //if we found the context, use it\n    let context = contexts[contextId];\n    return {\n      ...context,\n      binary\n    };\n  } else {\n    //otherwise we'll construct something default\n    return {\n      binary,\n      isConstructor\n    };\n  }\n}\n\n/**\n * create EVM-level selectors for a given trace step selector\n * may specify additional selectors to include\n */\nfunction createStepSelectors(step, state = null) {\n  let base = {\n    /**\n     * .trace\n     *\n     * trace step info related to operation\n     */\n    trace: createLeaf([step], step => {\n      if (!step) {\n        return null;\n      }\n      let { gasCost, op, pc } = step;\n      return { gasCost, op, pc };\n    }),\n\n    /**\n     * .programCounter\n     */\n    programCounter: createLeaf([\"./trace\"], step => (step ? step.pc : null)),\n\n    /**\n     * .isCall\n     *\n     * whether the opcode will switch to another calling context\n     */\n    isCall: createLeaf([\"./trace\"], step => isCallMnemonic(step.op)),\n\n    /**\n     * .isShortCall\n     *\n     * for calls that only take 6 arguments instead of 7\n     */\n    isShortCall: createLeaf([\"./trace\"], step => isShortCallMnemonic(step.op)),\n\n    /**\n     * .isDelegateCallBroad\n     *\n     * for calls that delegate storage\n     */\n    isDelegateCallBroad: createLeaf([\"./trace\"], step =>\n      isDelegateCallMnemonicBroad(step.op)\n    ),\n\n    /**\n     * .isDelegateCallStrict\n     *\n     * for calls that additionally delegate sender and value\n     */\n    isDelegateCallStrict: createLeaf([\"./trace\"], step =>\n      isDelegateCallMnemonicStrict(step.op)\n    ),\n\n    /**\n     * .isStaticCall\n     */\n    isStaticCall: createLeaf([\"./trace\"], step =>\n      isStaticCallMnemonic(step.op)\n    ),\n\n    /**\n     * .isCreate\n     * (includes CREATE2)\n     */\n    isCreate: createLeaf([\"./trace\"], step => isCreateMnemonic(step.op)),\n\n    /**\n     * .isSelfDestruct\n     */\n    isSelfDestruct: createLeaf([\"./trace\"], step =>\n      isSelfDestructMnemonic(step.op)\n    ),\n\n    /**\n     * .isCreate2\n     */\n    isCreate2: createLeaf([\"./trace\"], step => step.op === \"CREATE2\"),\n\n    /**\n     * .isStore\n     */\n    isStore: createLeaf([\"./trace\"], step => step.op === \"SSTORE\"),\n\n    /**\n     * .isLoad\n     */\n    isLoad: createLeaf([\"./trace\"], step => step.op === \"SLOAD\"),\n\n    /**\n     * .touchesStorage\n     *\n     * whether the instruction involves storage\n     */\n    touchesStorage: createLeaf(\n      [\"./isStore\", \"isLoad\"],\n      (stores, loads) => stores || loads\n    ),\n\n    /**\n     * .isPop\n     * used by data\n     */\n    isPop: createLeaf([\"./trace\"], step => step.op === \"POP\"),\n\n    /**\n     * .isLog\n     */\n    isLog: createLeaf([\"./topicCount\"], topicCount => topicCount !== null),\n\n    /**\n     * .topicCount\n     * returns null if not on a logging step\n     */\n    topicCount: createLeaf([\"./trace\"], step => {\n      if (!step.op) {\n        return null;\n      }\n\n      const match = step.op.match(/LOG(\\d+)/);\n      if (!match) {\n        return null;\n      }\n\n      return Number(match[1]);\n    })\n  };\n\n  if (state) {\n    const isRelative = path =>\n      typeof path === \"string\" &&\n      (path.startsWith(\"./\") || path.startsWith(\"../\"));\n\n    if (isRelative(state)) {\n      state = `../${state}`;\n    }\n\n    Object.assign(base, {\n      /**\n       * .isJump\n       */\n      isJump: createLeaf(\n        [\"./trace\", state],\n        (step, { stack }) =>\n          step.op === \"JUMP\" ||\n          (step.op === \"JUMPI\" && stack[stack.length - 2] !== ZERO_WORD)\n      ),\n\n      /**\n       * .valueStored\n       * the storage written, as determined by looking at the stack\n       * rather than at storage (since valueLoaded is now being done\n       * this way, may as well do valueStored this way as well and\n       * completely remove our dependence on the storage field!)\n       */\n      valueStored: createLeaf([\"./isStore\", state], (isStore, { stack }) => {\n        if (!isStore) {\n          return null;\n        }\n        return stack[stack.length - 2];\n      }),\n\n      /**\n       * .callAddress\n       *\n       * address transferred to by call operation\n       */\n      callAddress: createLeaf(\n        [\"./isCall\", state],\n\n        (isCall, { stack }) => {\n          if (!isCall) {\n            return null;\n          }\n\n          let address = stack[stack.length - 2];\n          return Codec.Evm.Utils.toAddress(address);\n        }\n      ),\n\n      /**\n       * .createBinary\n       *\n       * binary code to execute via create operation\n       */\n      createBinary: createLeaf(\n        [\"./isCreate\", state],\n\n        (isCreate, { stack, memory }) => {\n          if (!isCreate) {\n            return null;\n          }\n\n          // Get the code that's going to be created from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 2], 16) * 2;\n          const length = parseInt(stack[stack.length - 3], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * .callData\n       *\n       * data passed to EVM call\n       */\n      callData: createLeaf(\n        [\"./isCall\", \"./isShortCall\", \"./isCreate\", state],\n        (isCall, short, isCreate, { stack, memory }) => {\n          if (!isCall) {\n            //if it's not a call or create, this is invalid and we return null.\n            //for creations, we return 0x (if you want the binary, use createBinary\n            //instead)\n            return isCreate ? \"0x\" : null;\n          }\n\n          //if it's 6-argument call, the data start and offset will be one spot\n          //higher in the stack than they would be for a 7-argument call, so\n          //let's introduce an offset to handle this\n          let argOffset = short ? 1 : 0;\n\n          // Get the data from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 4 + argOffset], 16) * 2;\n          const length = parseInt(stack[stack.length - 5 + argOffset], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * .callValue\n       *\n       * value for the call (not create); returns null for DELEGATECALL\n       */\n      callValue: createLeaf(\n        [\"./isCall\", \"./isDelegateCallStrict\", \"./isStaticCall\", state],\n        (calls, delegates, isStatic, { stack }) => {\n          if (!calls || delegates) {\n            return null;\n          }\n\n          if (isStatic) {\n            return new BN(0);\n          }\n\n          //otherwise, for CALL and CALLCODE, it's the 3rd argument\n          let value = stack[stack.length - 3];\n          return Codec.Conversion.toBN(value);\n        }\n      ),\n\n      /**\n       * .createValue\n       *\n       * value for the create\n       */\n      createValue: createLeaf([\"./isCreate\", state], (isCreate, { stack }) => {\n        if (!isCreate) {\n          return null;\n        }\n\n        //creates have the value as the first argument\n        let value = stack[stack.length - 1];\n        return Codec.Conversion.toBN(value);\n      }),\n\n      /**\n       * .storageAffected\n       *\n       * storage slot being stored to or loaded from\n       * we do NOT prepend \"0x\"\n       */\n      storageAffected: createLeaf(\n        [\"./touchesStorage\", state],\n\n        (touchesStorage, { stack }) => {\n          if (!touchesStorage) {\n            return null;\n          }\n\n          return stack[stack.length - 1];\n        }\n      ),\n\n      /**\n       * .salt\n       */\n      salt: createLeaf(\n        [\"./isCreate2\", state],\n\n        (isCreate2, { stack }) => {\n          if (!isCreate2) {\n            return null;\n          }\n\n          return \"0x\" + stack[stack.length - 4];\n        }\n      ),\n\n      /**\n       * .callContext\n       *\n       * context of what this step is calling/creating (if applicable)\n       */\n      callContext: createLeaf(\n        [\n          \"./callAddress\",\n          \"./createBinary\",\n          \"/current/codex/instances\",\n          \"/info/binaries/search\",\n          \"/info/contexts\"\n        ],\n        (address, binary, instances, search, contexts) =>\n          determineFullContext({ address, binary }, instances, search, contexts)\n      ),\n\n      /**\n       * .logData\n       *\n       * the data portion of what's getting logged\n       */\n      logData: createLeaf([\"./isLog\", state], (isLog, { stack, memory }) => {\n        if (!isLog) {\n          return null;\n        }\n\n        // Get the data from memory.\n        // Note we multiply by 2 because these offsets are in bytes.\n        // (note the data offset/length comes before the topics, so\n        // we don't neeed ot adjust for the topic count)\n        const offset = parseInt(stack[stack.length - 1], 16) * 2;\n        const length = parseInt(stack[stack.length - 2], 16) * 2;\n\n        return (\n          \"0x\" +\n          memory\n            .join(\"\")\n            .substring(offset, offset + length)\n            .padEnd(length, \"00\")\n        );\n      }),\n\n      /**\n       * .logTopics\n       * returns an array of hex strings\n       */\n      logTopics: createLeaf(\n        [\"./isLog\", \"./topicCount\", state],\n        (isLog, topicCount, { stack }) => {\n          if (!isLog) {\n            return null;\n          }\n\n          //the topics (if any) start with the third argument,\n          //so we take the appropriate number of entries from\n          //the end of the stack (excluding than the last two), then\n          //reverse to put them in order; we also prepend \"0x\" for\n          //convenience\n          //note the use of reverse() is safe due to the use of slice() first\n          return stack\n            .slice(-2 - topicCount, -2)\n            .reverse()\n            .map(word => \"0x\" + word);\n        }\n      )\n    });\n  }\n\n  return base;\n}\n\nconst evm = createSelectorTree({\n  /**\n   * evm.state\n   */\n  state: state => state.evm,\n\n  /**\n   * evm.application\n   */\n  application: {\n    /**\n     * evm.application.storageLookup\n     */\n    storageLookup: createLeaf(\n      [\"/state\"],\n      state => state.application.storageLookup\n    ),\n\n    /**\n     * evm.application.storageLookupSupported\n     */\n    storageLookupSupported: createLeaf(\n      [\"/state\"],\n      state => state.application.storageLookupSupported\n    )\n  },\n\n  /**\n   * evm.info\n   */\n  info: {\n    /**\n     * evm.info.contexts\n     */\n    contexts: createLeaf([\"/state\"], state => state.info.contexts.byContext),\n\n    /**\n     * evm.info.binaries\n     */\n    binaries: {\n      /**\n       * evm.info.binaries.search\n       *\n       * returns function (binary) => context (returns the *ID* of the context)\n       * (returns null on no match)\n       */\n      search: createLeaf(\n        [\"/info/contexts\"],\n        contexts => binary =>\n          //HACK: the type of contexts doesn't actually match!! fortunately\n          //it's good enough to work\n          (\n            Codec.Contexts.Utils.findContext(contexts, binary) || {\n              context: null\n            }\n          ).context\n      )\n    }\n  },\n\n  /**\n   * evm.transaction\n   */\n  transaction: {\n    /**\n     * evm.transaction.globals\n     */\n    globals: {\n      /**\n       * evm.transaction.globals.tx\n       */\n      tx: createLeaf([\"/state\"], state => state.transaction.globals.tx),\n\n      /**\n       * evm.transaction.globals.block\n       */\n      block: createLeaf([\"/state\"], state => state.transaction.globals.block)\n    },\n\n    /**\n     * evm.transaction.blockHash\n     */\n    blockHash: createLeaf(\n      [\"/state\"],\n      state => state.transaction.txIdentification.blockHash\n    ),\n\n    /**\n     * evm.transaction.txIndex\n     */\n    txIndex: createLeaf(\n      [\"/state\"],\n      state => state.transaction.txIdentification.txIndex\n    ),\n\n    /**\n     * evm.transaction.status\n     */\n    status: createLeaf([\"/state\"], state => state.transaction.status),\n\n    /**\n     * evm.transaction.initialCall\n     */\n    initialCall: createLeaf([\"/state\"], state => state.transaction.initialCall),\n\n    /**\n     * evm.transaction.startingContext\n     */\n    startingContext: createLeaf(\n      [\n        \"/current/callstack\", //we're just getting bottom stackframe, so this is in fact tx-level\n        \"/current/codex/instances\", //this should also be fine?\n        \"/info/binaries/search\",\n        \"/info/contexts\"\n      ],\n      (stack, instances, search, contexts) =>\n        stack.length > 0\n          ? determineFullContext(stack[0], instances, search, contexts)\n          : null\n    ),\n\n    /**\n     * evm.transaction.affectedInstances\n     */\n    affectedInstances: createLeaf(\n      [\"/state\"],\n      state => state.transaction.affectedInstances.byAddress\n    )\n  },\n\n  /**\n   * evm.current\n   */\n  current: {\n    /**\n     * evm.current.callstack\n     */\n    callstack: state => state.evm.proc.callstack,\n\n    /**\n     * evm.current.call\n     */\n    call: createLeaf(\n      [\"./callstack\"],\n\n      stack => (stack.length ? stack[stack.length - 1] : {})\n    ),\n\n    /**\n     * evm.current.context\n     */\n    context: createLeaf(\n      [\n        \"./call\",\n        \"./codex/instances\",\n        \"/info/binaries/search\",\n        \"/info/contexts\"\n      ],\n      determineFullContext\n    ),\n\n    /**\n     * evm.current.isIR\n     * was the current context compield with IR on?\n     * currently, this defaults to false; in the future the default\n     * may depend on the Solidity version\n     */\n    isIR: createLeaf([\"./context\"], context =>\n      context.settings ? Boolean(context.settings.viaIR) : false\n    ),\n\n    /**\n     * evm.current.state\n     *\n     * evm state info: as of last operation, before op defined in step\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\"].map(param => ({\n        [param]: createLeaf([trace.step], step => step[param])\n      }))\n    ),\n\n    /**\n     * evm.current.step\n     */\n    step: {\n      ...createStepSelectors(trace.step, \"./state\"),\n\n      //the following step selectors only exist for current, not next or any\n      //other step\n\n      /**\n       * evm.current.step.createdAddress\n       *\n       * address created by the current create step\n       */\n      createdAddress: createLeaf(\n        [\n          \"./isCreate\",\n          \"/nextOfSameDepth/state/stack\",\n          \"./isCreate2\",\n          \"./create2Address\"\n        ],\n        (isCreate, stack, isCreate2, create2Address) => {\n          if (!isCreate) {\n            return null;\n          }\n          let address = stack //may be null if the create step itself fails\n            ? Codec.Evm.Utils.toAddress(stack[stack.length - 1])\n            : Codec.Evm.Utils.ZERO_ADDRESS; //nothing got created, so...\n          if (address === Codec.Evm.Utils.ZERO_ADDRESS && isCreate2) {\n            return create2Address;\n          }\n          return address;\n        }\n      ),\n\n      /**\n       * evm.current.step.create2Address\n       *\n       * address created by the current create2 step\n       * (computed, not read off the return)\n       */\n      create2Address: createLeaf(\n        [\"./isCreate2\", \"./createBinary\", \"../call\", \"../state/stack\"],\n        (isCreate2, binary, { storageAddress }, stack) =>\n          isCreate2\n            ? Codec.Evm.Utils.toAddress(\n                \"0x\" +\n                  keccak256({\n                    type: \"bytes\",\n                    value:\n                      //slice 2's are for cutting off initial \"0x\" where we've prepended this\n                      //0xff, then address, then salt, then code hash\n                      \"0xff\" +\n                      storageAddress.slice(2) +\n                      stack[stack.length - 4] +\n                      keccak256({ type: \"bytes\", value: binary }).slice(2)\n                  }).slice(\n                    2 +\n                      2 *\n                        (Codec.Evm.Utils.WORD_SIZE -\n                          Codec.Evm.Utils.ADDRESS_SIZE)\n                  )\n                //slice off initial 0x and initial 12 bytes (note we've re-prepended the\n                //0x at the beginning)\n              )\n            : null\n      ),\n\n      /**\n       * evm.current.step.isInstantCallOrCreate\n       *\n       * are we doing a call or create for which there are no trace steps?\n       * This can happen if:\n       * 1. we call a precompile\n       * 2. we call an externally-owned account (or other account w/no code)\n       * 3. we do a call or create but the call stack is exhausted\n       * 4. we attempt to transfer more ether than we have\n       */\n      isInstantCallOrCreate: createLeaf(\n        [\"./isCall\", \"./isCreate\", \"./isContextChange\"],\n        (calls, creates, contextChange) => (calls || creates) && !contextChange\n      ),\n\n      /**\n       * evm.current.step.isContextChange\n       * groups together calls, creates, halts, and exceptional halts\n       */\n      isContextChange: createLeaf(\n        [\"/current/state/depth\", \"/next/state/depth\"],\n        (currentDepth, nextDepth) => currentDepth !== nextDepth\n      ),\n\n      /**\n       * evm.current.step.isNormalHalting\n       */\n      isNormalHalting: createLeaf(\n        [\"./isHalting\", \"./returnStatus\"],\n        (isHalting, status) => isHalting && status\n      ),\n\n      /**\n       * evm.current.step.isHalting\n       *\n       * whether the instruction halts or returns from a calling context\n       * HACK: the check for stepsRemainining === 0 is a hack to cover\n       * the special case when there are no trace steps; normally this\n       * is unnecessary because the spoofed step past the end covers it\n       */\n      isHalting: createLeaf(\n        [\"/current/state/depth\", \"/next/state/depth\", trace.stepsRemaining],\n        (currentDepth, nextDepth, stepsRemaining) =>\n          nextDepth < currentDepth || stepsRemaining === 0\n      ),\n\n      /**\n       * evm.current.step.isExceptionalHalting\n       */\n      isExceptionalHalting: createLeaf(\n        [\"./isHalting\", \"./returnStatus\"],\n        (isHalting, status) => isHalting && !status\n      ),\n\n      /**\n       * evm.current.step.returnStatus\n       * checks the return status of the *current* halting instruction or insta-call\n       * returns null if not halting & not an insta-call\n       * (returns a boolean -- true for success, false for failure)\n       */\n      returnStatus: createLeaf(\n        [\n          \"./isHalting\",\n          \"./isInstantCallOrCreate\",\n          \"/next/state\",\n          trace.stepsRemaining,\n          \"/transaction/status\"\n        ],\n        (isHalting, isInstaCall, { stack }, remaining, finalStatus) => {\n          if (!isHalting && !isInstaCall) {\n            return null; //not clear this'll do much good since this may get\n            //read as false, but, oh well, may as well\n          }\n          if (remaining <= 1) {\n            return finalStatus;\n          } else {\n            return stack[stack.length - 1] !== ZERO_WORD;\n          }\n        }\n      ),\n\n      /**\n       * evm.current.step.returnValue\n       *\n       * for a [successful] RETURN or REVERT instruction, the value returned;\n       * we DO prepend \"0x\"\n       * for everything else, including unsuccessful RETURN, just returns \"0x\"\n       * (which is what the return value would be if the instruction were to\n       * fail) (or succeed in the case of STOP or SELFDESTRUCT)\n       * NOTE: technically this will be wrong if a REVERT fails, but that case\n       * is hard to detect and it barely matters\n       */\n      returnValue: createLeaf(\n        [\"./trace\", \"./isExceptionalHalting\", \"../state\"],\n\n        (step, isExceptionalHalting, { stack, memory }) => {\n          if (step.op !== \"RETURN\" && step.op !== \"REVERT\") {\n            return \"0x\";\n          }\n          if (isExceptionalHalting && step.op !== \"REVERT\") {\n            return \"0x\";\n          }\n          // Get the data from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 1], 16) * 2;\n          const length = parseInt(stack[stack.length - 2], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * evm.current.step.valueLoaded\n       * the storage loaded on an SLOAD. determined by examining\n       * the next stack, rather than storage (we're avoiding\n       * relying on storage to support old versions of Geth and Besu)\n       * we do not include an initial \"0x\"\n       */\n      valueLoaded: createLeaf(\n        [\"./isLoad\", \"/next/state\"],\n        (isLoad, { stack }) => {\n          if (!isLoad) {\n            return null;\n          }\n          return stack[stack.length - 1];\n        }\n      ),\n\n      /**\n       * evm.current.step.beneficiary\n       * NOTE: for a value-destroying selfdestruct, returns null\n       */\n      beneficiary: createLeaf(\n        [\"./isSelfDestruct\", \"../state\", \"../call\"],\n\n        (isSelfDestruct, { stack }, { storageAddress: currentAddress }) => {\n          if (!isSelfDestruct) {\n            return null;\n          }\n          const beneficiary = Codec.Evm.Utils.toAddress(\n            stack[stack.length - 1]\n          );\n          return beneficiary !== currentAddress ? beneficiary : null;\n        }\n      )\n    },\n\n    /**\n     * evm.current.codex (namespace)\n     */\n    codex: {\n      /**\n       * evm.current.codex (selector)\n       * the whole codex! not that that's very much at the moment\n       */\n      _: createLeaf([\"/state\"], state => state.proc.codex),\n\n      /**\n       * evm.current.codex.storage\n       * the current storage, as fetched from the codex\n       */\n      storage: createLeaf(\n        [\"./_\", \"../call\"],\n        (codex, { storageAddress }) =>\n          codex[codex.length - 1].accounts[storageAddress].storage\n      ),\n\n      /**\n       * evm.current.codex.instances\n       */\n      instances: createLeaf([\"./_\"], codex =>\n        Object.assign(\n          {},\n          ...Object.entries(codex[codex.length - 1].accounts).map(\n            ([address, { code, context }]) => ({\n              [address]: { address, binary: code, context }\n            })\n          )\n        )\n      )\n    }\n  },\n\n  /**\n   * evm.next\n   */\n  next: {\n    /**\n     * evm.next.state\n     *\n     * evm state as a result of next step operation\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\", \"storage\"].map(param => ({\n        [param]: createLeaf([trace.next], step => step[param])\n      }))\n    ),\n\n    /**\n     * evm.next.step\n     */\n    step: createStepSelectors(trace.next, \"./state\")\n  },\n\n  /**\n   * evm.nextOfSameDepth\n   */\n  nextOfSameDepth: {\n    /**\n     * evm.nextOfSameDepth.state\n     *\n     * evm state at the next step of same depth\n     * individual parts of the state will return null if there\n     * is no such step\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\", \"storage\"].map(param => ({\n        [param]: createLeaf([trace.nextOfSameDepth], step =>\n          step ? step[param] : null\n        )\n      }))\n    )\n  }\n});\n\nexport default evm;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@truffle/source-map-utils\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:sourcemapping:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport SourceMapUtils from \"@truffle/source-map-utils\";\nimport * as Codec from \"@truffle/codec\";\n\nimport semver from \"semver\";\nimport jsonpointer from \"json-pointer\";\n\nimport evm from \"lib/evm/selectors\";\nimport trace from \"lib/trace/selectors\";\n\nfunction contextRequiresPhantomStackframes(context, data) {\n  debug(\"context: %O\", context);\n  debug(\"data: %O\", data);\n  const selector = data\n    .slice(0, 2 + 2 * Codec.Evm.Utils.SELECTOR_SIZE)\n    .padEnd(2 + 2 * Codec.Evm.Utils.SELECTOR_SIZE, \"00\");\n  const hasFallbackOrReceive = (context.abi || []).some(\n    abiEntry => abiEntry.type === \"fallback\" || abiEntry.type === \"receive\"\n  );\n  return (\n    context.primaryLanguage === \"Solidity\" && //do not use phantom frames for Yul or Vyper!\n    context.compiler !== undefined && //(do NOT just put context.compiler here,\n    //we need this to be a boolean, not undefined, because it gets put in the state)\n    context.compiler.name === \"solc\" && //this check is possibly redundant now but I'll keep it in\n    semver.satisfies(context.compiler.version, \">=0.5.1\", {\n      includePrerelease: true\n    }) &&\n    !context.isConstructor && //constructors should not get a phantom stackframe!\n    (!hasFallbackOrReceive || //if there's no fallback or receive, we don't apply the\n      //fallback/receive check on the next line; this is to solve a problem with libraries,\n      //because libraries don't always have a reliable ABI we can use for our purposes here.\n      //fortunately, since libraries don't have fallbacks or receives, the condition isn't\n      //relevant to them anyway!\n      (context.abi || []).some(\n        abiEntry =>\n          abiEntry.type === \"function\" &&\n          Codec.AbiData.Utils.abiSelector(abiEntry) === selector //fallback & receive should not get phantom\n      ))\n  );\n}\n\n//function to create selectors that need both a current and next version\nfunction createMultistepSelectors(stepSelector) {\n  return {\n    /**\n     * .instruction\n     */\n    instruction: createLeaf(\n      [\"/current/instructionAtProgramCounter\", stepSelector.programCounter],\n      //HACK: we use sourcemapping.current.instructionAtProgramCounter\n      //even if we're looking at sourcemapping.next.\n      //This is harmless... so long as the current instruction isn't a context\n      //change.  So, don't use sourcemapping.next when it is.\n\n      (map, pc) => map[pc] || {}\n    ),\n\n    /**\n     * .modifierDepth\n     */\n    modifierDepth: createLeaf(\n      [\"./instruction\"],\n      instruction => instruction.modifierDepth\n    ),\n\n    /**\n     * .source\n     */\n    source: createLeaf(\n      //HACK: same hack as with instruction (we use current sources).\n      //but I don't need to give the same warning twice.\n      [\"/current/sources\", \"./instruction\"],\n\n      (sources, { file: index }) => (sources ? sources[index] || {} : {})\n    ),\n\n    /**\n     * HACK... you get the idea\n     */\n    findOverlappingRange: createLeaf(\n      [\"./source\", \"/current/overlapFunctions\"],\n      ({ index }, functions) => (functions || {})[index]\n    ),\n\n    /**\n     * .sourceRange\n     */\n    sourceRange: createLeaf([\"./instruction\"], SourceMapUtils.getSourceRange),\n\n    /**\n     * .pointerAndNode\n     */\n    pointerAndNode: createLeaf(\n      [\"./findOverlappingRange\", \"./sourceRange\"],\n\n      (findOverlappingRange, range) =>\n        findOverlappingRange\n          ? SourceMapUtils.findRange(\n              findOverlappingRange,\n              range.start,\n              range.length\n            )\n          : null\n    ),\n\n    /**\n     * .pointer\n     */\n    pointer: createLeaf(\n      [\"./pointerAndNode\"],\n\n      pointerAndNode => (pointerAndNode ? pointerAndNode.pointer : null)\n    ),\n\n    /**\n     * .node\n     */\n    node: createLeaf(\n      [\"./source\", \"./pointerAndNode\"],\n\n      ({ ast }, pointerAndNode) => (pointerAndNode ? pointerAndNode.node : ast)\n    ),\n\n    /**\n     * .contractNode\n     * WARNING: ad-hoc selector only meant to be used\n     * when you're on a function node!\n     * should probably be replaced by something better;\n     * the data submodule handles these things a better way\n     */\n    contractNode: createLeaf([\"./source\", \"./pointer\"], ({ ast }, pointer) =>\n      pointer\n        ? jsonpointer.get(\n            ast,\n            pointer.replace(/\\/nodes\\/\\d+$/, \"\") //cut off end\n          )\n        : ast\n    )\n  };\n}\n\nlet sourcemapping = createSelectorTree({\n  /**\n   * sourcemapping.state\n   */\n  state: state => state.sourcemapping,\n\n  /**\n   * sourcemapping.info\n   */\n  info: {\n    /**\n     * sourcemapping.info.sources\n     */\n    sources: createLeaf([\"/state\"], state => state.info.sources)\n  },\n\n  /**\n   * sourcemapping.transaction\n   */\n  transaction: {\n    /**\n     * sourcemapping.transaction.bottomStackframeRequiresPhantomFrame\n     */\n    bottomStackframeRequiresPhantomFrame: createLeaf(\n      [\n        evm.transaction.startingContext,\n        evm.current.callstack //only getting bottom frame so this is tx-level in this context\n      ],\n      (context, callstack) =>\n        contextRequiresPhantomStackframes(context, callstack[0].data)\n    )\n  },\n\n  /**\n   * sourcemapping.current\n   */\n  current: {\n    /**\n     * sourcemapping.current.sourceIds\n     * like sourcemapping.current.sources, but just has the IDs, not the sources\n     */\n    sourceIds: createLeaf(\n      [\"/info/sources\", evm.current.context],\n      (sources, context) => {\n        if (!context) {\n          debug(\"no context\");\n          return null; //no tx loaded, return null\n        }\n\n        const { compilationId, context: contextHash } = context;\n        debug(\"compilationId: %o\", compilationId);\n\n        let userSources = [];\n        let internalSources = [];\n\n        if (compilationId && sources.byCompilationId[compilationId]) {\n          userSources = sources.byCompilationId[compilationId].byIndex;\n        }\n\n        if (sources.byContext[contextHash]) {\n          internalSources = sources.byContext[contextHash].byIndex;\n        }\n\n        //we assign to [] rather than {} because we want the result to be an array\n        return Object.assign([], userSources, internalSources);\n      }\n    ),\n\n    /**\n     * sourcemapping.current.sources\n     * This takes the place of the old sourcemapping.info.sources,\n     * returning only the sources for the current compilation and context.\n     */\n    sources: createLeaf(\n      [\"/views/sources\", \"/current/sourceIds\"],\n      (allSources, ids) => (ids ? ids.map(id => allSources[id]) : null)\n    ),\n\n    /**\n     * sourcemapping.current.sourceMap\n     */\n    sourceMap: createLeaf(\n      [evm.current.context],\n\n      context => (context ? context.sourceMap : null) //null when no tx loaded\n    ),\n\n    /**\n     * sourcemapping.current.humanReadableSourceMap\n     */\n    humanReadableSourceMap: createLeaf([\"./sourceMap\"], sourceMap =>\n      sourceMap ? SourceMapUtils.getHumanReadableSourceMap(sourceMap) : null\n    ),\n\n    /**\n     * sourcemapping.current.functionDepthStack\n     */\n    functionDepthStack: state => state.sourcemapping.proc.functionDepthStack,\n\n    /**\n     * sourcemapping.current.nextFrameIsPhantom\n     */\n    nextFrameIsPhantom: state => state.sourcemapping.proc.nextFrameIsPhantom,\n\n    /**\n     * sourcemapping.current.functionDepth\n     */\n    functionDepth: createLeaf(\n      [\"./functionDepthStack\"],\n      stack => stack[stack.length - 1]\n    ),\n\n    /**\n     * sourcemapping.current.callRequiresPhantomFrame\n     */\n    callRequiresPhantomFrame: createLeaf(\n      [evm.current.step.callContext, evm.current.step.callData],\n      contextRequiresPhantomStackframes\n    ),\n\n    /**\n     * sourcemapping.current.instructions\n     */\n    instructions: createLeaf(\n      [\"./sources\", evm.current.context, \"./humanReadableSourceMap\"],\n\n      (sources, context, sourceMap) => {\n        if (!context) {\n          return [];\n        }\n\n        debug(\"sources before processing: %O\", sources);\n        return SourceMapUtils.getProcessedInstructionsForBinary(\n          (sources || []).map(source => (source ? source.source : undefined)),\n          context.binary,\n          sourceMap\n        );\n      }\n    ),\n\n    /**\n     * sourcemapping.current.instructionAtProgramCounter\n     */\n    instructionAtProgramCounter: createLeaf(\n      [\"./instructions\"],\n\n      instructions =>\n        Object.assign(\n          {},\n          ...instructions.map(instruction => ({\n            [instruction.pc]: instruction\n          }))\n        )\n    ),\n\n    ...createMultistepSelectors(evm.current.step),\n\n    /**\n     * sourcemapping.current.isSourceRangeFinalRaw\n     * the old version; doesn't account for internal-source problems\n     */\n    isSourceRangeFinalRaw: createLeaf(\n      [\n        \"./instructionAtProgramCounter\",\n        evm.current.step.programCounter,\n        evm.next.step.programCounter,\n        evm.current.step.isContextChange\n      ],\n\n      (map, current, next, changesContext) => {\n        if (changesContext || !map[next]) {\n          return true;\n        }\n\n        current = map[current];\n        next = map[next];\n\n        return (\n          current.start != next.start ||\n          current.length != next.length ||\n          current.file != next.file\n        );\n      }\n    ),\n\n    /**\n     * sourcemapping.current.isSourceRangeFinal\n     * if there's no context change, then don't return final\n     * on jumping from a user source to an internal source\n     */\n    isSourceRangeFinal: createLeaf(\n      [\n        \"./isSourceRangeFinalRaw\",\n        \"./source\",\n        \"/next/source\",\n        evm.current.step.isContextChange\n      ],\n\n      (isFinal, currentSource, nextSource, changesContext) => {\n        return (\n          changesContext ||\n          (isFinal && (currentSource.internal || !nextSource.internal))\n        );\n      }\n    ),\n\n    /**\n     * sourcemapping.current.functionsByProgramCounter\n     */\n    functionsByProgramCounter: createLeaf(\n      [\n        \"./instructions\",\n        \"./sources\",\n        \"./overlapFunctions\",\n        evm.current.context\n      ],\n      (instructions, sources, functions, { compilationId }) =>\n        //note: we can skip an explicit null check on sources here because\n        //if sources is null then instructions = [] so the problematic map\n        //never occurs\n        SourceMapUtils.getFunctionsByProgramCounter(\n          instructions,\n          sources.map(({ ast }) => ast),\n          functions,\n          compilationId\n        )\n    ),\n\n    /**\n     * sourcemapping.current.isMultiline\n     */\n    isMultiline: createLeaf(\n      [\"./sourceRange\"],\n\n      ({ lines }) => lines.start.line != lines.end.line\n    ),\n\n    /**\n     * sourcemapping.current.onYulFunctionDefinitionWhileEntering\n     */\n    onYulFunctionDefinitionWhileEntering: createLeaf(\n      [\"./node\", \"./pointer\", \"../next/pointer\"],\n      (node, pointer, nextPointer) =>\n        node &&\n        node.nodeType === \"YulFunctionDefinition\" &&\n        nextPointer !== null &&\n        (nextPointer.startsWith(`${pointer}/body/`) ||\n          nextPointer.startsWith(`${pointer}/returnVariables`))\n      //if neither of these conditions hold, we're seeing the function\n      //as it's being defined, rather than as it's being called.\n      //notice the final slash; when you enter a function, you go *strictly inside*\n      //its body (if you hit the body node itself you are seeing the definition)\n      //(as of Solidity 0.8.4, you may also go to the return parameters)\n    ),\n\n    /**\n     * sourcemapping.current.willJump\n     */\n    willJump: createLeaf([evm.current.step.isJump], isJump => isJump),\n\n    /**\n     * sourcemapping.current.jumpDirection\n     */\n    jumpDirection: createLeaf([\"./instruction\"], (i = {}) => i.jump || \"-\"),\n\n    /**\n     * sourcemapping.current.willCall\n     * note: includes creations, does *not* include instareturns\n     */\n    willCall: createLeaf(\n      [\n        evm.current.step.isCall,\n        evm.current.step.isCreate,\n        evm.current.step.isInstantCallOrCreate\n      ],\n      (isCall, isCreate, isInstant) => (isCall || isCreate) && !isInstant\n    ),\n\n    /**\n     * sourcemapping.current.willReturn\n     *\n     * covers both normal returns & failures\n     */\n    willReturn: createLeaf(\n      [evm.current.step.isHalting],\n      isHalting => isHalting\n    ),\n\n    /**\n     * sourcemapping.current.nextUserStep\n     * returns the next trace step after this one which is sourcemapped to\n     * a user source (not -1 or an internal source)\n     * HACK: this assumes we're not about to change context! don't use this if\n     * we are!\n     * ALSO, this may return undefined, so be prepared for that\n     */\n    nextUserStep: createLeaf(\n      [\n        \"./instructionAtProgramCounter\",\n        \"/current/sources\",\n        trace.steps,\n        trace.index\n      ],\n      (map, sources, steps, index) =>\n        steps\n          .slice(index + 1)\n          .find(\n            ({ pc }) =>\n              map[pc] &&\n              map[pc].file !== -1 &&\n              !(sources[map[pc].file] && sources[map[pc].file].internal)\n          )\n    ),\n\n    /**\n     * sourcemapping.current.overlapFunctions\n     * like sourcemapping.views.overlapFunctions, but just returns\n     * an array appropriate to the current context (like sourcemapping.current.sources)\n     */\n    overlapFunctions: createLeaf(\n      [\"/views/overlapFunctions\", \"/current/sourceIds\"],\n      (functions, ids) => (ids ? ids.map(id => functions[id]) : null)\n    )\n  },\n\n  /**\n   * sourcemapping.next\n   * HACK WARNING: do not use these selectors when the current instruction is a\n   * context change! (evm call or evm return)\n   */\n  next: createMultistepSelectors(evm.next.step),\n\n  /**\n   * sourcemapping.views\n   */\n  views: {\n    /**\n     * sourcemapping.views.sources\n     * just the byId part of sourcemapping.info.sources\n     * (effectively flattening them)\n     */\n    sources: createLeaf([\"/info/sources\"], sources => sources.byId),\n\n    /**\n     * sourcemapping.views.overlapFunctions\n     * organized by source ID\n     */\n    overlapFunctions: createLeaf([\"/views/sources\"], sources =>\n      Object.assign(\n        {},\n        ...Object.entries(sources).map(([id, { ast }]) => ({\n          [id]: SourceMapUtils.makeOverlapFunction(ast)\n        }))\n      )\n    )\n  }\n});\n\nexport default sourcemapping;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/zipWith\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport trace from \"lib/trace/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport sourcemapping from \"lib/sourcemapping/selectors\";\n\nimport zipWith from \"lodash/zipWith\";\nimport { popNWhere } from \"lib/helpers\";\nimport * as Codec from \"@truffle/codec\";\n\nconst identity = x => x;\n\nfunction generateReport(rawStack, location, status, message) {\n  //step 1: process combined frames\n  let callstack = [];\n  //we're doing a C-style loop here!\n  //because we want to skip some items <grin>\n  for (let i = 0; i < rawStack.length; i++) {\n    const frame = rawStack[i];\n    if (\n      frame.combineWithNextInternal &&\n      i < rawStack.length - 1 &&\n      rawStack[i + 1].type === \"internal\" &&\n      !rawStack[i + 1].sourceIsInternal\n    ) {\n      const combinedFrame = {\n        ...rawStack[i + 1],\n        calledFromLocation: frame.calledFromLocation\n        //note: since the next frame is internal, it will have the\n        //same address as this, so we don't have to specify which\n        //one to take the address from\n        //(same with isConstructor)\n      };\n      callstack.push(combinedFrame);\n      i++; //!! SKIP THE NEXT FRAME!\n    } else {\n      //ordinary case: just push the frame\n      callstack.push(frame);\n    }\n  }\n  debug(\"callstack: %O\", callstack);\n  //step 2: shift everything over by 1 and recombine :)\n  let locations = callstack.map(frame => frame.calledFromLocation);\n  //remove initial null, add final location on end\n  locations.shift();\n  locations.push(location);\n  debug(\"locations: %O\", locations);\n  const names = callstack.map(\n    ({ functionName, contractName, address, isConstructor, type }) => ({\n      functionName,\n      contractName,\n      address,\n      isConstructor,\n      type\n    })\n  );\n  debug(\"names: %O\", names);\n  let report = zipWith(locations, names, (location, nameInfo) => ({\n    ...nameInfo,\n    location\n  }));\n  //finally: set the status in the top frame\n  //and the message in the bottom\n  if (status !== null) {\n    report[report.length - 1].status = status;\n  }\n  if (message !== undefined) {\n    if (message.Error !== undefined) {\n      report[0].message = message.Error;\n    } else if (message.Panic !== undefined) {\n      report[0].panic = message.Panic;\n    } else if (message.custom !== undefined) {\n      report[0].custom = message.custom;\n    }\n  }\n  return report;\n}\n\nfunction createMultistepSelectors(stepSelector) {\n  return {\n    /**\n     * .location\n     */\n    location: {\n      /**\n       * .source\n       */\n      source: createLeaf([stepSelector.source], identity),\n      /**\n       * .sourceRange\n       */\n      sourceRange: createLeaf([stepSelector.sourceRange], identity),\n      /**\n       * .node\n       */\n      node: createLeaf([stepSelector.node], identity),\n      /**\n       * .pointer\n       */\n      pointer: createLeaf([stepSelector.pointer], identity)\n    },\n\n    /**\n     * .sourceIsInternal\n     */\n    sourceIsInternal: createLeaf(\n      [\"./location/source\"],\n      source => source.id === undefined || source.internal\n    ),\n\n    /**\n     * .strippedLocation\n     */\n    strippedLocation: createLeaf(\n      [\"./location/source\", \"./location/sourceRange\", \"./location/node\"],\n      ({ id, sourcePath, internal }, sourceRange, node) => ({\n        source: { id, sourcePath, internal },\n        sourceRange,\n        node: node ? { id: node.id } : null\n      })\n    ),\n\n    /**\n     * .contractNode\n     * WARNING: see the warning in sourcemapping before\n     * using this selector!\n     */\n    contractNode: createLeaf([stepSelector.contractNode], identity)\n  };\n}\n\nlet stacktrace = createSelectorTree({\n  /**\n   * stacktrace.state\n   */\n  state: state => state.stacktrace,\n\n  /**\n   * stacktrace.transaction\n   */\n  transaction: {\n    /**\n     * stacktrace.transaction.initialCallCombinesWithNextJumpIn\n     */\n    initialCallCombinesWithNextJumpIn: createLeaf(\n      [sourcemapping.transaction.bottomStackframeRequiresPhantomFrame],\n      identity\n    )\n  },\n\n  /**\n   * stacktrace.current\n   */\n  current: {\n    /**\n     * stacktrace.current.callstack\n     */\n    callstack: createLeaf([\"/state\"], state => state.proc.callstack),\n\n    /**\n     * stacktrace.current.returnCounter\n     */\n    returnCounter: createLeaf([\"/state\"], state => state.proc.returnCounter),\n\n    /**\n     * stacktrace.current.lastPosition\n     */\n    lastPosition: createLeaf([\"/state\"], state => state.proc.lastPosition),\n\n    /**\n     * stacktrace.current.innerReturnPosition\n     */\n    innerReturnPosition: createLeaf(\n      [\"/state\"],\n      state => state.proc.innerReturnPosition\n    ),\n\n    /**\n     * stacktrace.current.innerReturnStatus\n     */\n    innerReturnStatus: createLeaf(\n      [\"/state\"],\n      state => state.proc.innerReturnStatus\n    ),\n\n    /**\n     * stacktrace.current.innerErrorIndex\n     * Index of the most recent error (but not this)\n     */\n    innerErrorIndex: createLeaf(\n      [\"/state\"],\n      state => state.proc.innerErrorIndex\n    ),\n\n    ...createMultistepSelectors(sourcemapping.current),\n\n    /**\n     * stacktrace.current.index\n     */\n    index: createLeaf([trace.index], identity),\n\n    /**\n     * stacktrace.current.updateIndex\n     * We only want to update the index if:\n     * 1. the return counter is 0 (we're not in the middle of an\n     * error already being thrown -- we want to keep it at the\n     * initial index for that error)\n     * 2. we're not on the last step (we don't want to accidentally\n     * save the final step as the last error, it would be confusing)\n     * 3. the return status is actually false\n     */\n    updateIndex: createLeaf(\n      [\"./returnCounter\", trace.stepsRemaining, \"./returnStatus\"],\n      (returnCounter, stepsRemaining, returnStatus) =>\n        returnCounter === 0 && stepsRemaining > 1 && !returnStatus\n    ),\n\n    /**\n     * stacktrace.current.willJumpIn\n     */\n    willJumpIn: createLeaf(\n      [sourcemapping.current.willJump, sourcemapping.current.jumpDirection],\n      (willJump, jumpDirection) => willJump && jumpDirection === \"i\"\n    ),\n\n    /**\n     * stacktrace.current.willJumpOut\n     */\n    willJumpOut: createLeaf(\n      [sourcemapping.current.willJump, sourcemapping.current.jumpDirection],\n      (willJump, jumpDirection) => willJump && jumpDirection === \"o\"\n    ),\n\n    /**\n     * stacktrace.current.willCall\n     * note: includes creations!\n     */\n    willCall: createLeaf([sourcemapping.current.willCall], identity),\n\n    /**\n     * stacktrace.current.context\n     */\n    context: createLeaf([evm.current.context], identity),\n\n    /**\n     * stacktrace.current.callContext\n     */\n    callContext: createLeaf([evm.current.step.callContext], identity),\n\n    /**\n     * stacktrace.current.callCombinesWithNextJumpIn\n     */\n    callCombinesWithNextJumpIn: createLeaf(\n      [sourcemapping.current.callRequiresPhantomFrame],\n      identity\n    ),\n\n    /**\n     * stacktrace.current.willReturn\n     */\n    willReturn: createLeaf([sourcemapping.current.willReturn], identity),\n\n    /**\n     * stacktrace.current.returnStatus\n     */\n    returnStatus: createLeaf([evm.current.step.returnStatus], identity),\n\n    /**\n     * stacktrace.current.address\n     * Initial call can't be a delegate, so we just use the storage address\n     * (thus allowing us to handle both calls & creates in one)\n     */\n    address: createLeaf([evm.current.call], call => call.storageAddress),\n\n    /**\n     * stacktrace.current.callAddress\n     *\n     * Covers both calls and creates\n     * NOTE: for this selector, we treat delegates just like any other call!\n     * we want to report the *code* address here, not the storage address\n     * (exception: for creates we report the storage address, as that's where\n     * the code *will* live)\n     */\n    callAddress: createLeaf(\n      [\n        evm.current.step.isCall,\n        evm.current.step.isCreate,\n        evm.current.step.callAddress,\n        evm.current.step.createdAddress\n      ],\n      (isCall, isCreate, callAddress, createdAddress) => {\n        if (isCall) {\n          return callAddress;\n        } else if (isCreate) {\n          if (createdAddress !== Codec.Evm.Utils.ZERO_ADDRESS) {\n            return createdAddress;\n          } else {\n            return undefined; //if created address appears to be 0, omit it\n          }\n        } else {\n          return null; //I guess??\n        }\n      }\n    ),\n\n    /**\n     * stacktrace.current.revertString\n     * Crudely decodes the current revert string, OR the current panic,\n     * *or* an indication of a custom error (but not what, we can't do\n     * that here)\n     * Returns { Error: <string> } or { Panic: <BN> } or { custom: true }\n     * (or undefined)\n     * Not meant to account for crazy things, just there to produce\n     * a simple string or number.\n     * NOTE: if panic code is overlarge, we'll use -1 instead to indicate\n     * an unknown type of panic.\n     */\n    revertString: createLeaf(\n      [evm.current.step.returnValue],\n      rawRevertMessage => {\n        let revertDecodings = Codec.decodeRevert(\n          Codec.Conversion.toBytes(rawRevertMessage)\n        );\n        if (\n          revertDecodings.length === 1 &&\n          revertDecodings[0].kind === \"revert\"\n        ) {\n          const decoding = revertDecodings[0];\n          switch (decoding.abi.name) {\n            case \"Error\":\n              const revertStringInfo = decoding.arguments[0].value.value;\n              switch (revertStringInfo.kind) {\n                case \"valid\":\n                  return { Error: revertStringInfo.asString };\n                case \"malformed\":\n                  //turn into a JS string while smoothing over invalid UTF-8\n                  //slice 2 to remove 0x prefix\n                  return {\n                    Error: Buffer.from(\n                      revertStringInfo.asHex.slice(2),\n                      \"hex\"\n                    ).toString()\n                  };\n              }\n            case \"Panic\":\n              const panicCode = decoding.arguments[0].value.value.asBN;\n              return { Panic: panicCode };\n            default:\n              return undefined;\n          }\n        } else if (revertDecodings.length === 0) {\n          return { custom: true };\n        } else {\n          return undefined;\n        }\n      }\n    ),\n\n    /**\n     * stacktrace.current.positionWillChange\n     * note: we disregard internal sources here!\n     */\n    positionWillChange: createLeaf(\n      [\"/next/location\", \"/current/location\", \"./lastPosition\"],\n      (nextLocation, currentLocation, lastLocation) => {\n        let oldLocation =\n          currentLocation.source.id !== undefined &&\n          !currentLocation.source.internal\n            ? currentLocation\n            : lastLocation;\n        return (\n          Boolean(oldLocation) && //if there's no current or last position, we don't need this check\n          Boolean(nextLocation.source) &&\n          nextLocation.source.id !== undefined && //if next location is unmapped, we consider ourselves to have not moved\n          !nextLocation.source.internal && //similarly if it's internal\n          (nextLocation.source.id !== oldLocation.source.id ||\n            nextLocation.sourceRange.start !== oldLocation.sourceRange.start ||\n            nextLocation.sourceRange.length !== oldLocation.sourceRange.length)\n        );\n      }\n    ),\n\n    /**\n     * stacktrace.current.finalReport\n     * Contains the report object for outside consumption.\n     * Still needs to be processed into a string, mind you.\n     */\n    finalReport: createLeaf(\n      [\n        \"./callstack\",\n        \"./innerReturnPosition\",\n        \"./innerReturnStatus\",\n        \"./revertString\"\n      ],\n      generateReport\n    ),\n\n    /**\n     * stacktrace.current.report\n     * Similar to stacktrace.current.report, but meant for use as at\n     * an intermediate point instead of at the end (it reflects how things\n     * actually currently are rather than taking into account exited\n     * stackframes that caused the revert)\n     */\n    report: createLeaf(\n      [\n        \"./callstack\",\n        \"./returnCounter\",\n        \"./lastPosition\",\n        \"/current/strippedLocation\"\n      ],\n      (callstack, returnCounter, lastPosition, currentLocation) =>\n        generateReport(\n          popNWhere(\n            callstack,\n            returnCounter,\n            frame => frame.type === \"external\"\n          ),\n          currentLocation || lastPosition,\n          null,\n          undefined\n        )\n    )\n  },\n\n  /**\n   * stacktrace.next\n   */\n  next: {\n    ...createMultistepSelectors(sourcemapping.next)\n  }\n});\n\nexport default stacktrace;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport jsonpointer from \"json-pointer\";\nimport merge from \"lodash/merge\";\nimport semver from \"semver\";\n\nimport { stableKeccak256, makePath } from \"lib/helpers\";\n\nimport trace from \"lib/trace/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport sourcemapping from \"lib/sourcemapping/selectors\";\nimport stacktrace from \"lib/stacktrace/selectors\";\n\nimport * as Codec from \"@truffle/codec\";\n\n/**\n * @private\n */\nconst identity = x => x;\n\nfunction solidityVersionHasNoNow(compiler) {\n  return (\n    compiler &&\n    compiler.name === \"solc\" &&\n    //want to include prerelease versions of 0.7.0\n    semver.satisfies(compiler.version, \"~0.7 || >=0.7.0\", {\n      includePrerelease: true\n    })\n  );\n}\n\nfunction findAncestorOfType(node, types, scopes, pointer = null, root = null) {\n  //note: you may want to include \"SourceUnit\" as a fallback type when using\n  //this function for convenience.\n  //you only need to pass pointer and root if you want this function to work\n  //from Yul.  Otherwise you can omit those and you'll get null if you happen\n  //to be in Yul.\n  while (node && !types.includes(node.nodeType)) {\n    if (node.id !== undefined) {\n      node = scopes[scopes[node.id].parentId].definition;\n    } else {\n      if (pointer === null || root === null || pointer === \"\") {\n        //if we're trying to go up from the root but are still in Yul,\n        //or if we weren't given pointer and root at all,\n        //admit failure and return null\n        return null;\n      }\n      pointer = pointer.replace(/\\/[^/]*$/, \"\"); //chop off end\n      node = jsonpointer.get(root, pointer);\n    }\n  }\n  return node;\n}\n\n//given a modifier invocation (or inheritance specifier) node,\n//get the node for the actual modifier (or constructor)\nfunction modifierForInvocation(invocation, scopes) {\n  let rawId; //raw referencedDeclaration ID extracted from the AST.\n  //if it's a modifier this is what we want, but if it's base\n  //constructor, we'll get the contract instead, and need to find its\n  //constructor.\n  switch (invocation.nodeType) {\n    case \"ModifierInvocation\":\n      rawId = invocation.modifierName.referencedDeclaration;\n      break;\n    case \"InheritanceSpecifier\":\n      rawId = invocation.baseName.referencedDeclaration;\n      break;\n    default:\n      debug(\"bad invocation node\");\n  }\n  let rawNode = scopes[rawId].definition;\n  switch (rawNode.nodeType) {\n    case \"ModifierDefinition\":\n      return rawNode;\n    case \"ContractDefinition\":\n      return rawNode.nodes.find(\n        node =>\n          node.nodeType === \"FunctionDefinition\" &&\n          Codec.Ast.Utils.functionKind(node) === \"constructor\"\n      );\n    default:\n      //we should never hit this case\n      return undefined;\n  }\n}\n\n//see data.views.contexts for an explanation\nfunction debuggerContextToDecoderContext(context) {\n  let {\n    context: contextHash,\n    contractName,\n    binary,\n    contractId,\n    contractKind,\n    isConstructor,\n    abi,\n    payable,\n    compiler,\n    compilationId\n  } = context;\n  return {\n    context: contextHash,\n    contractName,\n    binary,\n    contractId,\n    contractKind,\n    isConstructor,\n    abi: Codec.AbiData.Utils.computeSelectors(abi),\n    fallbackAbi: {\n      fallback: (abi || []).find(item => item.type === \"fallback\") || null,\n      receive: (abi || []).find(item => item.type === \"receive\") || null\n    },\n    payable,\n    compiler,\n    compilationId\n  };\n}\n\n//spoofed definitions we'll need\n//we'll give them id -1 to indicate that they're spoofed\n\nexport const NOW_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"now\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_uint256\",\n    typeString: \"uint256\"\n  }\n};\n\nexport const MSG_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"msg\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_message\",\n    typeString: \"msg\"\n  }\n};\n\nexport const TX_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"tx\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_transaction\",\n    typeString: \"tx\"\n  }\n};\n\nexport const BLOCK_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"block\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_block\",\n    typeString: \"block\"\n  }\n};\n\nfunction spoofThisDefinition(contractName, contractId, contractKind) {\n  let formattedName = contractName.replace(/\\$/g, \"$$\".repeat(3));\n  //note that string.replace treats $'s specially in the replacement string;\n  //we want 3 $'s for each $ in the input, so we need to put *6* $'s in the\n  //replacement string\n  return {\n    id: -1,\n    src: \"0:0:-1\",\n    name: \"this\",\n    nodeType: \"VariableDeclaration\",\n    typeDescriptions: {\n      typeIdentifier: \"t_contract$_\" + formattedName + \"_$\" + contractId,\n      typeString: contractKind + \" \" + contractName\n    }\n  };\n}\n\nconst data = createSelectorTree({\n  state: state => state.data,\n\n  /**\n   * data.views\n   */\n  views: {\n    /**\n     * data.views.atLastInstructionForSourceRange\n     */\n    atLastInstructionForSourceRange: createLeaf(\n      [sourcemapping.current.isSourceRangeFinal],\n      final => final\n    ),\n\n    /**\n     * data.views.scopes (namespace)\n     */\n    scopes: {\n      /**\n       * data.views.scopes (selector)\n       * the raw scopes data, just with intermediate\n       * layers cut out\n       * (no inheritance, no inlining)\n       */\n      _: createLeaf([\"/info/scopes\"], scopes =>\n        Object.assign(\n          {},\n          ...Object.entries(scopes).map(([sourceId, { byAstRef: nodes }]) => ({\n            [sourceId]: nodes\n          }))\n        )\n      ),\n\n      /**\n       * data.views.scopes.inlined\n       * inlines, but still no inheritance data\n       */\n      inlined: createLeaf(\n        [\"./_\", sourcemapping.views.sources],\n\n        (scopes, sources) =>\n          Object.assign(\n            {},\n            ...Object.entries(scopes).map(([sourceId, nodes]) => ({\n              [sourceId]: Object.assign(\n                {},\n                ...Object.entries(nodes).map(([astRef, scope]) => ({\n                  [astRef]: {\n                    ...scope,\n                    definition: jsonpointer.get(\n                      sources[scope.sourceId].ast,\n                      scope.pointer\n                    )\n                  }\n                }))\n              )\n            }))\n          )\n      )\n    },\n\n    /**\n     * data.views.userDefinedTypesByCompilation\n     */\n    userDefinedTypesByCompilation: createLeaf(\n      [\n        \"/info/userDefinedTypes\",\n        \"./referenceDeclarations\",\n        \"./scopes/inlined\",\n        sourcemapping.views.sources\n      ],\n      (userDefinedTypes, referenceDeclarations, scopes, sources) => {\n        let typesByCompilation = {};\n        for (const { sourceId, id } of userDefinedTypes) {\n          const node = scopes[sourceId][id].definition;\n          const { compilationId, compiler, internal } = sources[sourceId];\n          if (internal) {\n            continue; //just to be sure, we assume generated sources don't define types\n          }\n          const type = Codec.Ast.Import.definitionToStoredType(\n            node,\n            compilationId,\n            compiler,\n            referenceDeclarations[compilationId]\n          );\n          if (!typesByCompilation[compilationId]) {\n            typesByCompilation[compilationId] = {\n              compiler,\n              types: {}\n            };\n          }\n          typesByCompilation[compilationId].types[type.id] = type;\n        }\n        return typesByCompilation;\n      }\n    ),\n\n    /**\n     * data.views.userDefinedTypes\n     * user-defined types for passing to the decoder\n     * NOTE: *not* grouped by compilation or anything, this is flat\n     */\n    userDefinedTypes: createLeaf(\n      [\"./userDefinedTypesByCompilation\"],\n      Codec.Format.Types.forgetCompilations\n    ),\n\n    /**\n     * data.views.contractAllocationInfo\n     */\n    contractAllocationInfo: createLeaf(\n      [\n        \"/info/userDefinedTypes\",\n        \"/views/scopes/inlined\",\n        \"/info/contracts\",\n        sourcemapping.views.sources,\n        evm.info.contexts\n      ],\n      (userDefinedTypes, scopes, contracts, sources, contexts) =>\n        Object.values(userDefinedTypes)\n          .filter(\n            ({ sourceId, id }) =>\n              !sources[sourceId].internal && //again, assuming internal sources don't define contracts\n              scopes[sourceId][id].definition.nodeType === \"ContractDefinition\"\n          )\n          .map(({ sourceId, id }) => {\n            debug(\"id: %O\", id);\n            const compilationId = sources[sourceId].compilationId;\n            debug(\"compilationId: %O\", compilationId);\n            const contract = contracts[compilationId].byAstId[id];\n            const deployedContext = contexts[contract.deployedContext];\n            const constructorContext = contexts[contract.constructorContext];\n            const immutableReferences = (deployedContext || {})\n              .immutableReferences;\n            return {\n              contractNode: scopes[sourceId][id].definition,\n              compilationId,\n              immutableReferences,\n              compiler: sources[sourceId].compiler,\n              abi: contract.abi,\n              deployedContext,\n              constructorContext\n            };\n          })\n    ),\n\n    /**\n     * data.views.referenceDeclarations\n     * grouped by compilation because that's how codec wants it;\n     * for simplicity, we will assume that generated sources never define types!\n     */\n    referenceDeclarations: createLeaf(\n      [\n        \"./scopes/inlined\",\n        \"/info/userDefinedTypes\",\n        \"/info/taggedOutputs\",\n        sourcemapping.views.sources\n      ],\n      (scopes, userDefinedTypes, taggedOutputs, sources) =>\n        merge(\n          {},\n          ...userDefinedTypes.concat(taggedOutputs).map(({ id, sourceId }) => {\n            const source = sources[sourceId];\n            return source.internal\n              ? {} //exclude these\n              : {\n                  [source.compilationId]: {\n                    [id]: scopes[sourceId][id].definition\n                  }\n                };\n          })\n        )\n    ),\n\n    /**\n     * data.views.mappingKeys\n     */\n    mappingKeys: createLeaf(\n      [\"/proc/mappedPaths\", \"/current/address\"],\n      (mappedPaths, address) =>\n        []\n          .concat(\n            ...Object.values(\n              (mappedPaths.byAddress[address] || { byType: {} }).byType\n            ).map(({ bySlotAddress }) => Object.values(bySlotAddress))\n          )\n          .filter(slot => slot.key !== undefined)\n    ),\n\n    /**\n     * data.views.blockNumber\n     * returns block number as string\n     */\n    blockNumber: createLeaf([evm.transaction.globals.block], block =>\n      block.number.toString()\n    ),\n\n    /**\n     * data.views.blockHash\n     */\n    blockHash: createLeaf([evm.transaction.blockHash], identity),\n\n    /**\n     * data.views.txIndex\n     */\n    txIndex: createLeaf([evm.transaction.txIndex], identity),\n\n    /**\n     * data.views.instances\n     * same as evm.current.codex.instances, but we just map address => binary,\n     * we don't bother with context, and also the code is a Uint8Array\n     */\n    instances: createLeaf([evm.current.codex.instances], instances =>\n      Object.assign(\n        {},\n        ...Object.entries(instances).map(([address, { binary }]) => ({\n          [address]: Codec.Conversion.toBytes(binary)\n        }))\n      )\n    ),\n\n    /**\n     * data.views.contexts\n     * same as evm.info.contexts, but:\n     * 1. we strip out fields irrelevant to codec\n     * 2. we alter abi in a few ways ways:\n     * 2a. we strip out everything but functions\n     * 2b. abi is now an object, not an array, and indexed by these signatures\n     * 2c. fallback/receive stuff instead goes in the fallbackAbi field\n     */\n    contexts: createLeaf([evm.info.contexts], contexts =>\n      Object.assign(\n        {},\n        ...Object.values(contexts).map(context => ({\n          [context.context]: debuggerContextToDecoderContext(context)\n        }))\n      )\n    )\n  },\n\n  /**\n   * data.info\n   */\n  info: {\n    /**\n     * data.info.scopes\n     */\n    scopes: createLeaf([\"/state\"], state => state.info.scopes.bySourceId),\n\n    /**\n     * data.info.contracts\n     */\n    contracts: createLeaf(\n      [\"/state\"],\n      state => state.info.contracts.byCompilationId\n    ),\n\n    /**\n     * data.info.allocations\n     */\n    allocations: {\n      /**\n       * data.info.allocations.storage\n       */\n      storage: createLeaf([\"/state\"], state => state.info.allocations.storage),\n\n      /**\n       * data.info.allocations.state\n       */\n      state: createLeaf([\"/state\"], state => state.info.allocations.state),\n\n      /**\n       * data.info.allocations.memory\n       */\n      memory: createLeaf([\"/state\"], state => state.info.allocations.memory),\n\n      /**\n       * data.info.allocations.abi\n       */\n      abi: createLeaf([\"/state\"], state => state.info.allocations.abi),\n\n      /**\n       * data.info.allocations.calldata\n       */\n      calldata: createLeaf(\n        [\"/state\"],\n        state => state.info.allocations.calldata\n      ),\n\n      /**\n       * data.info.allocations.returndata\n       */\n      returndata: createLeaf(\n        [\"/state\"],\n        state => state.info.allocations.returndata\n      ),\n\n      /**\n       * data.info.allocations.event\n       */\n      event: createLeaf([\"/state\"], state => state.info.allocations.event)\n    },\n\n    /**\n     * data.info.userDefinedTypes\n     */\n    userDefinedTypes: createLeaf(\n      [\"/state\"],\n      state => state.info.userDefinedTypes\n    ),\n\n    /**\n     * data.info.taggedOutputs\n     * \"Tagged outputs\" means user-defined things that are output by a contract\n     * (not input to a contract), and which are distinguished by (potentially\n     * ambiguous) selectors.  So, events and custom errors are tagged outputs.\n     * Function arguments are not tagged outputs (they're not outputs).\n     * Return values are not tagged outputs (they don't have a selector).\n     * Built-in errors (Error(string) and Panic(uint))... OK I guess those could\n     * be considered tagged outputs, but we're only looking at user-defined ones\n     * here.\n     */\n    taggedOutputs: createLeaf([\"/state\"], state => state.info.taggedOutputs)\n  },\n\n  /**\n   * data.proc\n   */\n  proc: {\n    /**\n     * data.proc.assignments\n     */\n    assignments: createLeaf([\"/state\"], state => state.proc.assignments.byId),\n\n    /**\n     * data.proc.mappedPaths\n     */\n    mappedPaths: createLeaf([\"/state\"], state => state.proc.mappedPaths)\n  },\n\n  /**\n   * data.current\n   */\n  current: {\n    /**\n     * data.current.state\n     */\n    state: {\n      /**\n       * data.current.state.stack\n       */\n      stack: createLeaf(\n        [evm.current.state.stack],\n\n        words => (words || []).map(word => Codec.Conversion.toBytes(word))\n      ),\n\n      /**\n       * data.current.state.memory\n       */\n      memory: createLeaf(\n        [evm.current.state.memory],\n\n        words => Codec.Conversion.toBytes(words.join(\"\"))\n      ),\n\n      /**\n       * data.current.state.code\n       */\n      code: createLeaf([evm.current.context], ({ binary }) =>\n        Codec.Conversion.toBytes(binary)\n      ),\n\n      /**\n       * data.current.state.calldata\n       */\n      calldata: createLeaf(\n        [evm.current.call],\n\n        ({ data }) => Codec.Conversion.toBytes(data)\n      ),\n\n      /**\n       * data.current.state.eventdata\n       * usually undefined; used for log decoding\n       */\n      eventdata: createLeaf([evm.current.step.logData], data =>\n        data !== null ? Codec.Conversion.toBytes(data) : undefined\n      ),\n\n      /**\n       * data.current.state.eventtopics\n       * usually undefined; used for log decoding\n       */\n      eventtopics: createLeaf([evm.current.step.logTopics], words =>\n        words !== null\n          ? words.map(word => Codec.Conversion.toBytes(word))\n          : undefined\n      ),\n\n      /**\n       * data.current.state.storage\n       */\n      storage: createLeaf(\n        [evm.current.codex.storage],\n\n        mapping =>\n          Object.assign(\n            {},\n            ...Object.entries(mapping).map(([address, word]) => ({\n              [`0x${address}`]: Codec.Conversion.toBytes(word)\n            }))\n          )\n      ),\n\n      /**\n       * data.current.state.specials\n       * I've named these after the solidity variables they correspond to,\n       * which are *mostly* the same as the corresponding EVM opcodes\n       * (FWIW: this = ADDRESS, sender = CALLER, value = CALLVALUE)\n       */\n      specials: createLeaf(\n        [\"/current/address\", evm.current.call, evm.transaction.globals],\n        (address, { sender, value }, { tx, block }) => ({\n          this: Codec.Conversion.toBytes(address),\n\n          sender: Codec.Conversion.toBytes(sender),\n\n          value: Codec.Conversion.toBytes(value),\n\n          //let's crack open that tx and block!\n          ...Object.assign(\n            {},\n            ...Object.entries(tx).map(([variable, value]) => ({\n              [variable]: Codec.Conversion.toBytes(value)\n            }))\n          ),\n\n          ...Object.assign(\n            {},\n            ...Object.entries(block).map(([variable, value]) => ({\n              [variable]: Codec.Conversion.toBytes(value)\n            }))\n          )\n        })\n      )\n    },\n\n    /**\n     * data.current.compilationId\n     */\n    compilationId: createLeaf(\n      [evm.current.context],\n      context => context?.compilationId\n    ),\n\n    /**\n     * data.current.sourceIndex\n     */\n    sourceIndex: createLeaf(\n      [sourcemapping.current.source],\n      ({ index }) => index\n    ),\n\n    /**\n     * data.current.language\n     */\n    language: createLeaf(\n      [sourcemapping.current.source],\n      ({ language }) => language\n    ),\n\n    /**\n     * data.current.internalSourceFor\n     * returns null if in a user source\n     */\n    internalSourceFor: createLeaf(\n      [sourcemapping.current.source],\n      ({ internalFor }) => internalFor || null\n    ),\n\n    /**\n     * data.current.root\n     */\n    root: createLeaf([sourcemapping.current.source], ({ ast }) => ast),\n\n    /**\n     * data.current.scopes (namespace)\n     */\n    scopes: {\n      /**\n       * data.current.scopes (selector)\n       * Replacement for the old data.info.scopes;\n       * that one now contains multi-compilation/context info, this\n       * one contains only the current compilation/context\n       */\n      _: createLeaf([\"./raw\", \"./inlined/raw\"], (scopes, inlined) =>\n        scopes && inlined\n          ? Object.assign(\n              {},\n              ...Object.entries(scopes).map(([id, scope]) => {\n                let definition = inlined[id].definition;\n                if (definition.nodeType === \"ContractDefinition\") {\n                  //contract definition case: process inheritance\n                  debug(\"contract id %d\", id);\n                  let newScope = { ...scope };\n                  //note that Solidity gives us the linearization in order from most\n                  //derived to most base, but we want most base to most derived;\n                  //annoyingly, reverse() is in-place, so we clone with slice() first\n                  const linearizedBaseContractsFromBase =\n                    definition.linearizedBaseContracts.slice().reverse();\n                  linearizedBaseContractsFromBase.pop(); //remove the last element, i.e.,\n                  //the contract itself, because we want to treat that one specially\n                  //now, we put it all together\n                  newScope.variables = []\n                    .concat(\n                      //concatenate the variables lists from the base classes\n                      ...linearizedBaseContractsFromBase.map(\n                        contractId => scopes[contractId].variables || []\n                        //we need the || [] because contracts with no state variables\n                        //have variables undefined rather than empty like you'd expect\n                      )\n                    )\n                    .filter(\n                      variable =>\n                        inlined[variable.astRef].definition.visibility !==\n                        \"private\"\n                      //filter out private variables from the base classes\n                    )\n                    //add in the variables for the contract itself -- note that here\n                    //private variables are not filtered out!\n                    .concat(scopes[id].variables || [])\n                    .filter(variable => {\n                      //HACK: let's filter out those constants we don't know\n                      //how to read.  they'll just clutter things up.\n                      debug(\"variable %O\", variable);\n                      const definition = inlined[variable.astRef].definition;\n                      return (\n                        !(\n                          definition.constant ||\n                          definition.mutability === \"constant\"\n                        ) || Codec.Ast.Utils.isSimpleConstant(definition.value)\n                      );\n                    });\n                  return { [id]: newScope };\n                } else if (definition.nodeType === \"SourceUnit\") {\n                  //source unit case: process imports\n                  let newScope = { ...scope };\n                  //in this case, handling imports in some sort of tree fashion would\n                  //be too much work.  we'll do this the easy way: by checking exported\n                  //symbols for constants.\n                  newScope.variables = Object.values(definition.exportedSymbols)\n                    .map(\n                      array => array[0] //I don't know why these are arrays...?\n                    )\n                    .filter(astRef => {\n                      //restrict to variables, not other exported symbols!\n                      const definition = inlined[astRef].definition;\n                      return (\n                        definition.nodeType === \"VariableDeclaration\" &&\n                        (definition.constant ||\n                          definition.mutability === \"constant\") &&\n                        //HACK: we'll also again filter out constants we don't know how\n                        //to read\n                        Codec.Ast.Utils.isSimpleConstant(definition.value)\n                      );\n                    })\n                    .map(astRef => ({\n                      //we'll have to reconstruct the rest from just the astRef\n                      astRef,\n                      name: inlined[astRef].definition.name,\n                      sourceId: inlined[astRef].sourceId\n                    }));\n                  return { [id]: newScope };\n                } else {\n                  //default case, nothing to process\n                  return { [id]: scope };\n                }\n              })\n            )\n          : null\n      ),\n\n      /**\n       * data.current.scopes.raw\n       * Current scopes, with inheritance not handled and no inlining\n       */\n      raw: createLeaf(\n        [\"/views/scopes\", sourcemapping.current.sourceIds],\n        (scopes, sourceIds) =>\n          sourceIds\n            ? Object.assign({}, ...sourceIds.map(sourceId => scopes[sourceId]))\n            : null\n      ),\n\n      /**\n       * data.current.scopes.inlined (namespace)\n       */\n      inlined: {\n        /**\n         * data.current.scopes.inlined (selector)\n         * Replacement for the old data.views.scopes.inlined;\n         * that one now contains multi-compilation info, this\n         * one contains only the current compilation/context\n         *\n         * Returns null if nothing loaded\n         */\n        _: createLeaf([\"./raw\", \"../_\"], (inlined, scopes) =>\n          inlined\n            ? Object.assign(\n                {},\n                ...Object.entries(inlined).map(([astRef, info]) => ({\n                  [astRef]: {\n                    ...info,\n                    variables: scopes[astRef].variables\n                  }\n                }))\n              )\n            : null\n        ),\n\n        /**\n         * data.current.scopes.inlined.raw\n         * inlines definitions but does not account for inheritance\n         */\n        raw: createLeaf(\n          [\"/views/scopes/inlined\", sourcemapping.current.sourceIds],\n          (scopes, sourceIds) =>\n            sourceIds\n              ? Object.assign(\n                  {},\n                  ...sourceIds.map(sourceId => scopes[sourceId])\n                )\n              : null\n        )\n      }\n    },\n\n    /**\n     * data.current.referenceDeclarations\n     */\n    referenceDeclarations: createLeaf(\n      [\"/views/referenceDeclarations\", \"./compilationId\"],\n      (scopes, compilationId) => scopes[compilationId]\n    ),\n\n    /**\n     * data.current.allocations\n     */\n    allocations: {\n      /**\n       * data.current.allocations.state\n       * Same as data.info.allocations.state, but uses the old allocation\n       * format (more convenient for debugger) where members are stored by ID\n       * in an object instead of by index in an array; also only holds things\n       * from the current compilation\n       * ALSO: if we're in a constructor, replaces all code pointers by appropriate\n       * memory pointers :)\n       */\n      state: createLeaf(\n        [\"/info/allocations/state\", \"../compilationId\", evm.current.context],\n        (allAllocations, compilationId, { isConstructor }) => {\n          debug(\"compilationId: %s\", compilationId);\n          debug(\"allAllocations: %o\", allAllocations);\n          const allocations = compilationId\n            ? allAllocations[compilationId]\n            : {};\n          //several-deep clone\n          let transformedAllocations = Object.assign(\n            {},\n            ...Object.entries(allocations).map(([id, allocation]) => ({\n              [id]: {\n                members: allocation.members.map(member => ({ ...member }))\n              }\n            }))\n          );\n          //if we're not in a constructor, we don't need to actually transform it.\n          //if we are...\n          if (isConstructor) {\n            //...we must transform code pointers!\n            for (const id in transformedAllocations) {\n              const allocation = transformedAllocations[id];\n              //here, the magic number 4 is the number of reserved memory slots\n              //at the start of memory.  immutables go immediately afterward.\n              let start = 4 * Codec.Evm.Utils.WORD_SIZE;\n              for (const member of allocation.members) {\n                //if it's not a code pointer, leave it alone\n                if (\n                  member.pointer.location === \"code\" ||\n                  member.pointer.location === \"nowhere\"\n                ) {\n                  //if it is, transform it\n                  member.pointer = {\n                    location: \"memory\",\n                    start,\n                    length: Codec.Evm.Utils.WORD_SIZE\n                  };\n                  start += Codec.Evm.Utils.WORD_SIZE;\n                }\n              }\n            }\n          }\n          //having now transformed code pointers if needed,\n          //we now index by ID\n          return Object.assign(\n            {},\n            ...Object.entries(transformedAllocations).map(\n              ([id, allocation]) => ({\n                [id]: {\n                  members: Object.assign(\n                    {},\n                    ...allocation.members.map(memberAllocation => ({\n                      [memberAllocation.definition.id]: memberAllocation\n                    }))\n                  )\n                }\n              })\n            )\n          );\n        }\n      )\n    },\n\n    /**\n     * data.current.compiler\n     */\n    compiler: createLeaf([evm.current.context], context => context?.compiler),\n\n    /**\n     * data.current.bareLetsInYulAreHit\n     */\n    bareLetsInYulAreHit: createLeaf(\n      [\"./compiler\"],\n      compiler =>\n        compiler !== undefined && //if no compiler we'll assume the old way I guess??\n        compiler.name === \"solc\" &&\n        semver.satisfies(compiler.version, \">=0.6.8\", {\n          includePrerelease: true\n        })\n    ),\n\n    /**\n     * data.current.node\n     */\n    node: createLeaf([sourcemapping.current.node], identity),\n\n    /**\n     * data.current.pointer\n     */\n    pointer: createLeaf([sourcemapping.current.pointer], identity),\n\n    /**\n     * data.current.astRef\n     * returns null when not in a mapped source\n     */\n    astRef: createLeaf(\n      [\n        sourcemapping.current.node,\n        sourcemapping.current.pointer,\n        \"./sourceIndex\"\n      ],\n      (node, pointer, sourceIndex) =>\n        node\n          ? node.id !== undefined\n            ? node.id\n            : makePath(sourceIndex, pointer)\n          : null\n    ),\n\n    /**\n     * data.current.scope\n     * old alias for data.current.node (deprecated)\n     */\n    scope: createLeaf([\"./node\"], identity),\n\n    /**\n     * data.current.contract\n     * warning: may return null or similar, even though SourceUnit is included\n     * as fallback\n     */\n    contract: createLeaf(\n      [\"./node\", \"./scopes/inlined\", \"./pointer\", \"./root\"],\n      (node, scopes, pointer, root) => {\n        const types = [\"ContractDefinition\", \"SourceUnit\"];\n        //SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes, pointer, root);\n      }\n    ),\n\n    /**\n     * data.current.contractForBytecode\n     * contract node for the executing bytecode -- *not* the current position!\n     * probably not what you usually want\n     */\n    contractForBytecode: createLeaf(\n      [evm.current.context, \"./scopes/inlined\"],\n      ({ contractId }, scopes) =>\n        (scopes[contractId] || { definition: null }).definition\n    ),\n\n    /**\n     * data.current.fallbackOutputForContext\n     * returns null if none\n     */\n    fallbackOutputForContext: createLeaf(\n      [\"./contractForBytecode\"],\n      contract => {\n        if (!contract) {\n          return null;\n        }\n        const fallbackDefinition = contract.nodes.find(\n          node =>\n            node.nodeType === \"FunctionDefinition\" &&\n            Codec.Ast.Utils.functionKind(node) === \"fallback\"\n        );\n        if (!fallbackDefinition) {\n          return null;\n        }\n        return fallbackDefinition.returnParameters.parameters[0] || null;\n      }\n    ),\n\n    /**\n     * data.current.function\n     * may be modifier rather than function!\n     */\n    function: createLeaf(\n      [\"./node\", \"./scopes/inlined\", \"./pointer\", \"./root\"],\n      (node, scopes, pointer, root) => {\n        const types = [\n          \"FunctionDefinition\",\n          \"ModifierDefinition\",\n          \"ContractDefinition\",\n          \"SourceUnit\"\n        ];\n        //SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes, pointer, root);\n      }\n    ),\n\n    /**\n     * data.current.inModifier\n     */\n    inModifier: createLeaf(\n      [\"./function\"],\n      node => node && node.nodeType === \"ModifierDefinition\"\n    ),\n\n    /**\n     * data.current.inFunctionOrModifier\n     */\n    inFunctionOrModifier: createLeaf(\n      [\"./function\"],\n      node =>\n        node &&\n        (node.nodeType === \"FunctionDefinition\" ||\n          node.nodeType === \"ModifierDefinition\")\n    ),\n\n    /**\n     * data.current.functionDepth\n     */\n\n    functionDepth: createLeaf([sourcemapping.current.functionDepth], identity),\n\n    /**\n     * data.current.modifierDepth\n     */\n\n    modifierDepth: createLeaf([sourcemapping.current.modifierDepth], identity),\n\n    /**\n     * data.current.address\n     * NOTE: this is the STORAGE address for the current call, not the CODE\n     * address\n     */\n\n    address: createLeaf([evm.current.call], call => call.storageAddress),\n\n    /**\n     * data.current.functionsByProgramCounter\n     */\n    functionsByProgramCounter: createLeaf(\n      [sourcemapping.current.functionsByProgramCounter],\n      functions => functions\n    ),\n\n    /**\n     * data.current.internalFunctionsTable\n     */\n    internalFunctionsTable: createLeaf(\n      [evm.current.isIR, \"./functionsByProgramCounter\"],\n      //for Solidity compiled with IR turned on, internal function pointers\n      //are encoded by index rather than by PC value.  unfortunately the\n      //indices are hard to predict and so at present we can't decode these\n      //(at least, not without a fair bit more effort).  As such we won't set\n      //up an internal functions table if IR is turned on.\n      (isIR, byPC) => (isIR ? undefined : byPC)\n    ),\n\n    /**\n     * data.current.context\n     */\n    context: createLeaf([evm.current.context], debuggerContextToDecoderContext),\n\n    /**\n     * data.current.fallbackBase\n     * gives the stack position where a fallback input would start\n     * this is 0 if there are no public or external functions, and 1 if there are\n     */\n    fallbackBase: createLeaf(\n      [\"./context\"],\n      ({ abi }) => (Object.keys(abi).length > 0 ? 1 : 0)\n      //note ABI here has been transformed to include functions only\n    ),\n\n    /**\n     * data.current.errorLocation\n     * note: we can't get the actual node from stacktrace,\n     * it doesn't store that\n     */\n    errorLocation: createLeaf(\n      [stacktrace.current.innerReturnPosition, stacktrace.current.lastPosition],\n      (innerLocation, lastLocation) => innerLocation || lastLocation || {}\n    ),\n\n    /**\n     * data.current.errorNode\n     * note: we can't get the actual node from stacktrace,\n     * it only stores the ID\n     */\n    errorNode: createLeaf(\n      [\"./errorLocation\", \"/views/scopes/inlined\"],\n      (errorLocation, scopes) => {\n        const sourceId = (errorLocation.source || {}).id;\n        const astId = (errorLocation.node || {}).id;\n        if (sourceId !== undefined && astId !== undefined) {\n          return scopes[sourceId][astId].definition;\n        } else {\n          return null;\n        }\n      }\n    ),\n\n    /**\n     * data.current.errorId\n     * returns a codec-style ID, not just an AST ID\n     * does not assume that the error is on the correct node...\n     * this could be factored into two selectors (one that finds\n     * the node and one that makes the ID)\n     */\n    errorId: createLeaf(\n      [\"./errorNode\", \"./compilationId\"],\n      (errorNode, compilationId) => {\n        if (errorNode === null) {\n          return undefined;\n        }\n        switch (errorNode.nodeType) {\n          case \"RevertStatement\":\n            //I don't think this case should happen, but I'm including it\n            //for extra certainty\n            errorNode = errorNode.errorCall;\n          //DELIBERATE FALL-THROUGH\n          case \"FunctionCall\":\n            if (\n              Codec.Ast.Utils.functionClass(errorNode.expression) !== \"error\"\n            ) {\n              return undefined;\n            }\n            //this should work for both qualified & unqualified errors\n            const errorId = errorNode.expression.referencedDeclaration;\n            return Codec.Contexts.Import.makeTypeId(errorId, compilationId);\n          default:\n            //I'm not going to try to handle other cases that maybe could\n            //occur with the optimizer on\n            return undefined;\n        }\n      }\n    ),\n\n    /**\n     * data.current.eventId\n     * similar to errorId but for events\n     * (and unlike errorId it can just use the current node!)\n     */\n    eventId: createLeaf(\n      [\"./node\", \"./compilationId\"],\n      (eventNode, compilationId) => {\n        if (!eventNode) {\n          return undefined;\n        }\n        switch (eventNode.nodeType) {\n          case \"EmitStatement\":\n            //I don't think this case should happen, but I'm including it\n            //for extra certainty\n            eventNode = eventNode.eventCall;\n          //DELIBERATE FALL-THROUGH\n          case \"FunctionCall\":\n            if (\n              Codec.Ast.Utils.functionClass(eventNode.expression) !== \"event\"\n            ) {\n              return undefined;\n            }\n            //this should work for both qualified & unqualified errors\n            const eventId = eventNode.expression.referencedDeclaration;\n            return Codec.Contexts.Import.makeTypeId(eventId, compilationId);\n          default:\n            //I'm not going to try to handle other cases that maybe could\n            //occur with the optimizer on\n            return undefined;\n        }\n      }\n    ),\n\n    /**\n     * data.current.aboutToModify\n     * HACK\n     * This selector is used to catch those times when we go straight from a\n     * modifier invocation into the modifier itself, skipping over the\n     * definition node (this includes base constructor calls).  So it should\n     * return true when:\n     * 1. we're on the node corresponding to an argument to a modifier\n     * invocation or base constructor call, or, if said argument is a type\n     * conversion, its argument (or nested argument)\n     * 2. the next node is not a FunctionDefinition, ModifierDefinition, or\n     * in the same modifier / base constructor invocation\n     */\n    aboutToModify: createLeaf(\n      [\n        \"./node\",\n        \"./modifierInvocation\",\n        \"./modifierArgumentIndex\",\n        \"/next/node\",\n        \"/next/modifierInvocation\",\n        evm.current.step.isContextChange\n      ],\n      (node, invocation, index, next, nextInvocation, isContextChange) => {\n        //ensure: current instruction is not a context change (because if it is\n        //we cannot rely on the data.next selectors, but also if it is we know\n        //we're not about to call a modifier or base constructor!)\n        //we also want to return false if we can't find things for whatever\n        //reason\n        if (\n          isContextChange ||\n          !node ||\n          node.id === undefined ||\n          !next ||\n          next.id === undefined ||\n          !invocation ||\n          invocation.id === undefined ||\n          !nextInvocation ||\n          nextInvocation.id === undefined\n        ) {\n          return false;\n        }\n\n        //ensure: current position is in a ModifierInvocation or\n        //InheritanceSpecifier (recall that SourceUnit was included as\n        //fallback)\n        if (invocation.nodeType === \"SourceUnit\") {\n          return false;\n        }\n\n        //ensure: next node is not a function definition or modifier definition\n        if (\n          next.nodeType === \"FunctionDefinition\" ||\n          next.nodeType === \"ModifierDefinition\"\n        ) {\n          return false;\n        }\n\n        //ensure: next node is not in the same invocation\n        if (\n          nextInvocation.nodeType !== \"SourceUnit\" &&\n          nextInvocation.id === invocation.id\n        ) {\n          return false;\n        }\n\n        //now: are we on the node corresponding to an argument, or, if\n        //it's a type conversion, its nested argument?\n        if (index === undefined) {\n          return false;\n        }\n        let argument = invocation.arguments[index];\n        while (argument.kind === \"typeConversion\") {\n          if (node.id === argument.id) {\n            return true;\n          }\n          argument = argument.arguments[0];\n        }\n        return node.id === argument.id;\n      }\n    ),\n\n    /**\n     * data.current.modifierInvocation\n     */\n    modifierInvocation: createLeaf(\n      [\"./node\", \"./scopes/inlined\"],\n      (node, scopes) => {\n        const types = [\n          \"ModifierInvocation\",\n          \"InheritanceSpecifier\",\n          \"SourceUnit\"\n        ];\n        //again, SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes);\n      }\n    ),\n\n    /**\n     * data.current.modifierArgumentIndex\n     * gets the index of the current modifier argument that you're in\n     * (undefined when not in a modifier argument)\n     */\n    modifierArgumentIndex: createLeaf(\n      [\"./scopes\", \"./node\", \"./modifierInvocation\"],\n      (scopes, node, invocation) => {\n        if (!invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        let pointer = scopes[node.id].pointer;\n        let invocationPointer = scopes[invocation.id].pointer;\n\n        //slice the invocation pointer off the beginning\n        let difference = pointer.slice(invocationPointer.length);\n        debug(\"difference %s\", difference);\n        let rawIndex = difference.match(/^\\/arguments\\/(\\d+)/);\n        //note that that \\d+ is greedy\n        debug(\"rawIndex %o\", rawIndex);\n        if (rawIndex === null) {\n          return undefined;\n        }\n        return parseInt(rawIndex[1]);\n      }\n    ),\n\n    /**\n     * data.current.modifierBeingInvoked\n     * gets the node corresponding to the modifier or base constructor\n     * being invoked\n     */\n    modifierBeingInvoked: createLeaf(\n      [\"./modifierInvocation\", \"./scopes/inlined\"],\n      (invocation, scopes) => {\n        if (!invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        return modifierForInvocation(invocation, scopes);\n      }\n    ),\n\n    /**\n     * data.current.onYulFunctionDefinitionWhileEntering\n     */\n    onYulFunctionDefinitionWhileEntering: createLeaf(\n      [sourcemapping.current.onYulFunctionDefinitionWhileEntering],\n      identity\n    ),\n\n    /**\n     * data.current.identifiers (namespace)\n     */\n    identifiers: {\n      /**\n       * data.current.identifiers (selector)\n       *\n       * returns identifers and corresponding definition node ID or builtin name\n       * (object entries look like [name]: {astRef: astRef}, [name]: {builtin: name})\n       */\n      _: createLeaf(\n        [\n          \"/current/scopes/inlined\",\n          \"/current/node\",\n          \"/current/pointer\",\n          \"/current/sourceIndex\",\n          \"/current/language\"\n        ],\n\n        (scopes, scope, pointer, sourceId, language) => {\n          let variables = {};\n          if (scope !== undefined) {\n            let cur =\n              scope.id !== undefined ? scope.id : makePath(sourceId, pointer);\n\n            while (cur !== null && scopes[cur]) {\n              debug(\"cur: %o\", cur);\n              debug(\"scopes[cur]: %o\", scopes[cur]);\n              variables = Object.assign(\n                variables,\n                ...(scopes[cur].variables || [])\n                  .filter(variable => variable.name !== \"\") //exclude anonymous output params\n                  .filter(variable => variables[variable.name] == undefined) //don't add shadowed vars\n                  .map(variable => ({\n                    [variable.name]: { astRef: variable.astRef }\n                  }))\n              );\n\n              if (scopes[cur].definition.nodeType === \"YulFunctionDefinition\") {\n                //Yul functions make the outside invisible\n                break;\n              }\n\n              if (scopes[cur].parentId !== undefined) {\n                cur = scopes[cur].parentId; //may be null!\n                //(undefined means we don't know what's up,\n                //null means there's nothing)\n              } else {\n                //in this case, cur must be a source-and-pointer, so we'll step\n                //up that way (skipping over any arrays)\n                cur = cur.replace(/\\/[^/]*(\\/\\d+)?$/, \"\");\n              }\n            }\n          }\n\n          let builtins = {\n            msg: { builtin: \"msg\" },\n            tx: { builtin: \"tx\" },\n            block: { builtin: \"block\" },\n            this: { builtin: \"this\" },\n            now: { builtin: \"now\" }\n          };\n\n          if (\n            language !== \"Solidity\" ||\n            (scope &&\n              (scope.nodeType.startsWith(\"Yul\") ||\n                scope.nodeType === \"InlineAssembly\"))\n          ) {\n            //Solidity builtins are for Solidity only!\n            return variables;\n          }\n\n          return { ...builtins, ...variables };\n        }\n      ),\n\n      /**\n       * data.current.identifiers.definitions (namespace)\n       */\n      definitions: {\n        /**\n         * data.current.identifiers.definitions (selector)\n         * definitions for current variables, by identifier\n         */\n        _: createLeaf(\n          [\"/current/scopes/inlined\", \"../_\", \"./this\", \"/current/compiler\"],\n\n          (scopes, identifiers, thisDefinition, compiler) => {\n            debug(\"identifiers: %O\", identifiers);\n            let variables = Object.assign(\n              {},\n              ...Object.entries(identifiers).map(([identifier, variable]) => {\n                if (variable.astRef !== undefined) {\n                  let { definition } = scopes[variable.astRef];\n                  return { [identifier]: definition };\n                  //there used to be separate code for Yul variables here,\n                  //but now that's handled in definitionToType\n                } else {\n                  return {}; //skip over builtins; we'll handle those separately\n                }\n              })\n            );\n            let builtins = {\n              msg: MSG_DEFINITION,\n              tx: TX_DEFINITION,\n              block: BLOCK_DEFINITION\n            };\n            //only include this when it has a proper definition\n            if (thisDefinition) {\n              builtins.this = thisDefinition;\n            }\n            //only include now on versions prior to 0.7.0\n            if (!solidityVersionHasNoNow(compiler)) {\n              debug(\"adding now\");\n              builtins.now = NOW_DEFINITION;\n            }\n            return { ...builtins, ...variables };\n          }\n        ),\n\n        /**\n         * data.current.identifiers.definitions.this\n         *\n         * returns a spoofed definition for the this variable\n         */\n        this: createLeaf([\"/current/contract\"], contractNode =>\n          contractNode && contractNode.nodeType === \"ContractDefinition\"\n            ? spoofThisDefinition(\n                contractNode.name,\n                contractNode.id,\n                contractNode.contractKind\n              )\n            : null\n        )\n      },\n\n      /**\n       * data.current.identifiers.sections\n       * used for printing out the variables in sections\n       */\n      sections: createLeaf(\n        [\"./definitions\", \"./refs\", \"/current/scopes/inlined\"],\n        (definitions, refs, scopes) => {\n          let sections = {\n            builtin: [],\n            global: [],\n            contract: [],\n            local: []\n          };\n          if (!scopes) {\n            //if no transaction is loaded, there are no variables\n            return sections;\n          }\n          for (const [identifier, ref] of Object.entries(refs)) {\n            if (identifier in definitions) {\n              switch (ref.location) {\n                case \"special\":\n                  sections.builtin.push(identifier);\n                  break;\n                case \"stack\":\n                  sections.local.push(identifier);\n                  break;\n                case \"storage\":\n                case \"code\":\n                case \"nowhere\":\n                case \"memory\":\n                  sections.contract.push(identifier);\n                  break;\n                case \"definition\":\n                  //in this case, look up whether its scope\n                  //is a SourceUnit or a ContractDefinition\n                  const definition = definitions[identifier];\n                  const scope = scopes[definition.scope].definition;\n                  if (scope.nodeType === \"SourceUnit\") {\n                    sections.global.push(identifier);\n                  } else if (scope.nodeType === \"ContractDefinition\") {\n                    sections.contract.push(identifier);\n                  }\n                  //other cases shouldn't happen\n                  break;\n                //other cases shouldn't happen\n              }\n            }\n          }\n          return sections;\n        }\n      ),\n\n      /**\n       * data.current.identifiers.refs\n       *\n       * current variables' value refs\n       */\n      refs: createLeaf(\n        [\n          \"/proc/assignments\",\n          \"./_\",\n          \"./definitions\",\n          \"/current/scopes/inlined\",\n          \"/current/compilationId\",\n          \"/current/internalSourceFor\", //may be null\n          \"/current/functionDepth\", //for pruning things too deep on stack\n          \"/current/modifierDepth\", //when it's useful\n          \"/current/inModifier\"\n        ],\n\n        (\n          assignments,\n          identifiers,\n          definitions,\n          scopes,\n          compilationId,\n          internalFor,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        ) =>\n          Object.assign(\n            {},\n            ...Object.entries(identifiers).map(\n              ([identifier, { astRef, builtin }]) => {\n                let id;\n                debug(\"astRef: %o\", astRef);\n                debug(\"builtin: %s\", builtin);\n\n                //is this an ordinary variable or a builtin?\n                if (astRef !== undefined) {\n                  //ordinary variable case\n                  //first: is this a contract variable?\n                  id = stableKeccak256({\n                    astRef,\n                    compilationId,\n                    internalFor\n                  });\n                  //if not contract, it's local, so identify by stackframe (& etc)\n                  if (!(id in assignments)) {\n                    id = stableKeccak256({\n                      astRef,\n                      compilationId,\n                      internalFor,\n                      stackframe: currentDepth,\n                      modifierDepth: inModifier ? modifierDepth : null\n                    });\n                  }\n                  debug(\"id after local: %s\", id);\n                  //if it's not that either, but it's a constant, maybe it's a\n                  //global (if it is, whip up an assignment rather than extracting\n                  //one from assignments!)\n                  if (!(id in assignments)) {\n                    const definition = definitions[identifier];\n                    debug(\"global definition: %o\", definition);\n                    if (definition.scope !== undefined) {\n                      const scope = scopes[definition.scope].definition;\n                      if (\n                        scope.nodeType === \"SourceUnit\" &&\n                        (definition.constant === true ||\n                          definition.mutability === \"constant\")\n                      ) {\n                        return {\n                          [identifier]: {\n                            location: \"definition\",\n                            definition: definition.value\n                          }\n                        };\n                      }\n                    }\n                  }\n                } else {\n                  //it's a builtin\n                  id = stableKeccak256({\n                    builtin\n                  });\n                }\n\n                //if we still didn't find it, oh well\n                debug(\"id: %s\", id);\n\n                let { ref } = assignments[id] || {};\n                if (!ref) {\n                  return {}; //don't add anything\n                }\n                return {\n                  [identifier]: ref\n                };\n              }\n            )\n          )\n      )\n    },\n\n    /**\n     * data.current.returnStatus\n     */\n    returnStatus: createLeaf(\n      [evm.current.step.returnStatus],\n      status => (status === null ? undefined : status) //convert null to undefined to be safe\n    ),\n\n    /**\n     * data.current.returnAllocation\n     */\n    returnAllocation: createLeaf(\n      [\n        evm.current.call,\n        \"/current/context\",\n        \"/info/allocations/calldata\",\n        \"./fallbackOutputForContext\"\n      ],\n      (\n        { data: calldata },\n        { context, isConstructor, fallbackAbi },\n        { constructorAllocations, functionAllocations },\n        contractHasFallbackOutput //just using truthiness here\n      ) => {\n        if (isConstructor) {\n          //we're in a constructor call\n          let allocation = constructorAllocations[context];\n          if (!allocation) {\n            return null;\n          }\n          return allocation.output;\n        } else {\n          //usual case\n          let selector = calldata.slice(0, 2 + 4 * 2); //extract first 4 bytes of hex string\n          debug(\"selector: %s\", selector);\n          debug(\"bySelector: %o\", functionAllocations[context]);\n          let allocation = (functionAllocations[context] || {})[selector];\n          if (allocation) {\n            return allocation.output;\n          } else {\n            //we're in a fallback or receive, presumably.\n            //so is it a fallback, and does it have output?\n            if (\n              (calldata !== \"0x\" || fallbackAbi.receive === null) &&\n              fallbackAbi.fallback !== null && //this check is redundant, but let's include it\n              contractHasFallbackOutput\n            ) {\n              return Codec.AbiData.Allocate.FallbackOutputAllocation;\n            } else {\n              return null;\n            }\n          }\n        }\n      }\n    ),\n\n    /**\n     * data.current.isCall\n     */\n    isCall: createLeaf([evm.current.step.isCall], identity),\n\n    /**\n     * data.current.isCreate\n     */\n    isCreate: createLeaf([evm.current.step.isCreate], identity),\n\n    /**\n     * data.current.currentCallIsCreate\n     */\n    currentCallIsCreate: createLeaf(\n      [evm.current.call],\n      call => call.binary !== undefined\n    ),\n\n    /**\n     * data.current.callContext\n     * note that we convert to decoder context!\n     */\n    callContext: createLeaf(\n      [evm.current.step.callContext],\n      debuggerContextToDecoderContext\n    ),\n\n    /**\n     * data.current.isPop\n     */\n    isPop: createLeaf([evm.current.step.isPop], identity)\n  },\n\n  /**\n   * data.next\n   */\n  next: {\n    /**\n     * data.next.state\n     * Yes, I'm just repeating the code for data.current.state.stack here;\n     * not worth the trouble to factor out\n     */\n    state: {\n      /**\n       * data.next.state.stack\n       */\n      stack: createLeaf(\n        [evm.next.state.stack],\n\n        words => (words || []).map(word => Codec.Conversion.toBytes(word))\n      ),\n\n      /**\n       * data.next.state.returndata\n       * NOTE: this is only for use by decodeReturnValue(); this is *not*\n       * an accurate reflection of the current contents of returndata!\n       * we don't track that at the moment\n       */\n      returndata: createLeaf([evm.current.step.returnValue], data =>\n        Codec.Conversion.toBytes(data)\n      ),\n\n      /**\n       * data.next.state.calldata\n       * NOTE: this is only for use by decodeCall(); this is *not*\n       * necessarily the actual next contents of calldata!\n       */\n      calldata: createLeaf(\n        [\n          evm.current.step.isCall,\n          evm.current.step.isCreate,\n          evm.current.step.callData,\n          evm.current.step.createBinary\n        ],\n        (isCall, isCreate, data, binary) => {\n          if (!isCall && !isCreate) {\n            return null;\n          }\n          return Codec.Conversion.toBytes(isCall ? data : binary);\n        }\n      )\n    },\n\n    //HACK WARNING\n    //the following selectors depend on sourcemapping.next\n    //do not use them when the current instruction is a context change!\n\n    /**\n     * data.next.node\n     */\n    node: createLeaf([sourcemapping.next.node], identity),\n\n    /**\n     * data.next.pointer\n     */\n    pointer: createLeaf([sourcemapping.next.pointer], identity),\n\n    /**\n     * data.next.modifierInvocation\n     * Note: yes, I'm just repeating the code from data.current here but with\n     * invalid added\n     */\n    modifierInvocation: createLeaf(\n      [\"./node\", \"/current/scopes/inlined\", evm.current.step.isContextChange],\n      (node, scopes, invalid) => {\n        //don't attempt this at a context change!\n        //(also don't attempt this if we can't find the node for whatever\n        //reason)\n        if (invalid) {\n          return undefined;\n        }\n        const types = [\n          \"ModifierInvocation\",\n          \"InheritanceSpecifier\",\n          \"SourceUnit\"\n        ];\n        //again, SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes);\n      }\n    ),\n\n    /**\n     * data.next.modifierBeingInvoked\n     */\n    modifierBeingInvoked: createLeaf(\n      [\n        \"./modifierInvocation\",\n        \"/current/scopes/inlined\",\n        evm.current.step.isContextChange\n      ],\n      (invocation, scopes, invalid) => {\n        if (invalid || !invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        return modifierForInvocation(invocation, scopes);\n      }\n    )\n    //END HACK WARNING\n  },\n\n  /**\n   * data.nextUserStep\n   */\n  nextUserStep: {\n    /**\n     * data.nextUserStep.state\n     * Yes, I'm just repeating the code for data.current.state.stack here;\n     * not worth the trouble to factor out\n     * HACK: this assumes we're not about to change context! don't use this if we\n     * are!\n     */\n    state: {\n      /**\n       * data.nextUserStep.state.stack\n       */\n      stack: createLeaf(\n        [sourcemapping.current.nextUserStep],\n\n        step =>\n          ((step || {}).stack || []).map(word => Codec.Conversion.toBytes(word))\n      )\n    }\n  },\n\n  /**\n   * data.nextOfSameDepth\n   */\n  nextOfSameDepth: {\n    /**\n     * data.nextOfSameDepth.state\n     * Yes, I'm just repeating the code for data.current.state.stack here but\n     * with an extra guard... *still* not worth the trouble to factor out\n     * HOWEVER, this one also returns null if there is no nextOfSameDepth\n     */\n    state: {\n      /**\n       * data.nextOfSameDepth.state.stack\n       */\n      stack: createLeaf(\n        [trace.nextOfSameDepth],\n\n        step =>\n          step\n            ? (step.stack || []).map(word => Codec.Conversion.toBytes(word))\n            : null\n      )\n    }\n  }\n});\n\nexport default data;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:txlog:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport data from \"lib/data/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport trace from \"lib/trace/selectors\";\nimport sourcemapping from \"lib/sourcemapping/selectors\";\n\nimport * as Codec from \"@truffle/codec\";\n\nconst identity = x => x;\n\nfunction createMultistepSelectors(stepSelector) {\n  return {\n    /**\n     * .source\n     * HACK: see notes in sourcemapping selectors about cases\n     * where this won't work\n     */\n    source: createLeaf([stepSelector.source], identity),\n\n    /**\n     * .astNode\n     * HACK: see notes in sourcemapping selectors about cases\n     * where this won't work\n     */\n    astNode: createLeaf([stepSelector.node], identity),\n\n    /**\n     * .inInternalSourceOrYul\n     */\n    inInternalSourceOrYul: createLeaf(\n      [\"./source\", \"./astNode\"],\n      (source, node) =>\n        !node ||\n        source.internal ||\n        node.nodeType.startsWith(\"Yul\") ||\n        node.nodeType === \"ContractDefinition\" //HACK\n      //HACK: this last case is to handle a Solidity bug where code that\n      //should be unmapped instead gets mapped to the to the contract\n      //definition node.  I'm worried that this might screw things up for\n      //optimized code, but... we'll see?\n    )\n  };\n}\n\nlet txlog = createSelectorTree({\n  /**\n   * txlog.state\n   */\n  state: state => state.txlog,\n\n  /**\n   * txlog.proc\n   */\n  proc: {\n    /**\n     * txlog.proc.transactionLog\n     */\n    transactionLog: createLeaf(\n      [\"/state\"],\n      state => state.proc.transactionLog.byPointer\n    )\n  },\n\n  /**\n   * txlog.transaction\n   */\n  transaction: {\n    /**\n     * txlog.transaction.origin\n     */\n    origin: createLeaf([evm.transaction.globals.tx], tx => tx.origin),\n\n    /**\n     * txlog.transaction.initialCall\n     */\n    initialCall: createLeaf([\"/state\"], state => state.transaction.initialCall),\n\n    /**\n     * txlog.transaction.absorbFirstInternalCall\n     */\n    absorbFirstInternalCall: createLeaf(\n      [sourcemapping.transaction.bottomStackframeRequiresPhantomFrame],\n      identity\n    )\n  },\n\n  /**\n   * txlog.current\n   */\n  current: {\n    ...createMultistepSelectors(sourcemapping.current),\n\n    /**\n     * txlog.current.state\n     */\n    state: createLeaf([evm.current.state], identity),\n\n    /**\n     * txlog.current.pointer\n     * NOTE: transaction log pointer; NOT the AST pointer!\n     */\n    pointer: createLeaf([\"/state\"], state => state.proc.currentNodePointer),\n\n    /**\n     * txlog.current.pointerStack\n     */\n    pointerStack: createLeaf([\"/state\"], state => state.proc.pointerStack),\n\n    /**\n     * txlog.current.node\n     * NOTE: transaction log node; NOT the AST node!\n     */\n    node: createLeaf(\n      [\"./pointer\", \"/proc/transactionLog\"],\n      (pointer, log) => log[pointer]\n    ),\n\n    /**\n     * txlog.current.step\n     */\n    step: createLeaf(\n      [trace.index, trace.steps],\n      (index, steps) =>\n        steps.length === 0\n          ? -1 //special case: we use step -1 to mean before the steps start;\n          : //so if there are no steps, that's what we want to report. trace.index\n            //won't do that, though, so we special-case it in here.\n            index //normal case\n    ),\n\n    /**\n     * txlog.current.waitingForFunctionDefinition\n     * This selector indicates whether there's a call (internal or external)\n     * that is waiting to have its function definition identified when we hit\n     * a function definition node.\n     */\n    waitingForFunctionDefinition: createLeaf(\n      [\"./node\"],\n      node =>\n        (node.type === \"callinternal\" || node.type === \"callexternal\") &&\n        node.waitingForFunctionDefinition\n    ),\n\n    /**\n     * txlog.current.waitingForInternalCallToAbsorb\n     */\n    waitingForInternalCallToAbsorb: createLeaf(\n      [\"./node\"],\n      node => node.type === \"callexternal\" && node.absorbNextInternalCall\n    ),\n\n    /**\n     * txlog.current.nextActionPointer\n     * the pointer where a new action will be added\n     */\n    nextActionPointer: createLeaf(\n      [\"./pointer\", \"./node\"],\n      (pointer, node) => `${pointer}/actions/${node.actions.length}`\n    ),\n\n    /**\n     * txlog.current.internalReturnPointer\n     * the pointer where we'll end up after an internal return\n     * (if we're on an internal call, it returns; if we're not,\n     * we stay put and just absorb the info)\n     */\n    internalReturnPointer: createLeaf(\n      [\"./pointer\", \"./node\"],\n      (pointer, node) =>\n        node.type === \"callinternal\"\n          ? pointer.replace(/\\/actions\\/\\d+$/, \"\")\n          : pointer\n    ),\n\n    /**\n     * txlog.current.externalReturnPointer\n     * the pointer where we'll end up after an external return\n     * (take the top stack entry, then go up one more)\n     * (there should always be something on the stack when this\n     * selector is used)\n     */\n    externalReturnPointer: createLeaf([\"./pointerStack\"], stack =>\n      stack[stack.length - 1].replace(/\\/actions\\/\\d+$/, \"\")\n    ),\n\n    /**\n     * txlog.current.context\n     * Note we use data context, not evm context\n     * (i.e. decoder context, not debugger context)\n     */\n    context: createLeaf([data.current.context], identity),\n\n    /**\n     * txlog.current.call\n     */\n    call: createLeaf([evm.current.call], identity),\n\n    /**\n     * txlog.current.contract\n     */\n    contract: createLeaf([data.current.contract], identity),\n\n    /**\n     * txlog.current.isSourceRangeFinal\n     */\n    isSourceRangeFinal: createLeaf(\n      [sourcemapping.current.isSourceRangeFinal],\n      identity\n    ),\n\n    /**\n     * txlog.current.onFunctionDefinition\n     */\n    onFunctionDefinition: createLeaf(\n      [\n        \"./astNode\",\n        \"./isSourceRangeFinal\",\n        \"/next/inInternalSourceOrYul\",\n        trace.stepsRemaining\n      ],\n      (node, ready, isNextInternal, stepsRemaining) =>\n        (ready || stepsRemaining <= 2) && //HACK: see below\n        node &&\n        node.nodeType === \"FunctionDefinition\" &&\n        !isNextInternal //need to make sure we're not just jumping to a generated source or unmapped code\n      //hack above: the last step doesn't get processed, so...\n    ),\n\n    /**\n     * txlog.current.currentFunctionIsAsExpected\n     *\n     * Does the function we're currently in according to the AST,\n     * match the function we're currently in according to the txlog?\n     * (if we're in a modifier we'll ignore this check)\n     */\n    currentFunctionIsAsExpected: createLeaf(\n      [\"./node\", data.current.function, data.current.contract],\n      (txlogNode, currentFunction, contractNode) =>\n        currentFunction &&\n        (currentFunction.nodeType === \"ContractDefinition\" ||\n          currentFunction.nodeType === \"ModifierDefinition\" ||\n          (currentFunction.nodeType === \"FunctionDefinition\" &&\n            currentFunction.name === txlogNode.functionName &&\n            (txlogNode.kind === \"callexternal\" ||\n              (contractNode && contractNode.name === txlogNode.contractName))))\n    ),\n\n    /**\n     * txlog.current.compilationId\n     */\n    compilationId: createLeaf([data.current.compilationId], identity),\n\n    /**\n     * txlog.current.isJump\n     */\n    isJump: createLeaf([evm.current.step.isJump], identity),\n\n    /**\n     * txlog.current.jumpDirection\n     */\n    jumpDirection: createLeaf([sourcemapping.current.jumpDirection], identity),\n\n    /**\n     * txlog.current.isLog\n     */\n    isLog: createLeaf([evm.current.step.isLog], identity),\n\n    /**\n     * txlog.current.isStore\n     */\n    isStore: createLeaf([evm.current.step.isStore], identity),\n\n    /**\n     * txlog.current.rawStorageSlot\n     * note we prepend 0x\n     */\n    rawStorageSlot: createLeaf(\n      [evm.current.step.isStore, evm.current.step.storageAffected],\n      (isStore, slot) => (isStore ? \"0x\" + slot : null)\n    ),\n\n    /**\n     * txlog.current.rawStorageValue\n     * note we prepend 0x\n     */\n    rawStorageValue: createLeaf([evm.current.step.valueStored], value =>\n      value !== null ? \"0x\" + value : null\n    ),\n\n    /**\n     * txlog.current.rawEventInfo\n     */\n    rawEventInfo: {\n      /**\n       * txlog.current.rawEventInfo.topics\n       */\n      topics: createLeaf([evm.current.step.logTopics], identity),\n\n      /**\n       * txlog.current.rawEventInfo.data\n       */\n      data: createLeaf([evm.current.step.logData], identity)\n    },\n\n    /**\n     * txlog.current.isCall\n     */\n    isCall: createLeaf([evm.current.step.isCall], identity),\n\n    /**\n     * txlog.current.isDelegateCallBroad\n     */\n    isDelegateCallBroad: createLeaf(\n      [evm.current.step.isDelegateCallBroad],\n      identity\n    ),\n\n    /**\n     * txlog.current.isCreate\n     */\n    isCreate: createLeaf([evm.current.step.isCreate], identity),\n\n    /**\n     * txlog.current.isInstantCallOrCreate\n     */\n    isInstantCallOrCreate: createLeaf(\n      [evm.current.step.isInstantCallOrCreate],\n      identity\n    ),\n\n    /**\n     * txlog.current.isHalting\n     */\n    isHalting: createLeaf([evm.current.step.isHalting], identity),\n\n    /**\n     * txlog.current.returnStatus\n     */\n    returnStatus: createLeaf([evm.current.step.returnStatus], identity),\n\n    /**\n     * txlog.current.callValue\n     */\n    callValue: createLeaf([evm.current.step.callValue], identity),\n\n    /**\n     * txlog.current.callAddress\n     */\n    callAddress: createLeaf([evm.current.step.callAddress], identity),\n\n    /**\n     * txlog.current.callContext\n     * note we make sure to use data, not evm, context!\n     * (i.e. decoder context, not debugger context)\n     */\n    callContext: createLeaf([data.current.callContext], identity),\n\n    /**\n     * txlog.current.absorbNextInternalCall\n     */\n    absorbNextInternalCall: createLeaf(\n      [sourcemapping.current.callRequiresPhantomFrame],\n      identity\n    ),\n\n    /**\n     * txlog.current.callData\n     */\n    callData: createLeaf([evm.current.step.callData], identity),\n\n    /**\n     * txlog.current.createBinary\n     */\n    createBinary: createLeaf([evm.current.step.createBinary], identity),\n\n    /**\n     * txlog.current.createValue\n     */\n    createValue: createLeaf([evm.current.step.createValue], identity),\n\n    /**\n     * txlog.current.createdAddress\n     */\n    createdAddress: createLeaf([evm.current.step.createdAddress], identity),\n\n    /**\n     * txlog.current.salt\n     */\n    salt: createLeaf([evm.current.step.salt], identity),\n\n    /**\n     * txlog.current.isSelfDestruct\n     */\n    isSelfDestruct: createLeaf([evm.current.step.isSelfDestruct], identity),\n\n    /**\n     * txlog.current.beneficiary\n     */\n    beneficiary: createLeaf([evm.current.step.beneficiary], identity),\n\n    /**\n     * txlog.current.returnData\n     */\n    returnData: createLeaf([evm.current.step.returnValue], identity),\n\n    /**\n     * txlog.current.inputParameterAllocations\n     */\n    inputParameterAllocations: createLeaf(\n      [\"./astNode\", \"./state\"],\n      (functionDefinition, { stack }) => {\n        if (\n          !functionDefinition ||\n          functionDefinition.nodeType !== \"FunctionDefinition\"\n        ) {\n          return null;\n        }\n        return locateParameters(\n          functionDefinition.parameters.parameters,\n          stack.length - 1\n        );\n      }\n    ),\n\n    /**\n     * txlog.current.outputParameterAllocations\n     */\n    outputParameterAllocations: createLeaf(\n      [\"./astNode\", \"./state\"],\n      (functionDefinition, { stack }) => {\n        if (\n          !functionDefinition ||\n          functionDefinition.nodeType !== \"FunctionDefinition\"\n        ) {\n          return null;\n        }\n        //when this selector is invoked, we're on the jump out step, so the\n        //top element of the stack is the return address; we need to skip past that\n        return locateParameters(\n          functionDefinition.returnParameters.parameters,\n          stack.length - 2\n        );\n      }\n    )\n  },\n\n  /**\n   * txlog.next\n   */\n  next: {\n    ...createMultistepSelectors(sourcemapping.next)\n  },\n\n  /**\n   * txlog.views\n   */\n  views: {\n    /**\n     * txlog.views.transactionLog\n     * contains the actual transformed transaction log ready for use!\n     */\n    transactionLog: createLeaf([\"/proc/transactionLog\"], log => {\n      const tie = node =>\n        node.actions\n          ? {\n              ...node,\n              actions: node.actions.map(pointer => tie(log[pointer]))\n            }\n          : node;\n      return tie(log[\"\"]); //\"\" is always the root node\n    }),\n\n    /**\n     * txlog.views.flattedEvents\n     */\n    flattedEvents: createLeaf([\"./transactionLog\"], log => {\n      const returnStatus = node => {\n        switch (node.returnKind) {\n          case \"revert\":\n            return false;\n          case \"unwind\":\n            //note: if the returnKind is \"unwind\", the last action *must*\n            //be a callinternal!  if not, something has gone very wrong.\n            const lastCall = node.actions[node.actions.length - 1];\n            return returnStatus(lastCall);\n          default:\n            return true;\n        }\n      };\n      const getFlattedEvents = (node, address, codeAddress, status) => {\n        switch (node.type) {\n          case \"transaction\":\n            return node.actions.flatMap(subNode =>\n              getFlattedEvents(subNode, node.origin, node.origin, status)\n            );\n          case \"callexternal\":\n            const subNodeStatus = returnStatus(node);\n            return node.actions.flatMap(subNode =>\n              getFlattedEvents(\n                subNode,\n                node.isDelegate ? address : node.address,\n                node.address,\n                status && subNodeStatus\n              )\n            );\n          case \"callinternal\":\n            return node.actions.flatMap(subNode =>\n              getFlattedEvents(subNode, address, codeAddress, status)\n            );\n          case \"event\":\n            return [\n              {\n                decoding: node.decoding,\n                raw: node.raw,\n                step: node.step,\n                address,\n                codeAddress,\n                status\n              }\n            ];\n          default:\n            return [];\n        }\n      };\n      return getFlattedEvents(log, null, null, true);\n    })\n  }\n});\n\nfunction locateParameters(parameters, top) {\n  const reverseParameters = parameters.slice().reverse();\n  //note we clone before reversing because reverse() is in place\n\n  let results = [];\n  let currentPosition = top;\n  for (let parameter of reverseParameters) {\n    const words = Codec.Ast.Utils.stackSize(parameter);\n    const pointer = {\n      location: \"stack\",\n      from: currentPosition - words + 1,\n      to: currentPosition\n    };\n\n    results.unshift({\n      name: parameter.name ? parameter.name : undefined, //replace \"\" with undefined\n      definition: parameter,\n      pointer\n    });\n    currentPosition -= words;\n  }\n  return results;\n}\n\nexport default txlog;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport evm from \"lib/evm/selectors\";\nimport trace from \"lib/trace/selectors\";\nimport sourcemapping from \"lib/sourcemapping/selectors\";\n\nconst session = createSelectorTree({\n  /**\n   * session.state\n   */\n  state: state => state.session,\n\n  /**\n   * session.info\n   */\n  info: {\n    /**\n     * session.info.affectedInstances\n     * NOTE: this really belongs in session.transaction,\n     * but that would be a breaking change\n     */\n    affectedInstances: createLeaf(\n      [\n        evm.transaction.affectedInstances,\n        evm.info.contexts,\n        sourcemapping.info.sources\n      ],\n\n      (instances, contexts, sources) =>\n        Object.assign(\n          {},\n          ...Object.entries(instances).map(\n            ([\n              address,\n              {\n                context: contextId,\n                binary,\n                creationBinary,\n                creationContext: creationContextId\n              }\n            ]) => {\n              debug(\"instances %O\", instances);\n              debug(\"contexts %O\", contexts);\n              let context = contexts[contextId];\n              if (!context) {\n                return { [address]: { binary } };\n              }\n              let { contractName, compilationId, primarySource } = context;\n\n              debug(\"primarySource: %o\", primarySource);\n              debug(\"compilationId: %s\", compilationId);\n              debug(\"sources: %o\", sources);\n\n              let source =\n                primarySource !== undefined // note this is an index, not an ID\n                  ? sources.byCompilationId[compilationId].byIndex[\n                      primarySource\n                    ]\n                  : undefined;\n\n              let constructorArgs;\n              if (creationBinary !== undefined) {\n                let creationContext = contexts[creationContextId];\n                if (creationContext) {\n                  //slice off the bytecode part of the constructor to leave the arguments\n                  constructorArgs = creationBinary.slice(\n                    creationContext.binary.length\n                  );\n                }\n              }\n\n              return {\n                [address]: {\n                  contractName,\n                  source,\n                  binary,\n                  constructorArgs //will be defined only if created by this tx\n                }\n              };\n            }\n          )\n        )\n    )\n  },\n\n  /**\n   * session.transaction (namespace)\n   */\n  transaction: {\n    /**\n     * session.transaction (selector)\n     * contains the web3 transaction object\n     */\n    _: createLeaf([\"/state\"], state => state.transaction),\n\n    /**\n     * session.transaction.receipt\n     * contains the web3 receipt object\n     */\n    receipt: createLeaf([\"/state\"], state => state.receipt),\n\n    /**\n     * session.transaction.block\n     * contains the web3 block object\n     */\n    block: createLeaf([\"/state\"], state => state.block)\n  },\n\n  /**\n   * session.status (namespace)\n   */\n  status: {\n    /**\n     * session.status.readyOrError\n     */\n    readyOrError: createLeaf([\"/state\"], state => state.ready),\n\n    /**\n     * session.status.ready\n     */\n    ready: createLeaf(\n      [\"./readyOrError\", \"./isError\"],\n      (readyOrError, error) => readyOrError && !error\n    ),\n\n    /**\n     * session.status.waiting\n     */\n    waiting: createLeaf([\"/state\"], state => !state.ready),\n\n    /**\n     * session.status.error\n     */\n    error: createLeaf([\"/state\"], state => state.lastLoadingError),\n\n    /**\n     * session.status.isError\n     */\n    isError: createLeaf([\"./error\"], error => error !== null),\n\n    /**\n     * session.status.success\n     */\n    success: createLeaf([\"./error\"], error => error === null),\n\n    /**\n     * session.status.errored\n     */\n    errored: createLeaf(\n      [\"./readyOrError\", \"./isError\"],\n      (readyOrError, error) => readyOrError && error\n    ),\n\n    /**\n     * session.status.loaded\n     */\n    loaded: createLeaf([trace.loaded], loaded => loaded),\n\n    /**\n     * session.status.lightMode\n     */\n    lightMode: createLeaf([\"/state\"], state => state.lightMode)\n  }\n});\n\nexport default session;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"redux-saga/effects\");","export const SAVE_STEPS = \"TRACE_SAVE_STEPS\";\nexport function saveSteps(steps) {\n  return {\n    type: SAVE_STEPS,\n    steps\n  };\n}\n\nexport const TICK = \"TRACE_TICK\";\nexport function tick() {\n  return { type: TICK };\n}\n\nexport const TOCK = \"TRACE_TOCK\";\nexport function tock() {\n  return { type: TOCK };\n}\n\nexport const ADVANCE = \"TRACE_ADVANCE\";\nexport function advance() {\n  return { type: ADVANCE };\n}\n\nexport const END_OF_TRACE = \"TRACE_EOT\";\nexport function endTrace() {\n  return { type: END_OF_TRACE };\n}\n\nexport const RESET = \"TRACE_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const UNLOAD_TRANSACTION = \"TRACE_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return { type: UNLOAD_TRANSACTION };\n}\n\nexport const SET_SUBMODULE_COUNT = \"TRACE_SET_SUBMODULE_COUNT\";\nexport function setSubmoduleCount(count) {\n  return { type: SET_SUBMODULE_COUNT, count };\n}\n","export const SCOPE = \"DATA_SCOPE\";\nexport function scope(id, pointer, parentId, sourceIndex, sourceId) {\n  return {\n    type: SCOPE,\n    id,\n    pointer,\n    parentId,\n    sourceIndex,\n    sourceId\n  };\n}\n\nexport const DECLARE = \"DATA_DECLARE_VARIABLE\";\nexport function declare(name, astRef, scopeAstRef, sourceId) {\n  return {\n    type: DECLARE,\n    name,\n    astRef,\n    scopeAstRef,\n    sourceId\n  };\n}\n\nexport const ASSIGN = \"DATA_ASSIGN\";\nexport function assign(assignments) {\n  return {\n    type: ASSIGN,\n    assignments\n  };\n}\n\nexport const MAP_PATH_AND_ASSIGN = \"DATA_MAP_PATH_AND_ASSIGN\";\nexport function mapPathAndAssign(\n  address,\n  slot,\n  assignments,\n  typeIdentifier,\n  parentType\n) {\n  return {\n    type: MAP_PATH_AND_ASSIGN,\n    address,\n    slot,\n    assignments,\n    typeIdentifier,\n    parentType\n  };\n}\n\nexport const RESET = \"DATA_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const DEFINE_TYPE = \"DATA_DEFINE_TYPE\";\nexport function defineType(node, sourceId) {\n  return {\n    type: DEFINE_TYPE,\n    node,\n    sourceId\n  };\n}\n\nexport const DEFINE_TAGGED_OUTPUT = \"DATA_DEFINE_TAGGED_OUTPUT\";\nexport function defineTaggedOutput(node, sourceId) {\n  return {\n    type: DEFINE_TAGGED_OUTPUT,\n    node,\n    sourceId\n  };\n}\n\nexport const ADD_CONTRACTS = \"DATA_ADD_CONTRACTS\";\nexport function addContracts(contracts) {\n  return {\n    type: ADD_CONTRACTS,\n    contracts\n  };\n}\n\nexport const ALLOCATE = \"DATA_ALLOCATE\";\nexport function allocate(\n  storage,\n  memory,\n  abi,\n  calldata,\n  returndata,\n  event,\n  state\n) {\n  return {\n    type: ALLOCATE,\n    storage,\n    memory,\n    abi,\n    calldata,\n    returndata,\n    event,\n    state\n  };\n}\n","export const ADD_CONTEXT = \"EVM_ADD_CONTEXT\";\nexport function addContext(context) {\n  return {\n    ...context,\n    type: ADD_CONTEXT\n  };\n}\n\nexport const ADD_INSTANCE = \"EVM_ADD_INSTANCE\";\nexport function addInstance(address, context, binary) {\n  return {\n    type: ADD_INSTANCE,\n    address,\n    context,\n    binary\n  };\n}\n\nexport const ADD_AFFECTED_INSTANCE = \"EVM_ADD_AFFECTED_INSTANCE\";\nexport function addAffectedInstance(\n  address,\n  context,\n  binary,\n  creationBinary,\n  creationContext\n) {\n  return {\n    type: ADD_AFFECTED_INSTANCE,\n    address,\n    context,\n    binary,\n    creationBinary, //may be undefined\n    creationContext\n  };\n}\n\nexport const REFRESH_INSTANCE = \"EVM_REFRESH_INSTANCE\";\nexport function refreshInstances(address, context) {\n  return {\n    type: REFRESH_INSTANCE,\n    address,\n    context\n  };\n}\n\nexport const SAVE_GLOBALS = \"EVM_SAVE_GLOBALS\";\nexport function saveGlobals(origin, gasprice, block) {\n  return {\n    type: SAVE_GLOBALS,\n    origin,\n    gasprice,\n    block\n  };\n}\n\nexport const SAVE_TX_IDENTIFICATION = \"EVM_SAVE_TX_IDENTIFICATION\";\nexport function saveTxIdentification(blockHash, txIndex) {\n  return {\n    type: SAVE_TX_IDENTIFICATION,\n    blockHash,\n    txIndex\n  };\n}\n\nexport const SAVE_STATUS = \"EVM_SAVE_STATUS\";\nexport function saveStatus(status) {\n  return {\n    type: SAVE_STATUS,\n    status\n  };\n}\n\nexport const CALL = \"EVM_CALL\";\nexport function call(address, data, storageAddress, sender, value) {\n  return {\n    type: CALL,\n    address,\n    data,\n    storageAddress,\n    sender,\n    value\n  };\n}\n\nexport const CREATE = \"EVM_CREATE\";\nexport function create(binary, storageAddress, sender, value) {\n  return {\n    type: CREATE,\n    binary,\n    storageAddress,\n    sender,\n    value\n  };\n}\n\nexport const RETURN_CALL = \"EVM_RETURN_CALL\";\nexport function returnCall() {\n  return {\n    type: RETURN_CALL\n  };\n}\n\nexport const RETURN_CREATE = \"EVM_RETURN_CREATE\";\nexport function returnCreate(address, code, context) {\n  return {\n    type: RETURN_CREATE,\n    address,\n    code,\n    context\n  };\n}\n\nexport const FAIL = \"EVM_FAIL\";\nexport function fail() {\n  return {\n    type: FAIL\n  };\n}\n\nexport const STORE = \"EVM_STORE\";\nexport function store(address, slot, value) {\n  return {\n    type: STORE,\n    address,\n    slot,\n    value\n  };\n}\n\nexport const LOAD = \"EVM_LOAD\";\nexport function load(address, slot, value) {\n  return {\n    type: LOAD,\n    address,\n    slot,\n    value\n  };\n}\n\nexport const RESET = \"EVM_RESET\";\nexport function reset(storageAddress) {\n  return {\n    type: RESET,\n    storageAddress\n  };\n}\n\nexport const UNLOAD_TRANSACTION = \"EVM_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n\nexport const SET_STORAGE_LOOKUP = \"EVM_SET_STORAGE_LOOKUP\";\nexport function setStorageLookup(status) {\n  return {\n    type: SET_STORAGE_LOOKUP,\n    status\n  };\n}\n\nexport const SET_STORAGE_LOOKUP_SUPPORT = \"EVM_SET_STORAGE_LOOKUP_SUPPORT\";\nexport function setStorageLookupSupport(status) {\n  return {\n    type: SET_STORAGE_LOOKUP_SUPPORT,\n    status\n  };\n}\n","export const INIT_WEB3 = \"INIT_WEB3\";\nexport function init(provider) {\n  return {\n    type: INIT_WEB3,\n    provider\n  };\n}\n\nexport const INSPECT = \"INSPECT_TRANSACTION\";\nexport function inspect(txHash) {\n  return {\n    type: INSPECT,\n    txHash\n  };\n}\n\nexport const FETCH_BINARY = \"FETCH_BINARY\";\nexport function fetchBinary(address, block) {\n  return {\n    type: FETCH_BINARY,\n    address,\n    block //optional\n  };\n}\n\nexport const FETCH_STORAGE = \"FETCH_STORAGE\";\nexport function fetchStorage(address, slot, blockHash, txIndex) {\n  return {\n    type: FETCH_STORAGE,\n    address,\n    slot,\n    blockHash,\n    txIndex\n  };\n}\n\nexport const RECEIVE_BINARY = \"RECEIVE_BINARY\";\nexport function receiveBinary(address, binary) {\n  return {\n    type: RECEIVE_BINARY,\n    address,\n    binary\n  };\n}\n\nexport const RECEIVE_STORAGE = \"RECEIVE_STORAGE\";\nexport function receiveStorage(address, slot, word) {\n  return {\n    type: RECEIVE_STORAGE,\n    address,\n    slot,\n    word\n  };\n}\n\nexport const RECEIVE_STORAGE_FAIL = \"RECEIVE_STORAGE_FAIL\";\nexport function receiveStorageFail(error) {\n  return {\n    type: RECEIVE_STORAGE_FAIL,\n    error\n  };\n}\n\nexport const RECEIVE_TRACE = \"RECEIVE_TRACE\";\nexport function receiveTrace(trace) {\n  return {\n    type: RECEIVE_TRACE,\n    trace\n  };\n}\n\nexport const RECEIVE_CALL = \"RECEIVE_CALL\";\nexport function receiveCall({\n  address,\n  binary,\n  data,\n  storageAddress,\n  status,\n  sender,\n  value,\n  gasprice,\n  block,\n  blockHash,\n  txIndex\n}) {\n  return {\n    type: RECEIVE_CALL,\n    address,\n    binary,\n    data,\n    storageAddress,\n    status, //only used for creation calls at present!\n    sender,\n    value,\n    gasprice,\n    block,\n    blockHash,\n    txIndex\n  };\n}\n\nexport const ERROR_WEB3 = \"ERROR_WEB3\";\nexport function error(error) {\n  return {\n    type: ERROR_WEB3,\n    error\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"web3\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:web3:adapter\");\n\nimport Web3 from \"web3\";\nimport * as Codec from \"@truffle/codec\";\nimport { promisify } from \"util\";\n\nexport default class Web3Adapter {\n  constructor(provider) {\n    this.web3 = new Web3(provider);\n  }\n\n  async getTrace(txHash) {\n    const provider = this.web3.currentProvider;\n    //send *only* uses callbacks, so we use promsifiy to make things more readable\n    //we also use bind here to prevent a problem that sometimes occurs where\n    //provider.send ends up unable to call its own methods because `this` gets\n    //set incorrectly\n    const result = await promisify(provider.send.bind(provider))({\n      jsonrpc: \"2.0\",\n      method: \"debug_traceTransaction\",\n      id: Date.now(),\n      params: [\n        txHash,\n        {\n          enableMemory: true, //recent geth versions require this option\n          disableStorage: true //we no longer use storage\n        }\n      ]\n    });\n    if (!result.result) {\n      //we assume if there's no result then there is an error.\n      //note: some nodes may return an error even if there is a\n      //usable result, so we don't assume that the presence of\n      //an error means we should throw an error, but rather check\n      //for the absence of a result.\n      throw new Error(result.error.message);\n    } else {\n      return result.result.structLogs;\n    }\n  }\n\n  async getTransaction(txHash) {\n    return await this.web3.eth.getTransaction(txHash);\n  }\n\n  async getReceipt(txHash) {\n    return await this.web3.eth.getTransactionReceipt(txHash);\n  }\n\n  async getBlock(blockNumberOrHash) {\n    return await this.web3.eth.getBlock(blockNumberOrHash);\n  }\n\n  async getChainId() {\n    return await this.web3.eth.getChainId();\n  }\n\n  async getExistingStorage(address, slot, blockHash, txIndex) {\n    debug(\"slot: %O\", slot);\n    const provider = this.web3.currentProvider;\n    const hashedSlot = Web3.utils.soliditySha3({\n      type: \"bytes\",\n      value: slot\n    });\n    //note: see comment in getTrace for why we do this thing with bind\n    const result = await promisify(provider.send.bind(provider))({\n      jsonrpc: \"2.0\",\n      method: \"debug_storageRangeAt\",\n      id: Date.now(),\n      params: [\n        blockHash,\n        txIndex,\n        address,\n        hashedSlot,\n        1 //we only want the one slot\n      ]\n    });\n    //again, see above for an explanation of the logic here\n    if (result.result) {\n      const storage = result.result.storage;\n      debug(\"hashedSlot: %O\", hashedSlot);\n      debug(\"storage: %O\", storage);\n      debug(\"found? %O\", hashedSlot in storage);\n      if (hashedSlot in storage) {\n        return storage[hashedSlot].value;\n      } else {\n        const zeroWord = \"0x\" + \"00\".repeat(Codec.Evm.Utils.WORD_SIZE);\n        return zeroWord;\n      }\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n\n  /**\n   * getDeployedCode - get the deployed code for an address from the client\n   * NOTE: the block argument is optional\n   * @param  {String} address\n   * @return {String}         deployedBinary\n   */\n  async getDeployedCode(address, block) {\n    debug(\"getting deployed code for %s\", address);\n    let code = await this.web3.eth.getCode(address, block);\n    return code === \"0x0\" ? \"0x\" : code;\n  }\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:web3:sagas\");\n\nimport {\n  all,\n  takeEvery,\n  apply,\n  fork,\n  join,\n  take,\n  put,\n  race,\n  call\n} from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport * as session from \"lib/session/actions\";\n\nimport BN from \"bn.js\";\nimport Web3 from \"web3\"; //just for utils!\nimport * as Codec from \"@truffle/codec\";\n\nimport Web3Adapter from \"../adapter\";\n\n//the following two functions are for Besu compatibility\nfunction padStackAndMemory(steps) {\n  return steps.map(step => ({\n    ...step,\n    stack: step.stack.map(padHexString),\n    memory: step.memory.map(padHexString)\n  }));\n}\n\n//turns Besu-style (begins with 0x, may be shorter than 64 hexdigits)\n//to Geth/Ganache-style (no 0x, always 64 hexdigits)\n//(I say 64 hexdigits rather than 32 bytes because Besu-style will use\n//non-whole numbers of bytes!)\nfunction padHexString(hexString) {\n  return hexString.startsWith(\"0x\") //Besu-style or Geth/Ganache-style?\n    ? hexString.slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"0\") //convert Besu to Geth/Ganache\n    : hexString; //leave Geth/Ganache style alone\n}\n\nfunction* fetchTransactionInfo(adapter, { txHash }) {\n  debug(\"inspecting transaction\");\n  var trace;\n  try {\n    trace = yield apply(adapter, adapter.getTrace, [txHash]);\n  } catch (e) {\n    debug(\"putting error\");\n    yield put(actions.error(e));\n    return;\n  }\n\n  debug(\"got trace\");\n  trace = padStackAndMemory(trace); //for Besu compatibility\n  yield put(actions.receiveTrace(trace));\n\n  const tx = yield apply(adapter, adapter.getTransaction, [txHash]);\n  debug(\"tx %O\", tx);\n  const receipt = yield apply(adapter, adapter.getReceipt, [txHash]);\n  debug(\"receipt %O\", receipt);\n  const block = yield apply(adapter, adapter.getBlock, [tx.blockNumber]);\n  debug(\"block %O\", block);\n  const chainId = yield apply(adapter, adapter.getChainId);\n\n  yield put(session.saveTransaction(tx));\n  yield put(session.saveReceipt(receipt));\n  yield put(session.saveBlock(block));\n\n  //Solidity's block.difficulty uses the opcode 0x44.\n  //This will return the difficulty (pre-merge) or the mixHash (post-merge).\n  //So if the mixHash is present and nonzero, we use that.  Otherwise, we use\n  //the difficulty.\n  let difficultyOrMixHash;\n  const mixHash = block.prevRandao || block.mixHash;\n  //mixHash is given in hex, so we have to slice off the 0x;\n  //BN doesn't accept 0n\n  const numericMixHash = new BN(mixHash.slice(2), 16);\n  if (numericMixHash.isZero()) {\n    difficultyOrMixHash = new BN(block.difficulty);\n  } else {\n    difficultyOrMixHash = numericMixHash;\n  }\n\n  //these ones get grouped together for convenience\n  const solidityBlock = {\n    coinbase: block.miner,\n    difficulty: difficultyOrMixHash,\n    gaslimit: new BN(block.gasLimit),\n    number: new BN(block.number),\n    timestamp: new BN(block.timestamp),\n    chainid: new BN(chainId), //key is lowercase because that's what Solidity does\n    basefee: new BN(parseInt(block.baseFeePerGas)) //will be 0 if pre-London [new BN(NaN) yields 0]\n    //note we need parseInt on basefee because some web3 versions return it as a hex string,\n    //and BN doesn't allow for hex strings as input\n  };\n\n  if (tx.to != null) {\n    yield put(\n      actions.receiveCall({\n        address: tx.to,\n        data: tx.input,\n        storageAddress: tx.to,\n        status: receipt.status,\n        sender: tx.from,\n        value: new BN(tx.value),\n        gasprice: new BN(tx.gasPrice),\n        block: solidityBlock,\n        blockHash: block.hash,\n        txIndex: tx.transactionIndex\n      })\n    );\n  } else {\n    const storageAddress = Web3.utils.isAddress(receipt.contractAddress)\n      ? receipt.contractAddress\n      : Codec.Evm.Utils.ZERO_ADDRESS;\n    yield put(\n      actions.receiveCall({\n        binary: tx.input,\n        storageAddress,\n        status: receipt.status,\n        sender: tx.from,\n        value: new BN(tx.value),\n        gasprice: new BN(tx.gasPrice),\n        block: solidityBlock,\n        blockHash: block.hash,\n        txIndex: tx.transactionIndex\n      })\n    );\n  }\n}\n\nexport function* inspectTransaction(txHash) {\n  yield put(actions.inspect(txHash));\n\n  let action = yield take([actions.RECEIVE_TRACE, actions.ERROR_WEB3]);\n  debug(\"action %o\", action);\n\n  var trace;\n  if (action.type == actions.RECEIVE_TRACE) {\n    trace = action.trace;\n    debug(\"received trace\");\n  } else {\n    return { error: action.error };\n  }\n\n  let {\n    address,\n    binary,\n    data,\n    storageAddress,\n    status,\n    sender,\n    value,\n    gasprice,\n    block,\n    blockHash,\n    txIndex\n  } = yield take(actions.RECEIVE_CALL);\n  debug(\"received call\");\n\n  return {\n    trace,\n    address,\n    binary,\n    data,\n    storageAddress,\n    status,\n    sender,\n    value,\n    gasprice,\n    block,\n    blockHash,\n    txIndex\n  };\n}\n\n//NOTE: the block argument is optional\nexport function* obtainBinaries(addresses, block) {\n  let tasks = yield all(addresses.map(address => fork(receiveBinary, address)));\n\n  debug(\"requesting binaries\");\n  yield all(addresses.map(address => put(actions.fetchBinary(address, block))));\n\n  let binaries = [];\n  binaries = yield join(tasks);\n\n  debug(\"binaries %o\", binaries);\n\n  return binaries;\n}\n\nfunction* fetchBinary(adapter, { address, block }) {\n  debug(\"fetching binary for %s\", address);\n  let binary = yield apply(adapter, adapter.getDeployedCode, [address, block]);\n\n  debug(\"received binary for %s\", address);\n  yield put(actions.receiveBinary(address, binary));\n}\n\nfunction* receiveBinary(address) {\n  let { binary } = yield take(\n    action => action.type == actions.RECEIVE_BINARY && action.address == address\n  );\n  debug(\"got binary for %s\", address);\n\n  return binary;\n}\n\nexport function* obtainStorage(address, slot, blockHash, txIndex) {\n  debug(\"forking\");\n  const task = yield fork(function* () {\n    return yield race({\n      success: call(receiveStorage, address, slot),\n      failure: call(receiveStorageErrorHandler)\n    });\n  });\n  yield put(actions.fetchStorage(address, slot, blockHash, txIndex));\n  debug(\"joining\");\n  const result = yield join(task);\n  debug(\"result: %O\", result);\n  if (result.failure) {\n    throw result.failure;\n  } else {\n    return result.success;\n  }\n}\n\nfunction* fetchStorage(adapter, { address, slot, blockHash, txIndex }) {\n  const slotAsHex = Codec.Conversion.toHexString(\n    slot,\n    Codec.Evm.Utils.WORD_SIZE\n  );\n  try {\n    const word = yield apply(adapter, adapter.getExistingStorage, [\n      address,\n      slotAsHex,\n      blockHash,\n      txIndex\n    ]);\n    yield put(actions.receiveStorage(address, slot, word));\n  } catch (error) {\n    yield put(actions.receiveStorageFail(error));\n  }\n}\n\nfunction* receiveStorage(address, slot) {\n  const { word } = yield take(\n    action =>\n      action.type == actions.RECEIVE_STORAGE &&\n      action.address == address &&\n      action.slot.eq(slot) //remember, these are BNs\n  );\n  return word;\n}\n\nfunction* receiveStorageErrorHandler() {\n  const { error } = yield take(actions.RECEIVE_STORAGE_FAIL);\n  return error; //because this is forked, we need to return\n  //rather than throw to prevent redux-saga from giving up\n}\n\nexport function* init(provider) {\n  yield put(actions.init(provider));\n}\n\nexport function* saga() {\n  // wait for web3 init signal\n  let { provider } = yield take(actions.INIT_WEB3);\n  let adapter = new Web3Adapter(provider);\n\n  yield takeEvery(actions.INSPECT, fetchTransactionInfo, adapter);\n  yield takeEvery(actions.FETCH_BINARY, fetchBinary, adapter);\n  yield takeEvery(actions.FETCH_STORAGE, fetchStorage, adapter);\n}\n\nexport default prefixName(\"web3\", saga);\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:trace:sagas\");\n\nimport { take, put, select } from \"redux-saga/effects\";\nimport {\n  isCallMnemonic,\n  isCreateMnemonic,\n  isSelfDestructMnemonic\n} from \"lib/helpers\";\n\nimport * as Codec from \"@truffle/codec\";\n\nimport * as actions from \"../actions\";\n\nimport trace from \"../selectors\";\n\nexport function* setSubmoduleCount(count) {\n  yield put(actions.setSubmoduleCount(count));\n}\n\nexport function* addSubmoduleToCount(increment = 1) {\n  let count = yield select(trace.application.submoduleCount);\n  yield put(actions.setSubmoduleCount(count + increment));\n}\n\nexport function* advance() {\n  let remaining = yield select(trace.stepsRemaining);\n  debug(\"remaining: %o\", remaining);\n  let steps = yield select(trace.steps);\n  debug(\"total steps: %o\", steps.length);\n  let waitingForSubmodules = 0;\n\n  if (remaining > 0) {\n    // updates state for current step\n    waitingForSubmodules = yield select(trace.application.submoduleCount);\n    yield put(actions.tick());\n\n    //wait for all backticks before continuing\n    while (waitingForSubmodules > 0) {\n      yield take(actions.TOCK);\n      waitingForSubmodules--;\n    }\n\n    remaining--; // local update, just for convenience\n  }\n\n  if (remaining) {\n    // updates step to next step in trace\n    yield put(actions.advance());\n  } else {\n    yield put(actions.endTrace());\n  }\n}\n\nexport function* signalTickSagaCompletion() {\n  yield put(actions.tock());\n}\n\nexport function* processTrace(steps) {\n  yield put(actions.saveSteps(steps));\n\n  let callAddresses = new Set();\n  let selfDestructAddresses = new Set();\n  let createdBinaries = {};\n\n  for (let index = 0; index < steps.length; index++) {\n    const { op, depth, stack, memory } = steps[index];\n    if (isCallMnemonic(op)) {\n      callAddresses.add(Codec.Evm.Utils.toAddress(stack[stack.length - 2]));\n    } else if (isCreateMnemonic(op)) {\n      const returnStep = steps\n        .slice(index + 1)\n        .find(step => step.depth === depth);\n      if (returnStep) {\n        const returnStack = returnStep.stack;\n        const address = Codec.Evm.Utils.toAddress(\n          returnStack[returnStack.length - 1]\n        );\n        if (address !== Codec.Evm.Utils.ZERO_ADDRESS) {\n          //now: extract the created binary.\n          //note we multiply by 2 because we're dealing with hex strings.\n          const offset = parseInt(stack[stack.length - 2], 16) * 2;\n          const length = parseInt(stack[stack.length - 3], 16) * 2;\n          const binary =\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\");\n          createdBinaries[address] = binary;\n          //warning: this is a deliberately crude method!\n          //it may warrant replacement later.\n          //(but it should be good enough for most purposes)\n        }\n      }\n    } else if (isSelfDestructMnemonic(op)) {\n      selfDestructAddresses.add(\n        Codec.Evm.Utils.toAddress(stack[stack.length - 1])\n      );\n    }\n  }\n\n  return {\n    calls: [...callAddresses],\n    selfdestructs: [...selfDestructAddresses],\n    creations: createdBinaries\n  };\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName, keccak256 } from \"lib/helpers\";\nimport * as Codec from \"@truffle/codec\";\nimport BN from \"bn.js\";\n\nimport { TICK } from \"lib/trace/actions\";\nimport * as actions from \"../actions\";\n\nimport evm from \"../selectors\";\n\nimport * as web3 from \"lib/web3/sagas\";\nimport * as trace from \"lib/trace/sagas\";\n\n/**\n * Adds EVM bytecode context\n *\n * @return {string} ID (0x-prefixed keccak of binary)\n */\nexport function* addContext(context) {\n  //get context hash if context doesn't already have it\n  const contextHash =\n    context.context || keccak256({ type: \"string\", value: context.binary });\n  //NOTE: we take hash as *string*, not as bytes, because the binary may\n  //contain link references!\n\n  debug(\"context %O\", context);\n  yield put(actions.addContext({ ...context, context: contextHash }));\n\n  return contextHash;\n}\n\n/**\n * Adds to codex known deployed instance of binary at address\n * (not to list of affected instances)\n *\n * @param {string} binary - may be undefined (e.g. precompiles)\n * @return {string} ID (0x-prefixed keccak of binary)\n */\nexport function* addInstance(address, binary) {\n  const search = yield select(evm.info.binaries.search);\n  const context = search(binary);\n\n  //now, whether we needed a new context or not, add the instance\n  yield put(actions.addInstance(address, context, binary));\n\n  return context;\n}\n\nexport function* recordStorage(address, slot, word) {\n  const slotAsPrefixlessHex = Codec.Conversion.toHexString(\n    slot,\n    Codec.Evm.Utils.WORD_SIZE\n  ).slice(2); //remove \"0x\" prefix in addition to converting to hex\n  yield put(actions.load(address, slotAsPrefixlessHex, word));\n}\n\n//NOTE: calling this *can* add a new instance, which will not\n//go away on a reset!  Yes, this is a little weird, but we\n//decided this is OK for now\nexport function* requestCode(address) {\n  const blockNumber = (yield select(\n    evm.transaction.globals.block\n  )).number.toString();\n  const instances = yield select(evm.current.codex.instances);\n\n  if (address in instances) {\n    //because this function is used by data, we return a Uint8Array\n    return Codec.Conversion.toBytes(instances[address].binary);\n    //former special case here for zero address is now gone since it's\n    //now covered by this case\n  } else {\n    //I don't want to write a new web3 saga, so let's just use\n    //obtainBinaries with a one-element array\n    debug(\"fetching binary\");\n    let binary = (yield* web3.obtainBinaries([address], blockNumber))[0];\n    debug(\"adding instance\");\n    yield* addInstance(address, binary);\n    return Codec.Conversion.toBytes(binary);\n  }\n}\n\n//NOTE: just like requestCode, this can also add to the codex!\n//yes, this is also weird.\nexport function* requestStorage(slot) {\n  //slot is a BN here\n  const currentStorage = yield select(evm.current.codex.storage);\n  const slotAsHex = Codec.Conversion.toHexString(slot).slice(2); //remove 0x prefix\n  if (slotAsHex in currentStorage) {\n    //because this function is used by data, we return a Uint8Array\n    return Codec.Conversion.toBytes(currentStorage[slotAsHex]);\n  }\n  //if we don't already know it, we'll have to look it up\n  const storageLookup = yield select(evm.application.storageLookup);\n  if (storageLookup) {\n    const address = (yield select(evm.current.call)).storageAddress;\n    const blockHash = yield select(evm.transaction.blockHash); //cannot use number here!\n    const txIndex = yield select(evm.transaction.txIndex);\n    const word = yield* web3.obtainStorage(address, slot, blockHash, txIndex);\n    yield* recordStorage(address, slot, word);\n    return Codec.Conversion.toBytes(word);\n  } else {\n    //indicates to codec this storage is unknown\n    return null;\n  }\n}\n\n/**\n * Adds known deployed instance of binary at address\n * to list of affected instances, *not* to codex\n *\n * creationBinary may also be specified\n *\n * @param {string} binary - may be undefined (e.g. precompiles)\n * @return {string} ID (0x-prefixed keccak of binary)\n */\nexport function* addAffectedInstance(address, binary, creationBinary) {\n  const search = yield select(evm.info.binaries.search);\n  const context = search(binary);\n  const creationContext = creationBinary ? search(creationBinary) : null;\n\n  //now, whether we needed a new context or not, add the instance\n  //note that these last two arguments may be undefined/null\n  yield put(\n    actions.addAffectedInstance(\n      address,\n      context,\n      binary,\n      creationBinary,\n      creationContext\n    )\n  );\n\n  return context;\n}\n\n//goes through all instances (codex & affected) and re-adds them with their new\n//context (used if new contexts have been added -- something\n//that currently only happens when adding external compilations)\nexport function* refreshInstances() {\n  const instances = yield select(evm.current.codex.instances);\n  const affectedInstances = yield select(evm.transaction.affectedInstances);\n  for (let [address, { binary }] of Object.entries(instances)) {\n    const search = yield select(evm.info.binaries.search);\n    const context = search(binary);\n    yield put(actions.addInstance(address, context, binary));\n  }\n  for (let [address, { binary, creationBinary }] of Object.entries(\n    affectedInstances\n  )) {\n    const search = yield select(evm.info.binaries.search);\n    const context = search(binary);\n    const creationContext = creationBinary ? search(creationBinary) : null;\n    yield put(\n      actions.addAffectedInstance(\n        address,\n        context,\n        binary,\n        creationBinary,\n        creationContext\n      )\n    );\n  }\n}\n\nexport function* begin({\n  address,\n  binary,\n  data,\n  storageAddress,\n  status,\n  sender,\n  value,\n  gasprice,\n  block,\n  blockHash,\n  txIndex\n}) {\n  yield put(actions.saveGlobals(sender, gasprice, block));\n  yield put(actions.saveStatus(status));\n  yield put(actions.saveTxIdentification(blockHash, txIndex));\n  if (address) {\n    yield put(actions.call(address, data, storageAddress, sender, value));\n  } else {\n    yield put(actions.create(binary, storageAddress, sender, value));\n  }\n}\n\nfunction* tickSaga() {\n  debug(\"got TICK\");\n\n  yield* callstackAndCodexSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\n//NOTE: We don't account here for multiple simultaneous returns.\n//Such a case is *vanishingly* unlikely to come up in real code\n//so it's simply not worth the trouble.  Such a case will screw\n//up the debugger pretty good as a result.\n//(...but I might go back and do it later. :P )\n\nexport function* callstackAndCodexSaga() {\n  if (yield select(evm.current.step.isExceptionalHalting)) {\n    //let's handle this case first so we can be sure everything else is *not*\n    //an exceptional halt\n    debug(\"exceptional halt!\");\n\n    yield put(actions.fail());\n  } else if (yield select(evm.current.step.isInstantCallOrCreate)) {\n    // if there is no binary (e.g. for precompiles or externally owned\n    // accounts), or if the call fails instantly (callstack overflow or not\n    // enough ether), there will be no trace steps for the called code, and so\n    // we shouldn't tell the debugger that we're entering another execution\n    // context\n    // (so we do nothing)\n  } else if (yield select(evm.current.step.isCall)) {\n    debug(\"got call\");\n\n    let address = yield select(evm.current.step.callAddress);\n    let data = yield select(evm.current.step.callData);\n\n    debug(\"calling address %s\", address);\n\n    if (yield select(evm.current.step.isDelegateCallStrict)) {\n      //if delegating, leave storageAddress, sender, and value the same\n      let { storageAddress, sender, value } = yield select(evm.current.call);\n      yield put(actions.call(address, data, storageAddress, sender, value));\n    } else {\n      //this branch covers CALL, CALLCODE, and STATICCALL\n      let currentCall = yield select(evm.current.call);\n      let storageAddress = (yield select(evm.current.step.isDelegateCallBroad))\n        ? currentCall.storageAddress //for CALLCODE\n        : address;\n      let sender = currentCall.storageAddress; //not the code address!\n      let value = yield select(evm.current.step.callValue); //0 if static\n      yield put(actions.call(address, data, storageAddress, sender, value));\n    }\n  } else if (yield select(evm.current.step.isCreate)) {\n    debug(\"got create\");\n    let binary = yield select(evm.current.step.createBinary);\n    let createdAddress = yield select(evm.current.step.createdAddress);\n    let value = yield select(evm.current.step.createValue);\n    let sender = (yield select(evm.current.call)).storageAddress;\n    //not the code address!\n\n    yield put(actions.create(binary, createdAddress, sender, value));\n    //as above, storageAddress handles when calling from a creation call\n  } else if (yield select(evm.current.step.isNormalHalting)) {\n    debug(\"got return\");\n\n    let { binary, storageAddress } = yield select(evm.current.call);\n\n    if (binary) {\n      //if we're returning from a successful creation call, let's log the\n      //result\n      let returnedBinary = yield select(evm.current.step.returnValue);\n      let search = yield select(evm.info.binaries.search);\n      let returnedContext = search(returnedBinary);\n      yield put(\n        actions.returnCreate(storageAddress, returnedBinary, returnedContext)\n      );\n    } else {\n      yield put(actions.returnCall());\n    }\n  } else if (yield select(evm.current.step.isStore)) {\n    let storageAddress = (yield select(evm.current.call)).storageAddress;\n    let slot = yield select(evm.current.step.storageAffected);\n    let storedValue = yield select(evm.current.step.valueStored);\n    yield put(actions.store(storageAddress, slot, storedValue));\n  } else if (yield select(evm.current.step.isLoad)) {\n    let storageAddress = (yield select(evm.current.call)).storageAddress;\n    let slot = yield select(evm.current.step.storageAffected);\n    let loadedValue = yield select(evm.current.step.valueLoaded);\n    yield put(actions.load(storageAddress, slot, loadedValue));\n  }\n}\n\nexport function* reset() {\n  const initialCall = yield select(evm.transaction.initialCall);\n  yield put(actions.reset());\n  yield put(initialCall);\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* setStorageLookup(status) {\n  const supported = yield* isStorageLookupSupported();\n  if (status && !supported) {\n    throw new Error(\n      \"The storageLookup option was passed, but the debug_storageRangeAt method is not available on this client.\"\n    );\n  }\n  yield put(actions.setStorageLookup(status));\n}\n\nfunction* isStorageLookupSupported() {\n  const storedValue = yield select(evm.application.storageLookupSupported);\n  //exit out early if it's already set\n  if (storedValue !== null) {\n    return storedValue;\n  }\n  const blockHash = yield select(evm.transaction.blockHash); //cannot use number here!\n  let supported;\n  try {\n    //note we need to use a blockHash and txIndex that actually exists, otherwise\n    //we'll get an error for a different reason; that's why this procedure is\n    //only performed once we have a transaction loaded, even though notionally it's\n    //independent of any transaction\n    yield* web3.obtainStorage(\n      Codec.Evm.Utils.ZERO_ADDRESS,\n      new BN(0),\n      blockHash,\n      0 //to avoid delays, we'll use 0 rather than the actual tx index...\n      //index 0 certainly exists as long as the block has any transactions!\n    ); //throw away the value\n    supported = true;\n  } catch {\n    supported = false;\n  }\n  yield put(actions.setStorageLookupSupport(supported));\n  return supported;\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"evm\", saga);\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/sum\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\n\nimport {\n  prefixName,\n  stableKeccak256,\n  makeAssignment,\n  makePath\n} from \"lib/helpers\";\n\nimport { TICK } from \"lib/trace/actions\";\nimport * as actions from \"../actions\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as trace from \"lib/trace/sagas\";\n\nimport data from \"../selectors\";\n\nimport sum from \"lodash/sum\";\nimport jsonpointer from \"json-pointer\";\n\nimport * as Codec from \"@truffle/codec\";\nimport BN from \"bn.js\";\n\nexport function* scope(nodeId, pointer, parentId, sourceIndex, sourceId) {\n  yield put(actions.scope(nodeId, pointer, parentId, sourceIndex, sourceId));\n}\n\nexport function* declare(node, sourceId) {\n  yield put(actions.declare(node.name, node.id, node.scope, sourceId));\n}\n\nexport function* yulScope(pointer, sourceIndex, sourceId, parentId) {\n  yield put(\n    //node ID is always undefined\n    actions.scope(undefined, pointer, parentId, sourceIndex, sourceId)\n  );\n}\n\nexport function* yulDeclare(\n  node,\n  pointer,\n  scopePointer,\n  sourceIndex,\n  sourceId\n) {\n  yield put(\n    actions.declare(\n      node.name,\n      makePath(sourceIndex, pointer),\n      makePath(sourceIndex, scopePointer),\n      sourceId\n    )\n  );\n}\n\nexport function* defineType(node, sourceId) {\n  yield put(actions.defineType(node, sourceId));\n}\n\nexport function* defineTaggedOutput(node, sourceId) {\n  yield put(actions.defineTaggedOutput(node, sourceId));\n}\n\nfunction* tickSaga() {\n  yield* variablesAndMappingsSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\nfunction* variablesAndMappingsSaga() {\n  // stack is only ready for interpretation after the last step of each\n  // source range\n  //\n  // the data module always looks at the result of a particular opcode\n  // (i.e., the following trace step's stack/memory/storage), so this\n  // asserts that the _current_ operation is the final one before\n  // proceeding\n  if (!(yield select(data.views.atLastInstructionForSourceRange))) {\n    return;\n  }\n\n  let node = yield select(data.current.node);\n  //can mutate in FunctionTypeName, YulLiteral, and YulIdentifier cases\n\n  if (!node) {\n    return;\n  }\n\n  //set up stack; see default case for what normally goes on\n  let stack;\n  switch (node.nodeType) {\n    case \"IndexAccess\":\n    case \"MemberAccess\":\n      stack = yield select(data.nextUserStep.state.stack);\n      //HACK: unfortunately, in some cases, data.next.state.stack gets the wrong\n      //results due to unmapped/internal instructions intervening.  So, we get the stack at\n      //the next mapped-to-user-source stack instead.  This is something of a hack and won't\n      //work if we're about to change context, but it should work in the cases that\n      //need it.\n      break;\n    case \"YulFunctionCall\":\n      stack = yield select(data.nextOfSameDepth.state.stack);\n      //if the step we're on is a CALL (or similar), as can happen with Yul,\n      //we don't want to look at the stack on the *next* step, but rather\n      //the step when it returns; hence this\n      break;\n    default:\n      stack = yield select(data.next.state.stack); //note the use of next!\n      //in this saga we are interested in the *results* of the current instruction\n      //note that the decoder is still based on data.current.state; that's fine\n      //though.  There's already a delay between when we record things off the\n      //stack and when we decode them, after all.  Basically, nothing serious\n      //should happen after an index node but before the index access node that\n      //would cause storage, memory, or calldata to change, meaning that even if\n      //the literal we recorded was a pointer, it will still be valid at the time\n      //we use it.  (The other literals we make use of, for the base expressions,\n      //are not decoded, so no potential mismatch there would be relevant anyway.)\n      break;\n  }\n\n  if (!stack) {\n    //note: should only happen in YulFunctionCall case\n    return;\n  }\n\n  const top = stack.length - 1;\n\n  //set up other variables\n  let pointer = yield select(data.current.pointer); //can mutate in YulLiteral and YulIdentifier cases\n  const currentDepth = yield select(data.current.functionDepth);\n  const modifierDepth = yield select(data.current.modifierDepth);\n  const inModifier = yield select(data.current.inModifier);\n  const address = yield select(data.current.address); //storage address, not code address\n  const compilationId = yield select(data.current.compilationId);\n  const internalFor = yield select(data.current.internalSourceFor);\n  //just in case it ever becomes possible to have a Solidity generated source\n\n  let assignments, preambleAssignments;\n\n  //HACK: modifier preamble\n  //modifier definitions are typically skipped (this includes constructor\n  //definitions when called as a base constructor); as such I've added this\n  //\"modifier preamble\" to catch them\n  if (yield select(data.current.aboutToModify)) {\n    const modifier = yield select(data.current.modifierBeingInvoked);\n    //may be either a modifier or base constructor\n    const currentIndex = yield select(data.current.modifierArgumentIndex);\n    debug(\"currentIndex %d\", currentIndex);\n    const parameters = modifier.parameters.parameters;\n    //now: look at the parameters *after* the current index.  we'll need to\n    //adjust for those.\n    const parametersLeft = parameters.slice(currentIndex + 1);\n    const adjustment = sum(parametersLeft.map(Codec.Ast.Utils.stackSize));\n    debug(\"adjustment %d\", adjustment);\n    preambleAssignments = assignParameters(\n      compilationId,\n      internalFor,\n      parameters,\n      top + adjustment,\n      currentDepth,\n      modifierDepth,\n      modifier.nodeType === \"ModifierDefinition\"\n    );\n  } else {\n    preambleAssignments = {};\n  }\n\n  switch (node.nodeType) {\n    case \"FunctionDefinition\":\n    case \"ModifierDefinition\":\n      //NOTE: this will *not* catch most modifier definitions!\n      //the rest hopefully will be caught by the modifier preamble\n      //(in fact they won't all be, but...)\n\n      //HACK: prevent parameter allocation while popping\n      //sometimes Solidity's sourcemapping will jump back to the function\n      //definition after a bare block while it pops the stack a bit.\n      //we don't want to allocate then, so we'll break out if the current\n      //instruction is a POP.\n      if (yield select(data.current.isPop)) {\n        break;\n      }\n\n      //HACK: filter out some garbage\n      //this filters out the case where we're really in an invocation of a\n      //modifier or base constructor, but have temporarily hit the definition\n      //node for some reason.  However this obviously can have a false positive\n      //in the case where a function has the same modifier twice.\n      const nextModifier = yield select(data.next.modifierBeingInvoked);\n      if (nextModifier && nextModifier.id === node.id) {\n        break;\n      }\n\n      const parameters = node.parameters.parameters;\n      //note that we do *not* include return parameters, since those are\n      //handled by the VariableDeclaration case (no, I don't know why it\n      //works out that way)\n\n      //we can skip preambleAssignments here, that isn't used in this case\n      assignments = assignParameters(\n        compilationId,\n        internalFor,\n        parameters,\n        top,\n        currentDepth,\n        modifierDepth,\n        inModifier\n      );\n\n      debug(\"Function definition case\");\n      debug(\"assignments %O\", assignments);\n\n      yield put(actions.assign(assignments));\n      break;\n\n    case \"YulFunctionDefinition\": {\n      const nextPointer = yield select(data.next.pointer);\n      if (!(yield select(data.current.onYulFunctionDefinitionWhileEntering))) {\n        //in this case, we're seeing the function as it's being defined, rather\n        //than as it's being called\n        break;\n      }\n      //yul parameters are a bit weird.\n      //whereas solidity parameters go bottom to top,\n      //first inputs then outputs (and we skip handling the outputs),\n      //yul parameters have the inputs go top to bottom,\n      //and the outputs go bottom to top (again with the outputs on top)\n      //For Solidity <0.8.4, we need to handle both inputs and outputs\n      //here; for Solidity >=0.8.4, we handle only inputs here and handle\n      //outputs separately\n      let returnSuffixes = [];\n      if (nextPointer.startsWith(`${pointer}/body/`)) {\n        returnSuffixes = (node.returnVariables || []).map(\n          (_, index, vars) => `/returnVariables/${vars.length - 1 - index}`\n        );\n      }\n      const parameterSuffixes = (node.parameters || []).map(\n        (_, index) => `/parameters/${index}`\n      );\n      //HACK: prior to 0.6.8, we *also* need to account for any bare lets (ones\n      //w/no value given) at the beginning of the function body because these\n      //will throw off our count otherwise\n      let bareLetSuffixes = []; //when hack is not invoked, we just leave this empty\n      if (!(yield select(data.current.bareLetsInYulAreHit))) {\n        let outerIndex = 0;\n        for (const declaration of node.body.statements) {\n          if (\n            declaration.nodeType !== \"YulVariableDeclaration\" ||\n            declaration.value != null\n          ) {\n            //deliberate != for future Solidity versions\n            break;\n          }\n          for (\n            let innerIndex = 0;\n            innerIndex < declaration.variables.length;\n            innerIndex++\n          ) {\n            //we want to process from top to bottom, so we'll put the earlier\n            //variables last\n            bareLetSuffixes.unshift(\n              `/body/statements/${outerIndex}/variables/${innerIndex}`\n            );\n          }\n          outerIndex++;\n        }\n      }\n      //both outputs and inputs in the appropriate order (top to bottom)\n      //(well, and those lets...)\n      const suffixes = bareLetSuffixes.concat(\n        returnSuffixes,\n        parameterSuffixes\n      );\n      debug(\"suffixes: %O\", suffixes);\n      assignments = {};\n      let position = top; //because that's how we'll process things\n      const sourceIndex = yield select(data.current.sourceIndex);\n      for (const suffix of suffixes) {\n        //we only care about the pointer, not the variable\n        const sourceAndPointer = makePath(sourceIndex, pointer + suffix);\n        const assignment = makeAssignment(\n          {\n            compilationId,\n            internalFor,\n            astRef: sourceAndPointer,\n            stackframe: currentDepth,\n            modifierDepth: inModifier ? modifierDepth : null\n          },\n          {\n            location: \"stack\",\n            from: position, //all Yul variables are size 1\n            to: position\n          }\n        );\n        assignments[assignment.id] = assignment;\n        position--;\n      }\n      yield put(actions.assign(assignments));\n      break;\n    }\n\n    case \"ContractDefinition\": {\n      const allocations = yield select(data.current.allocations.state);\n      const allocation = allocations[node.id];\n\n      debug(\"Contract definition case\");\n      debug(\"allocations %O\", allocations);\n      debug(\"allocation %O\", allocation);\n      assignments = {};\n      for (let id in allocation.members) {\n        id = Number(id); //used for .. in loop so get them as strings\n        const idObj = {\n          compilationId,\n          internalFor,\n          astRef: id\n        };\n        //these aren't locals, so we omit stackframe and modifier info\n        const ref = allocation.members[id].pointer;\n        const assignment = makeAssignment(idObj, ref);\n        assignments[assignment.id] = assignment;\n      }\n      //one more: add in the fallback input assignment here\n      const fallbackDefinition = node.nodes.find(\n        subNode =>\n          subNode.nodeType === \"FunctionDefinition\" &&\n          Codec.Ast.Utils.functionKind(subNode) === \"fallback\"\n      );\n      if (fallbackDefinition) {\n        const fallbackInputDefinition =\n          fallbackDefinition.parameters.parameters[0]; //may be undefined\n        if (fallbackInputDefinition) {\n          const base = yield select(data.current.fallbackBase);\n          const ref = {\n            location: \"stack\",\n            from: base,\n            to: base + Codec.Ast.Utils.stackSize(fallbackInputDefinition) - 1\n            //note: we will always have to===from+1, since it's always bytes calldata, but\n            //we'll do it this way just to be safe\n          }; //fallback input is always at the very bottom\n          const idObj = {\n            compilationId,\n            internalFor,\n            astRef: fallbackInputDefinition.id,\n            stackframe: currentDepth, //note the lack of a jump into fallbacks\n            modifierDepth: null //it's a function body variable\n          };\n          const assignment = makeAssignment(idObj, ref);\n          assignments[assignment.id] = assignment;\n        }\n      }\n      debug(\"assignments %O\", assignments);\n\n      //this case doesn't need preambleAssignments either\n      yield put(actions.assign(assignments));\n      break;\n    }\n\n    case \"FunctionTypeName\": {\n      //HACK\n      //for some reasons, for declarations of local variables of function type,\n      //we land on the FunctionTypeName instead of the VariableDeclaration,\n      //so we replace the node with its parent (the VariableDeclaration)\n      const scopes = yield select(data.current.scopes.inlined);\n      node = scopes[scopes[node.id].parentId].definition;\n      //let's do a quick check that it *is* a VariableDeclaration before\n      //continuing\n      if (node.nodeType !== \"VariableDeclaration\") {\n        break;\n      }\n    }\n    //otherwise, deliberately fall through to the VariableDeclaration case\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"VariableDeclaration\": {\n      const varId = node.id;\n      debug(\"Variable declaration case\");\n      debug(\"currentDepth %d varId %d\", currentDepth, varId);\n\n      const inFunctionOrModifier = yield select(\n        data.current.inFunctionOrModifier\n      );\n      if (!inFunctionOrModifier) {\n        //if we're not in a function or modifier, then this is a contract\n        //variable, not a local variable, and should not be included\n        debug(\"already a contract variable!\");\n        break;\n      }\n\n      //otherwise, go ahead and make the assignment\n      const assignment = makeAssignment(\n        {\n          compilationId,\n          internalFor,\n          astRef: varId,\n          stackframe: currentDepth,\n          modifierDepth: inModifier ? modifierDepth : null\n        },\n        {\n          location: \"stack\",\n          from: top - Codec.Ast.Utils.stackSize(node) + 1,\n          to: top\n        }\n      );\n      assignments = { [assignment.id]: assignment };\n      //this case doesn't need preambleAssignments either\n      debug(\"assignments: %O\", assignments);\n      yield put(actions.assign(assignments));\n      break;\n    }\n\n    case \"YulFunctionCall\": {\n      const nextPointer = yield select(data.next.pointer);\n      if (nextPointer !== null && nextPointer.startsWith(pointer)) {\n        //if we're moving inside the function call itself, ignore it\n        break;\n      }\n    }\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"YulLiteral\":\n    case \"YulIdentifier\":\n      //yul variable declaration, maybe\n      const parentPointer = pointer.replace(/\\/[^/]*$/, \"\"); //chop off end\n      const root = yield select(data.current.root);\n      const parent = jsonpointer.get(root, parentPointer);\n      if (\n        pointer !== `${parentPointer}/value` ||\n        parent.nodeType !== \"YulVariableDeclaration\"\n      ) {\n        break;\n      }\n      node = parent;\n      pointer = parentPointer;\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"YulVariableDeclaration\": {\n      const sourceIndex = yield select(data.current.sourceIndex);\n      const sourceAndPointer = makePath(sourceIndex, pointer);\n      debug(\"sourceAndPointer: %s\", sourceAndPointer);\n      assignments = {};\n      //variables go on from bottom to top, so process from top to bottom\n      let position = top; //NOTE: remember that which stack we use depends on our node type!\n      for (let index = node.variables.length - 1; index >= 0; index--) {\n        //we only care about the pointer, not the variable\n        const variableSourceAndPointer = `${sourceAndPointer}/variables/${index}`;\n        const assignment = makeAssignment(\n          {\n            compilationId,\n            internalFor,\n            astRef: variableSourceAndPointer,\n            stackframe: currentDepth,\n            modifierDepth: inModifier ? modifierDepth : null\n          },\n          {\n            location: \"stack\",\n            from: position, //all Yul variables are size 1\n            to: position\n          }\n        );\n        assignments[assignment.id] = assignment;\n        position--;\n      }\n\n      //this case doesn't need preambleAssignments, obviously!\n      yield put(actions.assign(assignments));\n      break;\n    }\n\n    case \"YulTypedName\": {\n      //this case is used to handle output parameters in Yul in\n      //Solidity >=0.8.4\n      const sourceIndex = yield select(data.current.sourceIndex);\n      const sourceAndPointer = makePath(sourceIndex, pointer);\n      const assignment = makeAssignment(\n        {\n          compilationId,\n          internalFor,\n          astRef: sourceAndPointer,\n          stackframe: currentDepth,\n          modifierDepth: inModifier ? modifierDepth : null\n        },\n        {\n          location: \"stack\",\n          from: top, //all Yul variables are size 1\n          to: top\n        }\n      );\n      yield put(actions.assign({ [assignment.id]: assignment }));\n      break;\n    }\n\n    case \"IndexAccess\": {\n      // to track `mapping` types known indices\n      // (and also *some* known indices for arrays)\n\n      debug(\"Index access case\");\n\n      //we're going to start by doing the same thing as in the default case\n      //(see below) -- getting things ready for an assignment.  Then we're\n      //going to forget this for a bit while we handle the rest...\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          internalFor,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n\n      //we'll need this\n      const baseExpression = node.baseExpression;\n\n      //but first, a diversion -- is this something that could not *possibly*\n      //lead to a mapping?  i.e., either a bytes, or an array of non-reference\n      //types, or a non-storage array?\n      //if so, we'll just do the assign and quit out early\n      //(note: we write it this way because mappings aren't caught by\n      //isReference)\n      if (\n        Codec.Ast.Utils.typeClass(baseExpression) === \"bytes\" ||\n        (Codec.Ast.Utils.typeClass(baseExpression) === \"array\" &&\n          (Codec.Ast.Utils.isReference(node)\n            ? Codec.Ast.Utils.referenceType(baseExpression) !== \"storage\"\n            : !Codec.Ast.Utils.isMapping(node)))\n      ) {\n        debug(\"Index case bailed out early\");\n        debug(\"typeClass %s\", Codec.Ast.Utils.typeClass(baseExpression));\n        debug(\n          \"referenceType %s\",\n          Codec.Ast.Utils.referenceType(baseExpression)\n        );\n        debug(\"isReference(node) %o\", Codec.Ast.Utils.isReference(node));\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      const allocations = yield select(data.current.allocations.state);\n      const currentAssignments = yield select(data.proc.assignments);\n\n      const path = fetchBasePath(\n        compilationId,\n        internalFor,\n        baseExpression,\n        currentAssignments,\n        allocations,\n        currentDepth,\n        modifierDepth,\n        inModifier\n      );\n      //this may fail, so let's check for that\n      if (path === null) {\n        debug(\"bailed out due to failed path\");\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      const scopes = yield select(data.current.scopes.inlined);\n\n      let keyDefinition = Codec.Ast.Utils.keyDefinition(baseExpression, scopes);\n      //if we're dealing with an array, this will just spoof up a uint\n      //definition :)\n\n      //now... the decoding! (this is messy)\n      let indexValue = yield* decodeMappingKeySaga(\n        node.indexExpression,\n        keyDefinition\n      );\n\n      debug(\"index value %O\", indexValue);\n      debug(\"keyDefinition %o\", keyDefinition);\n\n      //whew! But we're not done yet -- we need to turn this decoded key into\n      //an actual path (assuming we *did* decode it; we check both for null\n      //and for the result being a Value and not an Error)\n      //OK, not an actual path -- we're just going to use a simple offset for\n      //the path.  But that's OK, because the mappedPaths reducer will turn\n      //it into an actual path.\n      if (indexValue != null && indexValue.value) {\n        let slot = { path };\n\n        //we need to do things differently depending on whether we're dealing\n        //with an array or mapping\n        switch (Codec.Ast.Utils.typeClass(baseExpression)) {\n          case \"array\":\n            const compiler = yield select(data.current.compiler);\n            const storageAllocations = yield select(\n              data.info.allocations.storage\n            );\n            const userDefinedTypes = yield select(data.views.userDefinedTypes);\n            slot.hashPath = Codec.Ast.Utils.isDynamicArray(baseExpression);\n            slot.offset = indexValue.value.asBN.muln(\n              Codec.Storage.Allocate.storageSize(\n                Codec.Ast.Import.definitionToType(\n                  node,\n                  compilationId,\n                  compiler\n                ),\n                userDefinedTypes,\n                storageAllocations\n              ).words\n            );\n            break;\n          case \"mapping\":\n            slot.key = indexValue;\n            slot.offset = new BN(0);\n            break;\n          default:\n            debug(\"unrecognized index access!\");\n        }\n        debug(\"slot %O\", slot);\n\n        //now, map it! (and do the assign as well)\n        yield put(\n          actions.mapPathAndAssign(\n            address,\n            slot,\n            assignments,\n            Codec.Ast.Utils.typeIdentifier(node),\n            Codec.Ast.Utils.typeIdentifier(baseExpression)\n          )\n        );\n      } else {\n        //if we failed to decode, just do the assign from above\n        debug(\"failed to decode, just assigning\");\n        yield put(actions.assign(assignments));\n      }\n\n      break;\n    }\n\n    case \"MemberAccess\": {\n      //we're going to start by doing the same thing as in the default case\n      //(see below) -- getting things ready for an assignment.  Then we're\n      //going to forget this for a bit while we handle the rest...\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          internalFor,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n\n      debug(\"Member access case\");\n\n      //MemberAccess uses expression, not baseExpression\n      const baseExpression = node.expression;\n\n      //if this isn't a storage struct, or the element isn't of reference type,\n      //we'll just do the assignment and quit out (again, note that mappings\n      //aren't caught by isReference)\n      if (\n        Codec.Ast.Utils.typeClass(baseExpression) !== \"struct\" ||\n        (Codec.Ast.Utils.isReference(node)\n          ? Codec.Ast.Utils.referenceType(baseExpression) !== \"storage\"\n          : !Codec.Ast.Utils.isMapping(node))\n      ) {\n        debug(\"Member case bailed out early\");\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      const allocations = yield select(data.current.allocations.state);\n      const currentAssignments = yield select(data.proc.assignments);\n\n      //but if it is a storage struct, we have to map the path as well\n      const path = fetchBasePath(\n        compilationId,\n        internalFor,\n        baseExpression,\n        currentAssignments,\n        allocations,\n        currentDepth,\n        modifierDepth,\n        inModifier\n      );\n      //this may fail, so let's check for that\n      if (path === null) {\n        debug(\"bailed out due to failed path\");\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      let slot = { path };\n\n      const compiler = yield select(data.current.compiler);\n      const structType = Codec.Ast.Import.definitionToType(\n        baseExpression,\n        compilationId,\n        compiler\n      );\n      const storageAllocations = yield select(data.info.allocations.storage);\n      const memberAllocations = storageAllocations[structType.id].members;\n      const scopes = yield select(data.current.scopes.inlined);\n      //members of a given struct have unique names so it's safe to look up the member by name\n      const memberName = scopes[node.referencedDeclaration].definition.name;\n      const memberAllocation = memberAllocations.find(\n        member => member.name === memberName\n      );\n\n      slot.offset = memberAllocation.pointer.range.from.slot.offset.clone();\n\n      debug(\"slot %o\", slot);\n      yield put(\n        actions.mapPathAndAssign(\n          address,\n          slot,\n          assignments,\n          Codec.Ast.Utils.typeIdentifier(node),\n          Codec.Ast.Utils.typeIdentifier(baseExpression)\n        )\n      );\n      break;\n    }\n\n    default:\n      if (node.id === undefined || node.typeDescriptions == undefined) {\n        break;\n      }\n\n      debug(\"decoding expression value %O\", node.typeDescriptions);\n      debug(\"default case\");\n      debug(\"currentDepth %d node.id %d\", currentDepth, node.id);\n\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          internalFor,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n      yield put(actions.assign(assignments));\n      break;\n  }\n}\n\nfunction* decodeMappingKeySaga(indexDefinition, keyDefinition) {\n  //something of a HACK -- cleans any out-of-range booleans\n  //resulting from the main mapping key decoding loop,\n  //and also filters out errors\n  let indexValue = yield* decodeMappingKeyCore(indexDefinition, keyDefinition);\n  if (indexValue) {\n    indexValue = Codec.Conversion.cleanBool(indexValue);\n    switch (indexValue.kind) {\n      case \"value\":\n        return indexValue;\n      case \"error\":\n        //if it's still an error after cleaning booleans...\n        //let's not store it as a mapping key\n        return null;\n    }\n  } else {\n    return indexValue;\n  }\n  return indexValue ? Codec.Conversion.cleanBool(indexValue) : indexValue;\n}\n\nfunction* decodeMappingKeyCore(indexDefinition, keyDefinition) {\n  const scopes = yield select(data.current.scopes.inlined);\n  const compilationId = yield select(data.current.compilationId);\n  const internalFor = yield select(data.current.internalSourceFor); //should be null, but...\n  const currentAssignments = yield select(data.proc.assignments);\n  const currentDepth = yield select(data.current.functionDepth);\n  const modifierDepth = yield select(data.current.modifierDepth);\n  const inModifier = yield select(data.current.inModifier);\n\n  //why the loop? see the end of the block it heads for an explanatory\n  //comment\n  while (true) {\n    const indexId = indexDefinition.id;\n    //indices need to be identified by stackframe\n    const indexIdObj = {\n      compilationId,\n      internalFor,\n      astRef: indexId,\n      stackframe: currentDepth,\n      modifierDepth: inModifier ? modifierDepth : null\n    };\n    const fullIndexId = stableKeccak256(indexIdObj);\n\n    const indexReference = (currentAssignments[fullIndexId] || {}).ref;\n\n    debug(\"indexDefinition.nodeType: %o\", indexDefinition.nodeType);\n    debug(\"indexDefinition.kind: %o\", indexDefinition.kind);\n    if (Codec.Ast.Utils.isSimpleConstant(indexDefinition)) {\n      //while the main case is the next one, where we look for a prior\n      //assignment, we need this case (and need it first) for two reasons:\n      //1. some constant expressions (specifically, string and hex literals)\n      //aren't sourcemapped to and so won't have a prior assignment\n      //2. if the key type is bytesN but the expression is constant, the\n      //value will go on the stack *left*-padded instead of right-padded,\n      //so looking for a prior assignment will read the wrong value.\n      //so instead it's preferable to use the constant directly.\n      debug(\"about to decode simple literal\");\n      return yield* decode(\n        keyDefinition,\n        {\n          location: \"definition\",\n          definition: indexDefinition\n        },\n        compilationId\n      );\n    } else if (indexReference) {\n      //if a prior assignment is found\n      let splicedDefinition;\n      //in general, we want to decode using the key definition, not the index\n      //definition. however, the key definition may have the wrong location\n      //on it.  so, when applicable, we splice the index definition location\n      //onto the key definition location.\n      if (Codec.Ast.Utils.isReference(indexDefinition)) {\n        splicedDefinition = Codec.Ast.Utils.spliceLocation(\n          keyDefinition,\n          Codec.Ast.Utils.referenceType(indexDefinition)\n        );\n        //we could put code here to add on the \"_ptr\" ending when absent,\n        //but we presently ignore that ending, so we'll skip that\n      } else {\n        splicedDefinition = keyDefinition;\n      }\n      debug(\"about to decode\");\n      return yield* decode(splicedDefinition, indexReference, compilationId);\n    } else if (\n      indexDefinition.referencedDeclaration &&\n      scopes[indexDefinition.referencedDeclaration]\n    ) {\n      //there's one more reason we might have failed to decode it: it might be a\n      //constant state variable.  Unfortunately, we don't know how to decode all\n      //those at the moment, but we can handle the ones we do know how to decode.\n      //In the future hopefully we will decode all of them\n      debug(\"referencedDeclaration %d\", indexDefinition.referencedDeclaration);\n      let indexConstantDeclaration =\n        scopes[indexDefinition.referencedDeclaration].definition;\n      debug(\"indexConstantDeclaration %O\", indexConstantDeclaration);\n      if (indexConstantDeclaration.constant) {\n        let indexConstantDefinition = indexConstantDeclaration.value;\n        //next line filters out constants we don't know how to handle\n        if (Codec.Ast.Utils.isSimpleConstant(indexConstantDefinition)) {\n          debug(\"about to decode simple constant\");\n          return yield* decode(\n            keyDefinition,\n            {\n              location: \"definition\",\n              definition: indexConstantDeclaration.value\n            },\n            compilationId\n          );\n        } else {\n          return null; //can't decode; see below for more explanation\n        }\n      } else {\n        return null; //can't decode; see below for more explanation\n      }\n    }\n    //there's still one more reason we might have failed to decode it:\n    //certain (silent) type conversions aren't sourcemapped either.\n    //(thankfully, any type conversion that actually *does* something seems\n    //to be sourcemapped.)  So if we've failed to decode it, we try again\n    //with the argument of the type conversion, if it is one; we leave\n    //indexValue undefined so the loop will continue\n    //(note that this case is last for a reason; if this were earlier, it\n    //would catch *non*-silent type conversions, which we want to just read\n    //off the stack)\n    else if (\n      indexDefinition.nodeType === \"FunctionCall\" &&\n      indexDefinition.kind === \"typeConversion\"\n    ) {\n      debug(\"type conversion case\");\n      indexDefinition = indexDefinition.arguments[0];\n    }\n    //...also prior to 0.5.0, unary + was legal, which needs to be accounted\n    //for for the same reason\n    else if (\n      indexDefinition.nodeType === \"UnaryOperation\" &&\n      indexDefinition.operator === \"+\"\n    ) {\n      debug(\"unary + case\");\n      indexDefinition = indexDefinition.subExpression;\n    }\n    //...and starting in 0.8.8, we'd better handle wrap and unwrap as well for\n    //the same reason!\n    else if (\n      indexDefinition.nodeType === \"FunctionCall\" &&\n      indexDefinition.kind === \"functionCall\" &&\n      [\"wrap\", \"unwrap\"].includes(\n        Codec.Ast.Utils.functionClass(indexDefinition.expression)\n      )\n    ) {\n      debug(\"wrap/unwrap case\");\n      indexDefinition = indexDefinition.arguments[0];\n    }\n    //otherwise, we've just totally failed to decode it, so we mark\n    //indexValue as null (as distinct from undefined) to indicate this.  In\n    //the future, we should be able to decode all mapping keys, but we're\n    //not quite there yet, sorry (because we can't yet handle all constant\n    //state variables)\n    else {\n      debug(\"we failed\");\n      return null;\n    }\n    debug(\"retrying\");\n    //now, as mentioned, retry in the typeConversion case\n    //(or unary + case, or wrap/unwrap case)\n  }\n}\n\nfunction literalAssignments(\n  compilationId,\n  internalFor,\n  node,\n  stack,\n  currentDepth,\n  modifierDepth,\n  inModifier\n) {\n  let top = stack.length - 1;\n\n  let literal;\n  try {\n    literal = Codec.Stack.Read.readStack(\n      {\n        location: \"stack\",\n        from: top - Codec.Ast.Utils.stackSize(node) + 1,\n        to: top\n      },\n      {\n        stack,\n        storage: {} //irrelevant, but let's respect the type signature :)\n      }\n    );\n  } catch (error) {\n    literal = undefined; //not sure if this is right, but this is what would\n    //happen before, so I figure it's safe?\n  }\n\n  let assignment = makeAssignment(\n    {\n      compilationId,\n      internalFor,\n      astRef: node.id,\n      stackframe: currentDepth,\n      modifierDepth: inModifier ? modifierDepth : null\n    },\n    { location: \"stackliteral\", literal }\n  );\n\n  return { [assignment.id]: assignment };\n}\n\n//takes a parameter list as given in the AST\nfunction assignParameters(\n  compilationId,\n  internalFor,\n  parameters,\n  top,\n  functionDepth,\n  modifierDepth = 0,\n  forModifier = false\n) {\n  let reverseParameters = parameters.slice().reverse();\n  //reverse is in-place, so we use slice() to clone first\n  debug(\"reverseParameters %o\", parameters);\n\n  let currentPosition = top;\n  let assignments = {};\n\n  for (let parameter of reverseParameters) {\n    let words = Codec.Ast.Utils.stackSize(parameter);\n    let pointer = {\n      location: \"stack\",\n      from: currentPosition - words + 1,\n      to: currentPosition\n    };\n    let assignment = makeAssignment(\n      {\n        compilationId,\n        internalFor,\n        astRef: parameter.id,\n        stackframe: functionDepth,\n        modifierDepth: forModifier ? modifierDepth : null\n      },\n      pointer\n    );\n    assignments[assignment.id] = assignment;\n    currentPosition -= words;\n  }\n  return assignments;\n}\n\nfunction fetchBasePath(\n  compilationId,\n  internalFor,\n  baseNode,\n  currentAssignments,\n  allocations,\n  currentDepth,\n  modifierDepth,\n  inModifier\n) {\n  const fullId = stableKeccak256({\n    compilationId,\n    internalFor,\n    astRef: baseNode.id,\n    stackframe: currentDepth,\n    modifierDepth: inModifier ? modifierDepth : null\n  });\n  debug(\"astId: %d\", baseNode.id);\n  debug(\"stackframe: %d\", currentDepth);\n  debug(\"fullId: %s\", fullId);\n  debug(\"currentAssignments: %O\", currentAssignments);\n  //base expression is an expression, and so has a literal assigned to\n  //it (unless it doesn't, in which case we have to handle that case)\n  const baseAssignment = currentAssignments[fullId];\n  if (baseAssignment) {\n    const offset = Codec.Conversion.toBN(baseAssignment.ref.literal);\n    return { offset };\n  }\n  //if nothing was assigned to the base expression, we have a fallback we'll attempt:\n  //we'll check if it's a top-level state variable and look up its allocation if so.\n  const referencedId = baseNode.referencedDeclaration;\n  if (referencedId != undefined) {\n    //deliberate use of !=\n    const allocation = allocations[referencedId];\n    if (allocation && allocation.pointer.location === \"storage\") {\n      return allocation.pointer.range.from.slot;\n    }\n  }\n  //if that doesn't work either, give up\n  return null;\n}\n\nexport function* decode(definition, ref, compilationId) {\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const state = yield select(data.current.state);\n  const mappingKeys = yield select(data.views.mappingKeys);\n  const allocations = yield select(data.info.allocations);\n  const contexts = yield select(data.views.contexts);\n  const currentContext = yield select(data.current.context);\n  const internalFunctionsTable = yield select(\n    data.current.internalFunctionsTable\n  );\n\n  debug(\"definition: %o\");\n  debug(\"ref: %o\");\n  debug(\"compilationId: %s\", compilationId);\n\n  const decoder = Codec.decodeVariable(\n    definition,\n    ref,\n    {\n      userDefinedTypes,\n      state,\n      mappingKeys,\n      allocations,\n      contexts,\n      currentContext,\n      internalFunctionsTable\n    },\n    compilationId\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      case \"storage\":\n        response = yield* evm.requestStorage(request.slot);\n        break;\n      case \"code\":\n        response = yield* evm.requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    debug(\"response: %O\", response);\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  debug(\"decoded value: %O\", result.value);\n  return result.value;\n}\n\nexport function* decodeReturnValue() {\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const state = yield select(data.next.state); //next state has the return data\n  const allocations = yield select(data.info.allocations);\n  const contexts = yield select(data.views.contexts);\n  const currentContext = yield select(data.current.context);\n  const status = yield select(data.current.returnStatus); //may be undefined\n  const returnAllocation = yield select(data.current.returnAllocation); //may be null\n  const errorId = yield select(data.current.errorId);\n  const internalFunctionsTable = yield select(\n    data.current.internalFunctionsTable\n  );\n  debug(\"returnAllocation: %O\", returnAllocation);\n\n  const decoder = Codec.decodeReturndata(\n    {\n      userDefinedTypes,\n      state,\n      allocations,\n      contexts,\n      currentContext,\n      internalFunctionsTable\n    },\n    returnAllocation,\n    status,\n    errorId\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      //skip storage case, it won't happen here\n      case \"code\":\n        response = yield* evm.requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  debug(\"decoded value: %O\", result.value);\n  return result.value;\n}\n\n//by default, decodes the call being made at the current step;\n//if the flag is passed, instead decodes the call you're currently in\nexport function* decodeCall(decodeCurrent = false) {\n  const isCall = yield select(data.current.isCall);\n  const isCreate = yield select(data.current.isCreate);\n  if (!isCall && !isCreate && !decodeCurrent) {\n    return null;\n  }\n  const currentCallIsCreate = yield select(data.current.currentCallIsCreate);\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  let state = decodeCurrent\n    ? yield select(data.current.state)\n    : yield select(data.next.state);\n  if (decodeCurrent && currentCallIsCreate) {\n    //if we want to decode the *current* call, but the current call\n    //is a creation, we had better pass in the code, not the calldata\n    state = {\n      ...state,\n      calldata: state.code\n    };\n  }\n  const allocations = yield select(data.info.allocations);\n  debug(\"allocations: %O\", allocations);\n  const contexts = yield select(data.views.contexts);\n  const context = decodeCurrent\n    ? yield select(data.current.context)\n    : yield select(data.current.callContext);\n  const isConstructor = decodeCurrent\n    ? yield select(data.current.currentCallIsCreate)\n    : isCreate;\n\n  const decoder = Codec.decodeCalldata(\n    {\n      state,\n      userDefinedTypes,\n      allocations,\n      contexts,\n      currentContext: context\n    },\n    isConstructor\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      //skip storage case, it won't happen here\n      case \"code\":\n        response = yield* evm.requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  return result.value;\n}\n\nexport function* decodeLog() {\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const state = yield select(data.current.state); //note: this includes the data to be decoded!\n  const allocations = yield select(data.info.allocations);\n  const contexts = yield select(data.views.contexts);\n  const currentContext = yield select(data.current.context);\n  const eventId = yield select(data.current.eventId);\n  const internalFunctionsTable = yield select(\n    data.current.internalFunctionsTable\n  );\n\n  const decoder = Codec.decodeEvent(\n    {\n      userDefinedTypes,\n      state,\n      allocations,\n      contexts,\n      currentContext,\n      internalFunctionsTable\n    },\n    null, //pass null as address to indicate we know the context already\n    {\n      id: eventId\n    }\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      //skip storage case, it won't happen here\n      case \"code\":\n        response = yield* evm.requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  debug(\"decoded value: %O\", result.value);\n  return result.value;\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* recordAllocations() {\n  const contracts = yield select(data.views.contractAllocationInfo);\n  const referenceDeclarations = yield select(data.views.referenceDeclarations);\n  const userDefinedTypesByCompilation = yield select(\n    data.views.userDefinedTypesByCompilation\n  );\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const storageAllocations = Codec.Storage.Allocate.getStorageAllocations(\n    userDefinedTypesByCompilation\n  );\n  const memoryAllocations =\n    Codec.Memory.Allocate.getMemoryAllocations(userDefinedTypes);\n  const abiAllocations =\n    Codec.AbiData.Allocate.getAbiAllocations(userDefinedTypes);\n  const calldataAllocations = Codec.AbiData.Allocate.getCalldataAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    abiAllocations\n  );\n  const returndataAllocations = Codec.AbiData.Allocate.getReturndataAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    abiAllocations\n  );\n  const eventAllocations = Codec.AbiData.Allocate.getEventAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    abiAllocations,\n    true //signals that we are allowing events from constructors\n  );\n  const stateAllocations = Codec.Storage.Allocate.getStateAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    storageAllocations\n  );\n  yield put(\n    actions.allocate(\n      storageAllocations,\n      memoryAllocations,\n      abiAllocations,\n      calldataAllocations,\n      returndataAllocations,\n      eventAllocations,\n      stateAllocations\n    )\n  );\n}\n\nexport function* addContracts(contracts) {\n  yield put(actions.addContracts(contracts));\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"data\", saga);\n","export const INTERNAL_CALL = \"TXLOG_INTERNAL_CALL\";\nexport function internalCall(pointer, newPointer, step) {\n  return {\n    type: INTERNAL_CALL,\n    pointer,\n    newPointer,\n    step\n  };\n}\n\nexport const ABSORBED_CALL = \"TXLOG_ABSORBED_CALL\";\nexport function absorbedCall(pointer) {\n  return {\n    type: ABSORBED_CALL,\n    pointer\n  };\n}\n\nexport const INTERNAL_RETURN = \"TXLOG_INTERNAL_RETURN\";\nexport function internalReturn(pointer, newPointer, step, variables) {\n  return {\n    type: INTERNAL_RETURN,\n    pointer,\n    newPointer,\n    step,\n    variables\n  };\n}\n\nexport const EXTERNAL_CALL = \"TXLOG_EXTERNAL_CALL\";\nexport function externalCall(\n  pointer,\n  newPointer,\n  step,\n  address,\n  context,\n  value,\n  isDelegate,\n  kind,\n  decoding,\n  calldata,\n  absorbNextInternalCall\n) {\n  return {\n    type: EXTERNAL_CALL,\n    pointer,\n    newPointer,\n    step,\n    address,\n    context,\n    value,\n    isDelegate,\n    kind,\n    decoding,\n    calldata,\n    absorbNextInternalCall\n  };\n}\n\nexport const INSTANT_EXTERNAL_CALL = \"TXLOG_INSTANT_EXTERNAL_CALL\";\nexport function instantExternalCall(\n  pointer,\n  newPointer, //does not actually affect the current pointer!\n  step,\n  address,\n  context,\n  value,\n  isDelegate,\n  kind,\n  decoding,\n  calldata,\n  absorbNextInternalCall,\n  status\n) {\n  return {\n    type: INSTANT_EXTERNAL_CALL,\n    pointer,\n    newPointer,\n    step,\n    address,\n    context,\n    value,\n    isDelegate,\n    kind,\n    decoding,\n    calldata,\n    absorbNextInternalCall,\n    status\n  };\n}\n\nexport const CREATE = \"TXLOG_CREATE\";\nexport function create(\n  pointer,\n  newPointer,\n  step,\n  address,\n  context,\n  value,\n  salt,\n  decoding,\n  binary\n) {\n  return {\n    type: CREATE,\n    pointer,\n    newPointer,\n    step,\n    address,\n    context,\n    value,\n    salt,\n    decoding,\n    binary\n  };\n}\n\nexport const INSTANT_CREATE = \"TXLOG_INSTANT_CREATE\";\nexport function instantCreate(\n  pointer,\n  newPointer, //does not actually affect the current pointer!\n  step,\n  address,\n  context,\n  value,\n  salt,\n  decoding,\n  binary,\n  status\n) {\n  return {\n    type: INSTANT_CREATE,\n    pointer,\n    newPointer,\n    step,\n    address,\n    context,\n    value,\n    salt,\n    decoding,\n    binary,\n    status\n  };\n}\n\nexport const EXTERNAL_RETURN = \"TXLOG_EXTERNAL_RETURN\";\nexport function externalReturn(\n  pointer,\n  newPointer,\n  step,\n  decodings,\n  returnData\n) {\n  return {\n    type: EXTERNAL_RETURN,\n    pointer,\n    newPointer,\n    step,\n    decodings,\n    returnData\n  };\n}\n\nexport const SELFDESTRUCT = \"TXLOG_SELFDESTRUCT\";\nexport function selfdestruct(pointer, newPointer, step, beneficiary) {\n  return {\n    type: SELFDESTRUCT,\n    pointer,\n    newPointer,\n    step,\n    beneficiary\n  };\n}\n\nexport const REVERT = \"TXLOG_REVERT\";\nexport function revert(pointer, newPointer, step, error) {\n  return {\n    type: REVERT,\n    pointer,\n    newPointer,\n    step,\n    error\n  };\n}\n\nexport const IDENTIFY_FUNCTION_CALL = \"TXLOG_IDENTIFY_FUNCTION_CALL\";\nexport function identifyFunctionCall(\n  pointer,\n  functionNode,\n  contractNode,\n  variables\n) {\n  return {\n    type: IDENTIFY_FUNCTION_CALL,\n    pointer,\n    functionNode,\n    contractNode,\n    variables\n  };\n}\n\nexport const LOG_EVENT = \"TXLOG_LOG_EVENT\";\nexport function logEvent(pointer, newPointer, step, decoding, rawEventInfo) {\n  return {\n    type: LOG_EVENT,\n    pointer,\n    newPointer, //does not actually affect current pointer!\n    step,\n    decoding,\n    rawEventInfo\n  };\n}\n\n//this may be replaced once decoding info is added\nexport const STORE = \"TXLOG_STORE\";\nexport function store(pointer, newPointer, step, rawSlot, rawValue) {\n  return {\n    type: STORE,\n    pointer,\n    newPointer, //does not actually affect current pointer!\n    step,\n    rawSlot,\n    rawValue\n  };\n}\n\nexport const RECORD_ORIGIN = \"TXLOG_RECORD_ORIGIN\";\nexport function recordOrigin(pointer, address) {\n  return {\n    type: RECORD_ORIGIN,\n    pointer,\n    address\n  };\n}\n\nexport const RESET = \"TXLOG_RESET\";\nexport function reset() {\n  return {\n    type: RESET\n  };\n}\n\nexport const UNLOAD_TRANSACTION = \"TXLOG_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:txlog:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\nimport * as Codec from \"@truffle/codec\";\n\nimport * as actions from \"../actions\";\nimport { TICK } from \"lib/trace/actions\";\nimport * as trace from \"lib/trace/sagas\";\nimport * as data from \"lib/data/sagas\";\n\nimport txlog from \"../selectors\";\n\nfunction* tickSaga() {\n  yield* updateTransactionLogSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\nfunction* updateTransactionLogSaga() {\n  const pointer = yield select(txlog.current.pointer); //log pointer, not AST pointer\n  const step = yield select(txlog.current.step);\n  if (yield select(txlog.current.isHalting)) {\n    //note that we process this case first so that it overrides the others!\n    const newPointer = yield select(txlog.current.externalReturnPointer);\n    const status = yield select(txlog.current.returnStatus);\n    if (status) {\n      if (yield select(txlog.current.isSelfDestruct)) {\n        const beneficiary = yield select(txlog.current.beneficiary);\n        //note: this selector returns null for a value-destroying selfdestruct\n        debug(\"sd: %o %o\", pointer, newPointer);\n        yield put(actions.selfdestruct(pointer, newPointer, step, beneficiary));\n      } else {\n        const decodings = yield* data.decodeReturnValue();\n        const rawData = yield select(txlog.current.returnData);\n        debug(\"external return: %o %o\", pointer, newPointer);\n        yield put(\n          actions.externalReturn(pointer, newPointer, step, decodings, rawData)\n        );\n      }\n    } else {\n      const error = (yield* data.decodeReturnValue())[0];\n      debug(\"revert: %o %o\", pointer, newPointer);\n      yield put(actions.revert(pointer, newPointer, step, error));\n    }\n  } else if (yield select(txlog.current.isJump)) {\n    const jumpDirection = yield select(txlog.current.jumpDirection);\n    if (jumpDirection === \"i\") {\n      const internal = yield select(txlog.next.inInternalSourceOrYul); //don't log jumps into internal sources or Yul\n      if (!internal) {\n        //we don't do any decoding/fn identification here because that's handled by\n        //the function identification case\n        if (!(yield select(txlog.current.waitingForInternalCallToAbsorb))) {\n          const newPointer = yield select(txlog.current.nextActionPointer);\n          debug(\"internal call: %o %o\", pointer, newPointer);\n          yield put(actions.internalCall(pointer, newPointer, step));\n        } else {\n          debug(\"absorbed call: %o\", pointer);\n          yield put(actions.absorbedCall(pointer));\n        }\n      }\n    } else if (jumpDirection === \"o\") {\n      const internal = yield select(txlog.current.inInternalSourceOrYul); //don't log jumps out of internal sources or Yul\n      const astMatchesTxLog = yield select(\n        txlog.current.currentFunctionIsAsExpected\n      ); //don't log returns from the wrong function...?\n      //(I've added this second check due to a strange case Amal found, hopefully this doesn't screw anything up)\n      if (!internal && astMatchesTxLog) {\n        //in this case, we have to do decoding & fn identification\n        const newPointer = yield select(txlog.current.internalReturnPointer);\n        const outputAllocations = yield select(\n          txlog.current.outputParameterAllocations\n        );\n        if (outputAllocations) {\n          const compilationId = yield select(txlog.current.compilationId);\n          //can't do a yield* inside a map, have to do this loop manually\n          let variables = [];\n          for (let { name, definition, pointer } of outputAllocations) {\n            name = name ? name : undefined; //replace \"\" with undefined\n            const decodedValue = yield* data.decode(\n              definition,\n              pointer,\n              compilationId\n            );\n            variables.push({ name, value: decodedValue });\n          }\n          debug(\"internal return: %o %o\", pointer, newPointer);\n          yield put(\n            actions.internalReturn(pointer, newPointer, step, variables)\n          );\n        } else {\n          debug(\"internal return: %o %o\", pointer, newPointer);\n          yield put(\n            actions.internalReturn(pointer, newPointer, step, undefined)\n          ); //I guess?\n        }\n      }\n    }\n  } else if (yield select(txlog.current.isCall)) {\n    const newPointer = yield select(txlog.current.nextActionPointer);\n    const address = yield select(txlog.current.callAddress);\n    const value = yield select(txlog.current.callValue);\n    //distinguishing DELEGATECALL vs CALLCODE seems unnecessary here\n    const isDelegate = yield select(txlog.current.isDelegateCallBroad);\n    //we need to determine what kind of call this is.\n    //we'll sort them into: function, constructor, message, library\n    //(library is a placeholder to be replaced later)\n    const context = yield select(txlog.current.callContext);\n    const calldata = yield select(txlog.current.callData);\n    const instant = yield select(txlog.current.isInstantCallOrCreate);\n    const kind = callKind(context, calldata, instant);\n    const absorb = yield select(txlog.current.absorbNextInternalCall);\n    const decoding = yield* data.decodeCall();\n    if (instant) {\n      const status = yield select(txlog.current.returnStatus);\n      debug(\"instacall: %o %o\", pointer, newPointer);\n      yield put(\n        actions.instantExternalCall(\n          pointer,\n          newPointer, //note: doesn't actually change the current pointer\n          step,\n          address,\n          context,\n          value,\n          isDelegate,\n          kind,\n          decoding,\n          calldata,\n          absorb,\n          status\n        )\n      );\n    } else {\n      debug(\"external call: %o %o\", pointer, newPointer);\n      yield put(\n        actions.externalCall(\n          pointer,\n          newPointer,\n          step,\n          address,\n          context,\n          value,\n          isDelegate,\n          kind,\n          decoding,\n          calldata,\n          absorb\n        )\n      );\n    }\n  } else if (yield select(txlog.current.isCreate)) {\n    const newPointer = yield select(txlog.current.nextActionPointer);\n    const address = yield select(txlog.current.createdAddress);\n    const context = yield select(txlog.current.callContext);\n    const value = yield select(txlog.current.createValue);\n    const salt = yield select(txlog.current.salt); //is null for an ordinary create\n    const instant = yield select(txlog.current.isInstantCallOrCreate);\n    const binary = yield select(txlog.current.createBinary);\n    const decoding = yield* data.decodeCall();\n    if (instant) {\n      const status = yield select(txlog.current.returnStatus);\n      debug(\"instacreate: %o %o\", pointer, newPointer);\n      yield put(\n        actions.instantCreate(\n          pointer,\n          newPointer, //note: doesn't actually change the current pointer\n          step,\n          address,\n          context,\n          value,\n          salt,\n          decoding,\n          binary,\n          status\n        )\n      );\n    } else {\n      debug(\"create: %o %o\", pointer, newPointer);\n      yield put(\n        actions.create(\n          pointer,\n          newPointer,\n          step,\n          address,\n          context,\n          value,\n          salt,\n          decoding,\n          binary\n        )\n      );\n    }\n  } else if (yield select(txlog.current.isLog)) {\n    const decoding = (yield* data.decodeLog())[0]; //just assume first decoding is correct\n    //(note: because we know the event ID, there should typically only be one decoding)\n    const rawInfo = yield select(txlog.current.rawEventInfo);\n    const newPointer = yield select(txlog.current.nextActionPointer);\n    yield put(actions.logEvent(pointer, newPointer, step, decoding, rawInfo));\n  } else if (yield select(txlog.current.isStore)) {\n    //note: in the future this is going to get much more complicated so as to\n    //include decoded info and combining things...\n    const newPointer = yield select(txlog.current.nextActionPointer);\n    const rawSlot = yield select(txlog.current.rawStorageSlot);\n    const rawValue = yield select(txlog.current.rawStorageValue);\n    yield put(actions.store(pointer, newPointer, step, rawSlot, rawValue));\n  } else if (yield select(txlog.current.onFunctionDefinition)) {\n    if (yield select(txlog.current.waitingForFunctionDefinition)) {\n      debug(\"identifying\");\n      const inputAllocations = yield select(\n        txlog.current.inputParameterAllocations\n      );\n      debug(\"inputAllocations: %O\", inputAllocations);\n      if (inputAllocations) {\n        const functionNode = yield select(txlog.current.astNode);\n        const contractNode = yield select(txlog.current.contract);\n        const compilationId = yield select(txlog.current.compilationId);\n        //can't do a yield* inside a map, have to do this loop manually\n        let variables = [];\n        for (let { name, definition, pointer } of inputAllocations) {\n          const decodedValue = yield* data.decode(\n            definition,\n            pointer,\n            compilationId\n          );\n          variables.push({ name, value: decodedValue });\n        }\n        debug(\"identify: %o\", pointer);\n        yield put(\n          actions.identifyFunctionCall(\n            pointer,\n            functionNode,\n            contractNode,\n            variables\n          )\n        );\n      }\n    }\n  }\n}\n\nfunction callKind(context, calldata, instant) {\n  if (context) {\n    if (context.contractKind === \"library\") {\n      return instant ? \"message\" : \"library\";\n      //for an instant return, just get it out of the way and set it to\n      //message rather than leaving it open (it'll get resolved in favor\n      //of message by our criteria)\n    } else {\n      const abi = context.abi;\n      const selector = calldata\n        .slice(0, 2 + 2 * Codec.Evm.Utils.SELECTOR_SIZE)\n        .padEnd(\"00\", 2 + 2 * Codec.Evm.Utils.SELECTOR_SIZE);\n      debug(\"selector: %s\", selector);\n      if (abi && selector in abi) {\n        return \"function\";\n      }\n    }\n  }\n  return \"message\";\n}\n\nexport function* reset() {\n  const initialCall = yield select(txlog.transaction.initialCall);\n  yield put(actions.reset());\n  if (initialCall) {\n    yield put(initialCall);\n  }\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* begin() {\n  const pointer = yield select(txlog.current.pointer);\n  const newPointer = yield select(txlog.current.nextActionPointer);\n  const origin = yield select(txlog.transaction.origin);\n  debug(\"origin: %o\", pointer);\n  yield put(actions.recordOrigin(pointer, origin));\n  const {\n    address,\n    binary,\n    storageAddress,\n    value,\n    data: calldata\n  } = yield select(txlog.current.call);\n  const context = yield select(txlog.current.context);\n  //note: there was an instant check here (based on checking if there are no\n  //trace steps) but I took it out, because even though having no trace steps\n  //is essentially an insta-call, the debugger doesn't treat it that way (it\n  //will see the return later), so we shouldn't here either\n  const decoding = yield* data.decodeCall(true); //pass flag to decode *current* call\n  if (address) {\n    const kind = callKind(context, calldata, false); //no insta-calls here!\n    const absorb = yield select(txlog.transaction.absorbFirstInternalCall);\n    debug(\"initial call: %o %o\", pointer, newPointer);\n    yield put(\n      actions.externalCall(\n        pointer,\n        newPointer,\n        -1, //initial call considered to happen at \"step -1\"\n        address,\n        context,\n        value,\n        false, //initial call is never delegate\n        kind,\n        decoding,\n        calldata,\n        absorb\n      )\n    );\n  } else {\n    debug(\"initial create: %o %o\", pointer, newPointer);\n    yield put(\n      actions.create(\n        pointer,\n        newPointer,\n        -1, //initial call considered to happen at \"step -1\"\n        storageAddress,\n        context,\n        value,\n        null, //initial create never has salt\n        decoding,\n        binary\n      )\n    );\n  }\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"txlog\", saga);\n","export const ADD_SOURCES = \"SOURCEMAPPING_ADD_SOURCES\";\nexport function addSources(sources) {\n  return {\n    type: ADD_SOURCES,\n    sources\n  };\n}\n\nexport const JUMP = \"SOURCEMAPPING_JUMP\";\nexport function jump(jumpDirection) {\n  return {\n    type: JUMP,\n    jumpDirection\n  };\n}\n\nexport const EXTERNAL_CALL = \"SOURCEMAPPING_EXTERNAL_CALL\";\nexport function externalCall(guard) {\n  return { type: EXTERNAL_CALL, guard };\n}\n\nexport const EXTERNAL_RETURN = \"SOURCEMAPPING_EXTERNAL_RETURN\";\nexport function externalReturn() {\n  return { type: EXTERNAL_RETURN };\n}\n\nexport const CLEAR_PHANTOM_GUARD = \"SOURCEMAPPING_CLEAR_PHANTOM_GUARD\";\nexport function clearPhantomGuard() {\n  return { type: CLEAR_PHANTOM_GUARD };\n}\n\nexport const RESET = \"SOURCEMAPPING_RESET\";\nexport function reset(guard) {\n  return { type: RESET, guard };\n}\n\nexport const UNLOAD_TRANSACTION = \"SOURCEMAPPING_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return { type: UNLOAD_TRANSACTION };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:sourcemapping:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport { TICK } from \"lib/trace/actions\";\nimport * as trace from \"lib/trace/sagas\";\n\nimport sourcemapping from \"../selectors\";\n\nexport function* addSources(sources) {\n  yield put(actions.addSources(sources));\n}\n\nfunction* tickSaga() {\n  debug(\"got TICK\");\n\n  yield* functionDepthSaga();\n  debug(\"instruction: %O\", yield select(sourcemapping.current.instruction));\n  yield* trace.signalTickSagaCompletion();\n}\n\nfunction* functionDepthSaga() {\n  if (yield select(sourcemapping.current.willReturn)) {\n    //we do this case first so we can be sure we're not failing in any of the\n    //other cases below!\n    yield put(actions.externalReturn());\n  } else if (yield select(sourcemapping.current.willJump)) {\n    let jumpDirection = yield select(sourcemapping.current.jumpDirection);\n    debug(\"checking guard\");\n    let guard = yield select(sourcemapping.current.nextFrameIsPhantom);\n    let nextSource = yield select(sourcemapping.next.source);\n    if (\n      jumpDirection === \"i\" &&\n      guard &&\n      nextSource.id !== undefined &&\n      !nextSource.internal\n    ) {\n      //note that we don't want jumps into unmapped code or internal sources to clear\n      //the phantom guard; those will just be counted like normal\n      yield put(actions.clearPhantomGuard());\n    } else {\n      yield put(actions.jump(jumpDirection));\n    }\n  } else if (yield select(sourcemapping.current.willCall)) {\n    //note: includes creations; does not include insta-returns\n    debug(\"checking if guard needed\");\n    let guard = yield select(sourcemapping.current.callRequiresPhantomFrame);\n    yield put(actions.externalCall(guard));\n  }\n}\n\nexport function* reset() {\n  let guard = yield select(\n    sourcemapping.transaction.bottomStackframeRequiresPhantomFrame\n  );\n  yield put(actions.reset(guard));\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* begin() {\n  let guard = yield select(\n    sourcemapping.transaction.bottomStackframeRequiresPhantomFrame\n  );\n  yield put(actions.externalCall(guard));\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"sourcemapping\", saga);\n","export const JUMP_IN = \"STACKTRACE_JUMP_IN\";\nexport function jumpIn(location, functionNode, contractNode, sourceIsInternal) {\n  return {\n    type: JUMP_IN,\n    location,\n    functionNode,\n    contractNode,\n    sourceIsInternal\n  };\n}\n\nexport const JUMP_OUT = \"STACKTRACE_JUMP_OUT\";\nexport function jumpOut(location) {\n  return {\n    type: JUMP_OUT,\n    location\n  };\n}\n\nexport const EXTERNAL_CALL = \"STACKTRACE_EXTERNAL_CALL\";\nexport function externalCall(\n  location,\n  context,\n  address,\n  combineWithNextInternal\n) {\n  return {\n    type: EXTERNAL_CALL,\n    location,\n    context,\n    address,\n    combineWithNextInternal\n  };\n}\n\nexport const EXTERNAL_RETURN = \"STACKTRACE_EXTERNAL_RETURN\";\nexport function externalReturn(from, status, location, index) {\n  return {\n    type: EXTERNAL_RETURN,\n    from,\n    status,\n    location,\n    index\n  };\n}\n\nexport const EXECUTE_RETURN = \"STACKTRACE_EXECUTE_RETURN\";\nexport function executeReturn(counter, location) {\n  return {\n    type: EXECUTE_RETURN,\n    counter,\n    location\n  };\n}\n\nexport const UPDATE_POSITION = \"STACKTRACE_UPDATE_POSITION\";\nexport function updatePosition(location) {\n  return {\n    type: UPDATE_POSITION,\n    location\n  };\n}\n\nexport const RESET = \"STACKTRACE_RESET\";\nexport function reset() {\n  return {\n    type: RESET\n  };\n}\n\nexport const UNLOAD_TRANSACTION = \"STACKTRACE_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport { TICK } from \"lib/trace/actions\";\nimport * as trace from \"lib/trace/sagas\";\n\nimport stacktrace from \"../selectors\";\n\nfunction* tickSaga() {\n  yield* stacktraceSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\n//NOTE: we deliberately *don't* do any phantom-checking in this\n//submodule.  yes, it will result in some junk stackframes, but\n//I really don't want a fallback or constructor frame skipped over\n//due to phantom checking\n\nfunction* stacktraceSaga() {\n  const currentLocation = yield select(stacktrace.current.strippedLocation);\n  const lastLocation = yield select(stacktrace.current.lastPosition);\n  const returnCounter = yield select(stacktrace.current.returnCounter);\n  let positionUpdated = false;\n  //different possible outcomes:\n  //first: are we returning?\n  if (yield select(stacktrace.current.willReturn)) {\n    const status = yield select(stacktrace.current.returnStatus);\n    const index = yield select(stacktrace.current.index);\n    const updateIndex = yield select(stacktrace.current.updateIndex);\n    debug(\"returning!\");\n    yield put(\n      actions.externalReturn(\n        lastLocation,\n        status,\n        currentLocation,\n        updateIndex ? index : null //we use null to mean don't update\n      )\n    );\n    positionUpdated = true;\n  } else if (\n    //next: are we *executing* a return?\n    //note this needs to be an else if or else this could execute\n    //in an inconsistent state\n    returnCounter > 0 &&\n    (yield select(stacktrace.current.positionWillChange))\n  ) {\n    debug(\"executing!\");\n    debug(\"location: %o\", yield select(stacktrace.next.location));\n    debug(\"marked: %o\", lastLocation);\n    yield put(actions.executeReturn(returnCounter, currentLocation));\n    positionUpdated = true;\n  }\n  //we now process the other possibilities.\n  //technically, an EXECUTE_RETURN could happen as well as those below,\n  //resulting in 2 actions instead of just one, but it's pretty unlikely.\n  //(an EXTERNAL_RETURN, OTOH, is obviously exclusive of the possibilities below)\n  if ((yield select(stacktrace.current.willJumpIn)) && returnCounter === 0) {\n    //note: do NOT process jumps while there are returns waiting to execute\n    const nextLocation = yield select(stacktrace.next.location);\n    const nextParent = yield select(stacktrace.next.contractNode);\n    const nextSourceIsInternal = yield select(stacktrace.next.sourceIsInternal);\n    yield put(\n      actions.jumpIn(\n        currentLocation,\n        nextLocation.node,\n        nextParent,\n        nextSourceIsInternal\n      )\n    );\n    positionUpdated = true;\n  } else if (\n    (yield select(stacktrace.current.willJumpOut)) &&\n    returnCounter === 0\n  ) {\n    //again, do not process jumps while there are returns waiting to execute\n    yield put(actions.jumpOut(currentLocation));\n    positionUpdated = true;\n  } else if (yield select(stacktrace.current.willCall)) {\n    //note: includes creations\n    //note: does *not* include calls that insta-return.  logically speaking,\n    //such calls should be a call + a return in one, right? and we could do that,\n    //making a call while also incrementing the return counter.  but the stacktraces\n    //this would generate would, I think, be more confusing than helpful, so I'm\n    //deliberately not doing that.\n    //NOTE: we can't use stacktrace.next.location here as that\n    //doesn't work across call contexts!\n    const nextContext = yield select(stacktrace.current.callContext);\n    const nextAddress = yield select(stacktrace.current.callAddress);\n    const combineWithNextInternal = yield select(\n      stacktrace.current.callCombinesWithNextJumpIn\n    );\n    yield put(\n      actions.externalCall(\n        currentLocation,\n        nextContext,\n        nextAddress,\n        combineWithNextInternal\n      )\n    );\n    positionUpdated = true;\n  }\n  //finally, if no other action updated the position, do so here\n  if (!positionUpdated) {\n    yield put(actions.updatePosition(currentLocation));\n  }\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* begin() {\n  const context = yield select(stacktrace.current.context);\n  const address = yield select(stacktrace.current.address);\n  const combineWithNextInternal = yield select(\n    stacktrace.transaction.initialCallCombinesWithNextJumpIn\n  );\n  yield put(\n    actions.externalCall(null, context, address, combineWithNextInternal)\n  );\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"stacktrace\", saga);\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:selectors\"); //eslint-disable-line no-unused-vars\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport { isSkippedNodeType } from \"lib/helpers\";\nimport * as Codec from \"@truffle/codec\";\n\nimport evm from \"lib/evm/selectors\";\nimport sourcemapping from \"lib/sourcemapping/selectors\";\nimport data from \"lib/data/selectors\";\nimport trace from \"lib/trace/selectors\";\n\n/**\n * @private\n */\nconst identity = x => x;\n\nfunction anyNonSkippedInRange(\n  findOverlappingRange,\n  node,\n  sourceStart,\n  sourceLength\n) {\n  let sourceEnd = sourceStart + sourceLength;\n  return findOverlappingRange(sourceStart, sourceLength).some(\n    ({ range, node }) =>\n      isOldStyleAssembly(node) ||\n      (sourceStart <= range[0] && //we want to go by starting line\n        range[0] < sourceEnd &&\n        !isSkippedNodeType(node))\n    //NOTE: this doesn't actually catch everything skipped!  But doing better\n    //is hard\n  );\n}\n\n//catches InlineAssembly nodes from before 0.6.0.\n//We want to be able to place breakpoints if something merely *overlaps*\n//one of these, because, well, we can't really look inside and do better.\nfunction isOldStyleAssembly(node) {\n  return node.nodeType === \"InlineAssembly\" && !node.AST;\n}\n\n/**\n * controller\n */\nconst controller = createSelectorTree({\n  /**\n   * controller.state\n   */\n  state: state => state.controller,\n  /**\n   * controller.current\n   */\n  current: {\n    /**\n     * controller.current.functionDepth\n     */\n    functionDepth: createLeaf([sourcemapping.current.functionDepth], identity),\n\n    /**\n     * controller.current.executionContext\n     */\n    executionContext: createLeaf([evm.current.call], identity),\n\n    /**\n     * controller.current.willJump\n     */\n    willJump: createLeaf([evm.current.step.isJump], identity),\n\n    /**\n     * controller.current.onBaseConstructorDefinition\n     */\n    onBaseConstructorDefinition: createLeaf(\n      [\n        \"./location/node\",\n        evm.current.context,\n        sourcemapping.current.contractNode\n      ],\n      (node, context, contract) =>\n        node &&\n        node.nodeType === \"FunctionDefinition\" &&\n        Codec.Ast.Utils.functionKind(node) === \"constructor\" &&\n        context.contractId !== contract.id //when are we on a *base* constructor\n      //definition?  precisely when the contract we're in according to the source\n      //mapping is different from the contract whose bytecode is executing\n      //(note that we don't need to check whether the compilation IDs are different,\n      //since these will always be the same)\n    ),\n\n    /**\n     * controller.current.location.onYulFunctionDefinitionWhileEntering\n     */\n    onYulFunctionDefinitionWhileEntering: createLeaf(\n      [sourcemapping.current.onYulFunctionDefinitionWhileEntering],\n      identity\n    ),\n\n    /**\n     * controller.current.location\n     */\n    location: {\n      /**\n       * controller.current.location.sourceRange\n       */\n      sourceRange: createLeaf(\n        [sourcemapping.current.sourceRange, \"/current/trace/loaded\"],\n        (range, loaded) => (loaded ? range : null)\n      ),\n\n      /**\n       * controller.current.location.source\n       */\n      source: createLeaf(\n        [sourcemapping.current.source, \"/current/trace/loaded\"],\n        (source, loaded) => (loaded ? source : null)\n      ),\n\n      /**\n       * controller.current.location.node\n       */\n      node: createLeaf(\n        [sourcemapping.current.node, \"/current/trace/loaded\"],\n        (node, loaded) => (loaded ? node : null)\n      ),\n\n      /**\n       * controller.current.location.astRef\n       */\n      astRef: createLeaf([data.current.astRef], identity),\n\n      /**\n       * controller.current.location.isMultiline\n       */\n      isMultiline: createLeaf(\n        [sourcemapping.current.isMultiline, \"/current/trace/loaded\"],\n        (raw, loaded) => (loaded ? raw : false)\n      )\n    },\n\n    /**\n     * controller.current.trace\n     */\n    trace: {\n      /**\n       * controller.current.trace.finished\n       */\n      finished: createLeaf([trace.finished], identity),\n\n      /**\n       * controller.current.trace.loaded\n       */\n      loaded: createLeaf([trace.loaded], identity)\n    }\n  },\n\n  /**\n   * controller.breakpoints (namespace)\n   */\n  breakpoints: {\n    /**\n     * controller.breakpoints (selector)\n     */\n    _: createLeaf([\"/state\"], state => state.breakpoints),\n\n    /**\n     * controller.breakpoints.resolver (selector)\n     * this selector returns a function that adjusts a given line-based\n     * breakpoint (on node-based breakpoints it simply returns the input) by\n     * repeatedly moving it down a line until it lands on a line where there's\n     * actually somewhere to break.  if no such line exists beyond that point, it\n     * returns null instead.\n     */\n    resolver: createLeaf(\n      [sourcemapping.views.sources, sourcemapping.views.overlapFunctions],\n      (sources, functions) => breakpoint => {\n        let adjustedBreakpoint;\n        if (breakpoint.node === undefined) {\n          let line = breakpoint.line;\n          if (line < 0) {\n            line = 0; //prevents hang if user enters large negative number\n          }\n          const { sourceId } = breakpoint;\n          debug(\"breakpoint: %O\", breakpoint);\n          debug(\"sources: %o\", sources);\n          const { source, ast } = sources[sourceId];\n          if (!ast) {\n            //if no ast, don't attempt to adjust\n            return breakpoint;\n          }\n          const findOverlappingRange = functions[sourceId];\n          const lineLengths = source.split(\"\\n\").map(line => line.length);\n          //why does neither JS nor lodash have a scan function like Haskell??\n          //guess we'll have to do our scan manually\n          let lineStarts = [0];\n          for (let length of lineLengths) {\n            lineStarts.push(lineStarts[lineStarts.length - 1] + length + 1);\n            //+1 for the /n itself\n          }\n          debug(\n            \"line: %s\",\n            source.slice(lineStarts[line], lineStarts[line] + lineLengths[line])\n          );\n          while (\n            line < lineLengths.length &&\n            !anyNonSkippedInRange(\n              findOverlappingRange,\n              ast,\n              lineStarts[line],\n              lineLengths[line]\n            )\n          ) {\n            debug(\"incrementing\");\n            line++;\n          }\n          if (line >= lineLengths.length) {\n            adjustedBreakpoint = null;\n          } else {\n            adjustedBreakpoint = { ...breakpoint, line };\n          }\n        } else {\n          debug(\"node-based breakpoint\");\n          adjustedBreakpoint = breakpoint;\n        }\n        return adjustedBreakpoint;\n      }\n    )\n  },\n\n  /**\n   * controller.finished\n   * deprecated alias for controller.current.trace.finished\n   */\n  finished: createLeaf([\"/current/trace/finished\"], finished => finished),\n\n  /**\n   * controller.isStepping\n   */\n  isStepping: createLeaf([\"./state\"], state => state.isStepping),\n\n  /**\n   * controller.stepIntoInternalSources\n   */\n  stepIntoInternalSources: createLeaf(\n    [\"./state\"],\n    state => state.stepIntoInternalSources\n  )\n});\n\nexport default controller;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:sagas\");\n\nimport { put, call, race, take, select } from \"redux-saga/effects\";\n\nimport { prefixName, isDeliberatelySkippedNodeType } from \"lib/helpers\";\n\nimport * as trace from \"lib/trace/sagas\";\nimport * as data from \"lib/data/sagas\";\nimport * as txlog from \"lib/txlog/sagas\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as sourcemapping from \"lib/sourcemapping/sagas\";\nimport * as stacktrace from \"lib/stacktrace/sagas\";\n\nimport * as actions from \"../actions\";\n\nimport controller from \"../selectors\";\n\nconst STEP_SAGAS = {\n  [actions.ADVANCE]: advance,\n  [actions.STEP_NEXT]: stepNext,\n  [actions.STEP_OVER]: stepOver,\n  [actions.STEP_INTO]: stepInto,\n  [actions.STEP_OUT]: stepOut,\n  [actions.CONTINUE]: continueUntilBreakpoint,\n  [actions.RUN_TO_END]: runToEnd\n};\n\nexport function* saga() {\n  while (true) {\n    debug(\"waiting for control action\");\n    let action = yield take(Object.keys(STEP_SAGAS));\n    if (!(yield select(controller.current.trace.loaded))) {\n      continue; //while no trace is loaded, step actions are ignored\n    }\n    debug(\"got control action\");\n    let saga = STEP_SAGAS[action.type];\n\n    yield put(actions.startStepping());\n    yield race({\n      exec: call(saga, action), //not all will use this\n      interrupt: take(actions.INTERRUPT)\n    });\n    yield put(actions.doneStepping());\n  }\n}\n\nexport default prefixName(\"controller\", saga);\n\n/**\n * Advance the state by the given number of instructions (but not past the end)\n * (if no count given, advance 1)\n */\nfunction* advance(action) {\n  let count =\n    action !== undefined && action.count !== undefined ? action.count : 1;\n  //default is, as mentioned, to advance 1\n  for (\n    let i = 0;\n    i < count && !(yield select(controller.current.trace.finished));\n    i++\n  ) {\n    yield* trace.advance();\n  }\n}\n\n/**\n * stepNext - step to the next logical code segment\n *\n * Note: It might take multiple instructions to express the same section of code.\n * \"Stepping\", then, is stepping to the next logical item, not stepping to the next\n * instruction. See advance() if you'd like to advance by one instruction.\n *\n * Note that if you are not in an internal source, this function will not stop in one\n * (unless it hits the end of the trace); you will need to use advance() to get into\n * one.  However, if you are already in an internal source, this function will not\n * automatically step all the way out of it.\n */\nfunction* stepNext() {\n  const starting = yield select(controller.current.location);\n  const allowInternal = yield select(controller.stepIntoInternalSources);\n\n  let upcoming, finished;\n\n  do {\n    // advance at least once step\n    yield* advance();\n\n    // and check the next source range\n    upcoming = yield select(controller.current.location);\n\n    finished = yield select(controller.current.trace.finished);\n\n    // if the next step's source range is still the same, keep going\n  } while (\n    !finished &&\n    (!upcoming ||\n      //don't stop on an internal source unless allowInternal is on or\n      //we started in an internal source\n      (!allowInternal &&\n        upcoming.source.internal &&\n        !starting.source.internal) ||\n      upcoming.sourceRange.length === 0 ||\n      upcoming.source.id === undefined ||\n      (upcoming.node && isDeliberatelySkippedNodeType(upcoming.node)) ||\n      (upcoming.sourceRange.start === starting.sourceRange.start &&\n        upcoming.sourceRange.length === starting.sourceRange.length &&\n        upcoming.source.id === starting.source.id))\n  );\n}\n\n/**\n * stepInto - step into the current function\n *\n * Conceptually this is easy, but from a programming standpoint it's hard.\n * Code like `getBalance(msg.sender)` might be highlighted, but there could\n * be a number of different intermediate steps (like evaluating `msg.sender`)\n * before `getBalance` is stepped into. This function will step into the first\n * function available (where instruction.jump == \"i\"), ignoring any intermediate\n * steps that fall within the same code range. If there's a step encountered\n * that exists outside of the range, then stepInto will only execute until that\n * step.\n */\nfunction* stepInto() {\n  const startingDepth = yield select(controller.current.functionDepth);\n  const startingLocation = yield select(controller.current.location);\n  debug(\"startingDepth: %d\", startingDepth);\n  debug(\"starting source range: %O\", (startingLocation || {}).sourceRange);\n  let currentDepth;\n  let currentLocation;\n  let finished;\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    currentLocation = yield select(controller.current.location);\n    finished = yield select(controller.current.trace.finished);\n    debug(\"currentDepth: %d\", currentDepth);\n    debug(\"current source range: %O\", (currentLocation || {}).sourceRange);\n    debug(\"finished: %o\", finished);\n  } while (\n    //we aren't finished,\n    !finished &&\n    // the function stack has not increased,\n    currentDepth <= startingDepth &&\n    // we haven't changed files,\n    currentLocation.source.id === startingLocation.source.id &&\n    //and we haven't changed lines\n    currentLocation.sourceRange.lines.start.line ===\n      startingLocation.sourceRange.lines.start.line\n  );\n}\n\n/**\n * Step out of the current function\n *\n * This will run until the debugger encounters a decrease in function depth\n * (or finishes).\n */\nfunction* stepOut() {\n  const startingDepth = yield select(controller.current.functionDepth);\n  let currentDepth;\n  let finished;\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    finished = yield select(controller.current.trace.finished);\n  } while (!finished && currentDepth >= startingDepth);\n}\n\n/**\n * stepOver - step over the current line\n *\n * Step over the current line. This will step to the next instruction that\n * exists on a different line of code within the same function depth (or lower).\n * (However, if you are on the definition of a function, it will step over that\n * function entirely, returning you to the next function depth.)\n */\nfunction* stepOver() {\n  const startingDepth = yield select(controller.current.functionDepth);\n  const startingLocation = yield select(controller.current.location);\n  const startingNode = yield select(controller.current.location.node);\n  let currentDepth;\n  let currentLocation;\n  let finished;\n\n  //special case: what if you're on a function definition?\n  if (\n    startingNode &&\n    ((startingNode.nodeType === \"FunctionDefinition\" &&\n      //note that we exclude base constructors here, because we don't have a\n      //good way to go to the end of a base constructor; we'll just perform\n      //an ordinary stepOver in that case\n      !(yield select(controller.current.onBaseConstructorDefinition))) ||\n      //for Yul functions, we use a special selector to make sure we're seeing\n      //the function definition as we enter it rather than as it's defined\n      (yield select(controller.current.onYulFunctionDefinitionWhileEntering)))\n  ) {\n    yield* stepOut();\n    return;\n  }\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    currentLocation = yield select(controller.current.location);\n    finished = yield select(controller.current.trace.finished);\n  } while (\n    // keep stepping provided:\n    //\n    // we haven't finished\n    !finished &&\n    // we haven't jumped out\n    currentDepth >= startingDepth &&\n    // either: function depth is greater than starting (ignore function calls)\n    // or, if we're at the same depth, keep stepping until we're on a new\n    // line (which may be in a new file)\n    (currentDepth > startingDepth ||\n      (currentLocation.source.id === startingLocation.source.id &&\n        currentLocation.sourceRange.lines.start.line ===\n          startingLocation.sourceRange.lines.start.line))\n  );\n}\n\n/**\n * runToEnd - run the debugger till the end\n */\nfunction* runToEnd() {\n  let finished;\n\n  do {\n    yield* advance();\n    finished = yield select(controller.current.trace.finished);\n  } while (!finished);\n}\n\n/**\n * continueUntilBreakpoint - step through execution until a breakpoint\n */\nfunction* continueUntilBreakpoint(action) {\n  //if breakpoints was not specified, use the stored list from the state.\n  //if it was, override that with the specified list.\n  //note that explicitly specifying an empty list will advance to the end.\n  let breakpoints =\n    action !== undefined && action.breakpoints !== undefined\n      ? action.breakpoints\n      : yield select(controller.breakpoints);\n\n  let breakpointHit = false;\n\n  let currentLocation = yield select(controller.current.location);\n  let currentSourceId = currentLocation.source.id;\n  let currentLine = currentLocation.sourceRange.lines.start.line;\n  let currentStart = currentLocation.sourceRange.start;\n  let currentLength = currentLocation.sourceRange.start;\n  //note that if allow internal is on, we don't turn on the special treatment\n  //of user sources even if we started in one\n  const startedInUserSource =\n    !(yield select(controller.stepIntoInternalSources)) &&\n    currentLocation.source.id !== undefined &&\n    !currentLocation.source.internal;\n  //the following are set regardless, but only used if startedInUserSource\n  let lastUserSourceId = currentSourceId;\n  let lastUserLine = currentLine;\n  let lastUserStart = currentStart;\n  let lastUserLength = currentLength;\n\n  do {\n    yield* advance(); //note: this avoids using stepNext in order to\n    //allow breakpoints in internal sources to work properly\n\n    //note these three have not been updated yet; they'll be updated a\n    //few lines down.  but at this point these are still the previous\n    //values.\n    let previousLine = currentLine;\n    let previousStart = currentStart;\n    let previousLength = currentLength;\n    let previousSourceId = currentSourceId;\n    if (!currentLocation.source.internal) {\n      lastUserSourceId = currentSourceId;\n      lastUserLine = currentLine;\n      lastUserStart = currentStart;\n      lastUserLength = currentLength;\n    }\n\n    currentLocation = yield select(controller.current.location);\n    let finished = yield select(controller.current.trace.finished);\n    if (finished) {\n      break; //can break immediately if finished\n    }\n\n    currentSourceId = currentLocation.source.id;\n    if (currentSourceId === undefined) {\n      continue; //never stop on an unmapped instruction\n    }\n    currentLine = currentLocation.sourceRange.lines.start.line;\n    currentStart = currentLocation.sourceRange.start;\n    currentLength = currentLocation.sourceRange.length;\n\n    breakpointHit =\n      breakpoints.filter(({ sourceId, line, start, length }) => {\n        if (start !== undefined && length !== undefined) {\n          //node-based (well, source-range-based) breakpoint\n          return (\n            sourceId === currentSourceId &&\n            start === currentStart &&\n            length === currentLength &&\n            (currentSourceId !== previousSourceId ||\n              currentStart !== previousStart ||\n              currentLength !== previousLength) &&\n            //if we started in a user source (& allow internal is off),\n            //we need to make sure we've moved from a user-source POV\n            (!startedInUserSource ||\n              currentSourceId !== lastUserSourceId ||\n              currentStart !== lastUserStart ||\n              currentLength !== lastUserLength)\n          );\n        }\n        //otherwise, we have a line-style breakpoint; we want to stop at the\n        //*first* point on the line\n        return (\n          sourceId === currentSourceId &&\n          line === currentLine &&\n          (currentSourceId !== previousSourceId ||\n            currentLine !== previousLine) &&\n          //again, if started in a user source w/ allow internal off,\n          //need to make sure we've moved from a *user*-source POV\n          (!startedInUserSource ||\n            currentSourceId !== lastUserSourceId ||\n            currentLine !== lastUserLine)\n        );\n      }).length > 0;\n  } while (!breakpointHit);\n}\n\n/**\n * reset -- reset the state of the debugger\n * (we'll just reset all submodules regardless of which are in use)\n */\nexport function* reset() {\n  yield* data.reset();\n  yield* evm.reset();\n  yield* sourcemapping.reset();\n  yield* trace.reset();\n  yield* stacktrace.reset();\n  yield* txlog.reset();\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:ast:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport sourcemapping from \"lib/sourcemapping/selectors\";\n\n/**\n * ast\n */\nconst ast = createSelectorTree({\n  /**\n   * ast.views\n   */\n  views: {\n    /**\n     * ast.views.sources\n     * let's just flatten this into an array\n     */\n    sources: createLeaf([sourcemapping.views.sources], sources =>\n      Object.values(sources)\n    )\n  }\n});\n\nexport default ast;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:ast:sagas\");\n\nimport { all, call, select } from \"redux-saga/effects\";\n\nimport * as data from \"lib/data/sagas\";\n\nimport ast from \"../selectors\";\n\nimport jsonpointer from \"json-pointer\";\n\nfunction* walk(sourceId, sourceIndex, node, pointer = \"\", parentId = null) {\n  debug(\"walking %s %o %o\", sourceId, pointer, node);\n\n  yield* handleEnter(sourceId, sourceIndex, node, pointer, parentId);\n\n  if (Array.isArray(node)) {\n    for (let [i, child] of node.entries()) {\n      yield* walk(sourceId, sourceIndex, child, `${pointer}/${i}`, parentId);\n    }\n  } else if (node && node.nodeType && node.nodeType.startsWith(\"Yul\")) {\n    //defer to yul handler!\n    yield* handleYul(sourceId, sourceIndex, node, pointer, parentId);\n  } else if (node instanceof Object) {\n    for (let [key, child] of Object.entries(node)) {\n      yield* walk(sourceId, sourceIndex, child, `${pointer}/${key}`, node.id);\n    }\n  }\n\n  yield* handleExit(sourceId, sourceIndex, node, pointer);\n}\n\nfunction* handleEnter(sourceId, sourceIndex, node, pointer, parentId) {\n  debug(\"entering %s %s\", sourceId, pointer);\n\n  if (!(node instanceof Object)) {\n    return;\n  }\n\n  if (node.id !== undefined) {\n    debug(\"%s recording scope %s\", pointer, node.id);\n    yield* data.scope(node.id, pointer, parentId, sourceIndex, sourceId);\n  }\n\n  switch (node.nodeType) {\n    case \"VariableDeclaration\":\n      debug(\"%s recording variable %o\", pointer, node);\n      yield* data.declare(node, sourceId);\n      break;\n    case \"ContractDefinition\":\n    case \"StructDefinition\":\n    case \"EnumDefinition\":\n    case \"UserDefinedValueTypeDefinition\":\n      debug(\"%s recording type %o\", pointer, node);\n      yield* data.defineType(node, sourceId);\n      break;\n    case \"EventDefinition\":\n    case \"ErrorDefinition\":\n      debug(\"%s recording type %o\", pointer, node);\n      yield* data.defineTaggedOutput(node, sourceId);\n      break;\n  }\n}\n\nfunction* handleExit(sourceId, sourceIndex, node, pointer) {\n  debug(\"exiting %s %s\", sourceId, pointer);\n\n  // no-op right now\n}\n\nexport function* visitAll() {\n  const sources = yield select(ast.views.sources);\n\n  yield all(\n    sources\n      .filter(({ ast }) => ast)\n      .map(({ ast, id, index }) => call(walk, id, index, ast))\n  );\n\n  debug(\"done visiting\");\n}\n\nfunction* handleYul(sourceId, sourceIndex, node, pointer, parentId) {\n  yield* yulWalk(sourceId, sourceIndex, node, pointer, node, pointer, parentId);\n}\n\nfunction* yulWalk(\n  sourceId,\n  sourceIndex,\n  node,\n  pointer,\n  base,\n  basePointer,\n  parentId = undefined\n) {\n  yield* handleYulEnter(\n    sourceId,\n    sourceIndex,\n    node,\n    pointer,\n    base,\n    basePointer,\n    parentId\n  );\n\n  if (Array.isArray(node)) {\n    for (let [i, child] of node.entries()) {\n      yield* yulWalk(\n        sourceId,\n        sourceIndex,\n        child,\n        `${pointer}/${i}`,\n        base,\n        basePointer\n      ); //no parent ID for subnodes\n    }\n  } else if (node instanceof Object) {\n    for (let [key, child] of Object.entries(node)) {\n      yield* yulWalk(\n        sourceId,\n        sourceIndex,\n        child,\n        `${pointer}/${key}`,\n        base,\n        basePointer\n      ); //no parent ID for subnodes\n    }\n  }\n\n  yield* handleYulExit(\n    sourceId,\n    sourceIndex,\n    node,\n    pointer,\n    base,\n    basePointer,\n    parentId\n  );\n}\n\nfunction* handleYulExit(\n  sourceId,\n  sourceIndex,\n  node,\n  pointer,\n  base,\n  basePointer,\n  _parentId = undefined\n) {\n  debug(\"exiting %s %s\", sourceId, pointer);\n\n  // no-op right now\n}\n\nfunction* handleYulEnter(\n  sourceId,\n  sourceIndex,\n  node,\n  pointer,\n  base,\n  basePointer,\n  parentId = undefined\n) {\n  debug(\"entering %s %s\", sourceId, pointer);\n\n  if (!node) {\n    return;\n  }\n\n  if (node.src !== undefined) {\n    debug(\"scoping!\");\n    yield* data.yulScope(pointer, sourceIndex, sourceId, parentId);\n  }\n\n  if (node.nodeType === \"YulTypedName\") {\n    let scopePointer = findYulScopePointer(node, pointer, base, basePointer);\n    yield* data.yulDeclare(node, pointer, scopePointer, sourceIndex, sourceId);\n  }\n}\n\nfunction findYulScopePointer(node, pointer, base, basePointer) {\n  //walk upward until we find a YulBlock or YulFunctionDefinition,\n  //with a special case for YulForLoop\n  debug(\"pointer: %s\", pointer);\n  debug(\"basePointer: %s\", basePointer);\n  let relativePointer = pointer.slice(basePointer.length);\n  debug(\"relativePointer: %s\", relativePointer);\n  let relativeParentPointer = relativePointer.replace(/\\/[^/]*$/, \"\"); //chop off last element\n  let parentPointer = basePointer + relativeParentPointer; //make it absolute again\n  debug(\"parentPointer: %s\", parentPointer);\n  let parent = jsonpointer.get(base, relativeParentPointer);\n  //NOTE: if node === base, then we'll just get parent = node,\n  //but that's fine, since we necessarily have base.nodeType === \"YulBlock\"\n  //(and the real parent of base is certainly not a for loop!)\n  if (node.nodeType === \"YulBlock\") {\n    if (parent.nodeType === \"YulForLoop\") {\n      if (pointer === `${parentPointer}/pre`) {\n        //variables declared in the pre block of a for loop\n        //are visible across the entire for loop\n        return parentPointer;\n      } else {\n        return pointer;\n      }\n    } else {\n      return pointer;\n    }\n  } else if (node.nodeType === \"YulFunctionDefinition\") {\n    return pointer;\n  } else {\n    return findYulScopePointer(parent, parentPointer, base, basePointer);\n  }\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:sagas\");\n\nimport { call, all, fork, take, put, race, select } from \"redux-saga/effects\";\n\nimport { prefixName } from \"lib/helpers\";\n\nimport * as ast from \"lib/ast/sagas\";\nimport * as controller from \"lib/controller/sagas\";\nimport * as sourcemapping from \"lib/sourcemapping/sagas\";\nimport * as stacktrace from \"lib/stacktrace/sagas\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as trace from \"lib/trace/sagas\";\nimport * as data from \"lib/data/sagas\";\nimport * as txlog from \"lib/txlog/sagas\";\nimport * as web3 from \"lib/web3/sagas\";\n\nimport * as actions from \"../actions\";\n\nimport session from \"../selectors\";\n\nconst LOAD_SAGAS = {\n  [actions.LOAD_TRANSACTION]: load,\n  //will also add reconstruct action/saga once it exists\n  //the following ones don't really relate to loading, but, oh well\n  [actions.ADD_COMPILATIONS]: addCompilations,\n  [actions.START_FULL_MODE]: startFullMode\n};\n\nfunction* listenerSaga() {\n  while (true) {\n    let action = yield take(Object.keys(LOAD_SAGAS));\n    let saga = LOAD_SAGAS[action.type];\n\n    yield put(actions.wait());\n    yield race({\n      exec: call(saga, action), //not all will use this\n      interrupt: take(actions.INTERRUPT)\n    });\n    yield put(actions.ready());\n  }\n}\n\nexport function* saga(moduleOptions) {\n  debug(\"starting listeners\");\n  yield* forkListeners(moduleOptions);\n\n  // receiving & saving contracts into state\n  debug(\"waiting for contract information\");\n  const { contexts, sources, contracts } = yield take(actions.RECORD_CONTRACTS);\n\n  debug(\"recording contract binaries\");\n  yield* recordContexts(contexts);\n\n  debug(\"recording contract sources\");\n  yield* recordSources(sources);\n\n  //note: even this goes in data, we'll do it even in light\n  //mode for simplicity\n  debug(\"recording other contract info\");\n  yield* recordContracts(contracts);\n\n  debug(\"waiting for start\");\n  // wait for start signal\n  let { txHash, provider } = yield take(actions.START);\n  debug(\"starting\");\n\n  if (!moduleOptions.lightMode) {\n    debug(\"visiting ASTs\");\n    // visit asts\n    yield* ast.visitAll();\n\n    //save allocation table\n    debug(\"saving allocation table\");\n    yield* data.recordAllocations();\n\n    //note: we don't need to explicitly set full mode, it's the default\n  } else {\n    debug(\"setting light mode\");\n    yield put(actions.setLightMode());\n  }\n\n  //initialize web3 adapter\n  debug(\"initializing adapter\");\n  yield* web3.init(provider);\n\n  //process transaction (if there is one)\n  //(note: this part may also set the error state)\n  if (txHash !== undefined) {\n    yield* processTransaction(txHash, moduleOptions);\n  }\n\n  debug(\"readying\");\n  // signal that commands can begin\n  yield* ready();\n}\n\n//please only use in light mode!\nfunction* addCompilations({ sources, contexts, contracts }) {\n  debug(\"recording contract binaries\");\n  yield* recordContexts(contexts);\n\n  debug(\"recording contract sources\");\n  yield* recordSources(sources);\n\n  //see comment above about this\n  debug(\"recording other contract info\");\n  yield* recordContracts(contracts);\n\n  debug(\"refreshing instances\");\n  yield* evm.refreshInstances();\n}\n\nfunction* startFullMode() {\n  debug(\"session: %O\", session);\n  const lightMode = yield select(session.status.lightMode);\n  if (!lightMode) {\n    //better not start this twice!\n    return;\n  }\n  debug(\"turning on data & txlog listeners\");\n  const listenersToActivate = [data.saga, txlog.saga];\n  for (const listener of listenersToActivate) {\n    yield fork(listener);\n  }\n\n  debug(\"visiting ASTs\");\n  // visit asts\n  yield* ast.visitAll();\n\n  //save allocation table\n  debug(\"saving allocation table\");\n  yield* data.recordAllocations();\n\n  yield* trace.addSubmoduleToCount(listenersToActivate.length);\n\n  if (yield select(session.status.loaded)) {\n    //begin any full-mode modules that need beginning\n    yield* txlog.begin();\n    //we don't need to perform setup regarding storage visibility,\n    //as that will have been already been done on tx load\n  }\n\n  yield put(actions.setFullMode());\n}\n\nexport function* processTransaction(txHash, loadOptions) {\n  // process transaction\n  debug(\"fetching transaction info\");\n  let err = yield* fetchTx(txHash, loadOptions);\n  if (err) {\n    debug(\"error %o\", err);\n    yield* error(err);\n  }\n}\n\nexport default prefixName(\"session\", saga);\n\nfunction* forkListeners(moduleOptions) {\n  yield fork(listenerSaga); //session listener; this one is separate, sorry\n  //(I didn't want to mess w/ the existing structure of defaults)\n  let mainApps = [evm, sourcemapping, stacktrace];\n  if (!moduleOptions.lightMode) {\n    mainApps.push(data);\n    mainApps.push(txlog);\n  }\n  let otherApps = [controller, web3];\n  const submoduleCount = mainApps.length;\n  const apps = mainApps.concat(otherApps);\n  yield* trace.setSubmoduleCount(submoduleCount);\n  return yield all(apps.map(app => fork(app.saga)));\n}\n\nfunction* fetchTx(txHash, loadOptions) {\n  let result = yield* web3.inspectTransaction(txHash);\n  debug(\"result %o\", result);\n\n  if (result.error) {\n    return result.error;\n  }\n\n  //get addresses created/called during transaction\n  debug(\"processing trace for addresses\");\n  let { calls, creations, selfdestructs } = yield* trace.processTrace(\n    result.trace\n  );\n  //add in the address of the call itself (if a call)\n  if (result.address && !calls.includes(result.address)) {\n    calls.push(result.address);\n  }\n\n  //if a create, only add in address if it was successful\n  if (result.binary && result.status && !(result.storageAddress in creations)) {\n    creations[result.storageAddress] = result.binary;\n  }\n\n  let blockNumber = result.block.number.toString(); //a BN is not accepted\n  let addresses = [...calls, ...selfdestructs, ...Object.keys(creations)];\n  let nonCallStartIndex = calls.length;\n  debug(\"obtaining binaries\");\n  let binaries = yield* web3.obtainBinaries(addresses, blockNumber);\n\n  debug(\"recording instances\");\n  yield all(\n    addresses.map((address, index) =>\n      call(\n        recordInstance,\n        address,\n        binaries[index],\n        index >= nonCallStartIndex,\n        creations[address] //may be undefined\n      )\n    )\n  );\n\n  debug(\"sending initial call\");\n  yield* evm.begin(result); //note: this must occur *before* the other ones!\n  yield* sourcemapping.begin();\n  yield* stacktrace.begin();\n  if (!(yield select(session.status.lightMode))) {\n    //full-mode-only modules\n    yield* txlog.begin();\n  }\n  try {\n    //finally, enable storage lookup.  We do this even in light mode, since\n    //full mode might be set later, and we have to do it on loading the tx.\n    //Ideally this would be done earlier, but in the current setup, it can't\n    //occur until after evm.begin(), so it's here.\n    yield* evm.setStorageLookup(loadOptions.storageLookup);\n  } catch (error) {\n    //remember, this function *returns* errors rather than throwing them!\n    return error;\n  }\n}\n\nfunction* recordContexts(contexts) {\n  for (const context of Object.values(contexts)) {\n    yield* evm.addContext(context);\n  }\n}\n\nfunction* recordSources(sources) {\n  yield* sourcemapping.addSources(sources);\n}\n\nfunction* recordContracts(contracts) {\n  yield* data.addContracts(contracts);\n}\n\n//creationBinary can be omitted; should only be used for creations\nfunction* recordInstance(\n  address,\n  binary,\n  affectedInstanceOnly,\n  creationBinary\n) {\n  yield* evm.addAffectedInstance(address, binary, creationBinary);\n  if (!affectedInstanceOnly) {\n    //add it as a real codex instance\n    yield* evm.addInstance(address, binary);\n  }\n}\n\nfunction* ready() {\n  yield put(actions.ready());\n}\n\nfunction* error(err) {\n  yield put(actions.error(err));\n}\n\n//we'll just unload all modules regardless of which ones are currently present...\nexport function* unload() {\n  debug(\"unloading\");\n  yield* data.reset();\n  yield* sourcemapping.unload();\n  yield* evm.unload();\n  yield* trace.unload();\n  yield* stacktrace.unload();\n  yield* txlog.unload();\n  yield put(actions.unloadTransaction());\n}\n\n//note that load takes an action as its argument, which is why it's separate\n//from processTransaction\nfunction* load({ txHash, options }) {\n  yield* processTransaction(txHash, options);\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nimport * as Codec from \"@truffle/codec\";\nimport { makeAssignment, makePath } from \"lib/helpers\";\n\nconst DEFAULT_SCOPES = {\n  bySourceId: {}\n};\n\nfunction scopes(state = DEFAULT_SCOPES, action) {\n  switch (action.type) {\n    case actions.SCOPE: {\n      const { sourceId, id, sourceIndex, parentId, pointer } = action;\n      const astRef = id !== undefined ? id : makePath(sourceIndex, pointer);\n      //astRef is used throughout the data saga.\n      //it identifies an AST node within a given compilation either by:\n      //1. its ast ID, if it has one, or\n      //2. a combination of its source index and its JSON pointer if not\n\n      return {\n        bySourceId: {\n          ...state.bySourceId,\n          [sourceId]: {\n            byAstRef: {\n              ...(state.bySourceId[sourceId] || {}).byAstRef,\n              [astRef]: {\n                ...(state.bySourceId[sourceId] || { byAstRef: {} }).byAstRef[\n                  astRef\n                ],\n                id,\n                parentId,\n                sourceIndex,\n                pointer,\n                sourceId\n              }\n            }\n          }\n        }\n      };\n    }\n\n    case actions.DECLARE: {\n      let { sourceId, name, astRef, scopeAstRef } = action;\n\n      //note: we can assume the scope already exists!\n      let scope = state.bySourceId[sourceId].byAstRef[scopeAstRef];\n      let variables = scope.variables || [];\n\n      return {\n        bySourceId: {\n          ...state.bySourceId,\n          [sourceId]: {\n            byAstRef: {\n              ...state.bySourceId[sourceId].byAstRef,\n              [scopeAstRef]: {\n                ...scope,\n                variables: [...variables, { name, astRef, sourceId }]\n              }\n            }\n          }\n        }\n      };\n    }\n\n    default:\n      return state;\n  }\n}\n\n//yes, this is just a flat array as that's what's convenient\nfunction userDefinedTypes(state = [], action) {\n  switch (action.type) {\n    case actions.DEFINE_TYPE:\n      debug(\"action: %O\", action);\n      return [...state, { id: action.node.id, sourceId: action.sourceId }];\n    default:\n      return state;\n  }\n}\n\n//just going to treat this like userDefinedTypes\nfunction taggedOutputs(state = [], action) {\n  switch (action.type) {\n    case actions.DEFINE_TAGGED_OUTPUT:\n      return [...state, { id: action.node.id, sourceId: action.sourceId }];\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_ALLOCATIONS = {\n  storage: {},\n  memory: {},\n  abi: {},\n  calldata: {},\n  returndata: {},\n  event: {},\n  state: {}\n};\n\nfunction allocations(state = DEFAULT_ALLOCATIONS, action) {\n  if (action.type === actions.ALLOCATE) {\n    debug(\"action: %O\", action);\n    return {\n      storage: action.storage,\n      memory: action.memory,\n      abi: action.abi,\n      calldata: action.calldata,\n      returndata: action.returndata,\n      event: action.event,\n      state: action.state\n    };\n  } else {\n    return state; //not to be confused with action.state!\n  }\n}\n\nconst DEFAULT_CONTRACTS = {\n  byCompilationId: {}\n};\n\nfunction contracts(state = DEFAULT_CONTRACTS, action) {\n  if (action.type === actions.ADD_CONTRACTS) {\n    //NOTE: this code assumes that we are only ever adding compilations\n    //wholesale, and never adding to existing ones!\n    return {\n      byCompilationId: {\n        ...state.byCompilationId,\n        ...Object.assign(\n          {},\n          ...Object.entries(action.contracts).map(\n            ([compilationId, compilation]) => ({\n              [compilationId]: {\n                byAstId: compilation\n              }\n            })\n          )\n        )\n      }\n    };\n  } else {\n    return state;\n  }\n}\n\nconst info = combineReducers({\n  scopes,\n  contracts,\n  userDefinedTypes,\n  taggedOutputs,\n  allocations\n});\n\nconst GLOBAL_ASSIGNMENTS = [\n  [{ builtin: \"msg\" }, { location: \"special\", special: \"msg\" }],\n  [{ builtin: \"tx\" }, { location: \"special\", special: \"tx\" }],\n  [{ builtin: \"block\" }, { location: \"special\", special: \"block\" }],\n  [{ builtin: \"this\" }, { location: \"special\", special: \"this\" }],\n  [{ builtin: \"now\" }, { location: \"special\", special: \"timestamp\" }] //we don't have an alias \"now\"\n].map(([idObj, ref]) => makeAssignment(idObj, ref));\n\nconst DEFAULT_ASSIGNMENTS = {\n  byId: Object.assign(\n    {}, //we start out with all globals assigned\n    ...GLOBAL_ASSIGNMENTS.map(assignment => ({ [assignment.id]: assignment }))\n  )\n};\n\nfunction assignments(state = DEFAULT_ASSIGNMENTS, action) {\n  switch (action.type) {\n    case actions.ASSIGN:\n    case actions.MAP_PATH_AND_ASSIGN:\n      debug(\"action.type %O\", action.type);\n      debug(\"action.assignments %O\", action.assignments);\n      return {\n        byId: {\n          ...state.byId,\n          ...action.assignments\n        }\n      };\n\n    case actions.RESET:\n      return DEFAULT_ASSIGNMENTS;\n\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_PATHS = {\n  byAddress: {}\n};\n\n//WARNING: do *not* rely on mappedPaths to keep track of paths that do not\n//involve mapping keys!  Yes, many will get mapped, but there is no guarantee.\n//Only when mapping keys are involved does it necessarily work reliably --\n//which is fine, as that's all we need it for.\nfunction mappedPaths(state = DEFAULT_PATHS, action) {\n  switch (action.type) {\n    case actions.MAP_PATH_AND_ASSIGN:\n      let { address, slot, typeIdentifier, parentType } = action;\n      //how this case works: first, we find the spot in our table (based on\n      //address, type identifier, and slot address) where the new entry should\n      //be added; if needed we set up all the objects needed along the way.  If\n      //there's already something there, we do nothing.  If there's nothing\n      //there, we record our given slot in that spot in that table -- however,\n      //we alter it in one key way.  Before entry, we check if the slot's\n      //*parent* has a spot in the table, based on address (same for both child\n      //and parent), parentType, and the parent's slot address (which can be\n      //found as the slotAddress of the slot's path object, if it exists -- if\n      //it doesn't then we conclude that no the parent does not have a spot in\n      //the table).  If the parent has a slot in the table already, then we\n      //alter the child slot by replacing its path with the parent slot.  This\n      //will keep the slotAddress the same, but since the versions kept in the\n      //table here are supposed to preserve path information, we'll be\n      //replacing a fairly bare-bones Slot object with one with a full path.\n\n      //we do NOT want to distinguish between types with and without \"_ptr\" on\n      //the end here! (or _slice)\n      debug(\"typeIdentifier %s\", typeIdentifier);\n      typeIdentifier = Codec.Ast.Utils.regularizeTypeIdentifier(typeIdentifier);\n      parentType = Codec.Ast.Utils.regularizeTypeIdentifier(parentType);\n\n      debug(\"slot %o\", slot);\n      let hexSlotAddress = Codec.Conversion.toHexString(\n        Codec.Storage.Utils.slotAddress(slot),\n        Codec.Evm.Utils.WORD_SIZE\n      );\n      let parentAddress = slot.path\n        ? Codec.Conversion.toHexString(\n            Codec.Storage.Utils.slotAddress(slot.path),\n            Codec.Evm.Utils.WORD_SIZE\n          )\n        : undefined;\n\n      //this is going to be messy and procedural, sorry.  but let's start with\n      //the easy stuff: create the new address if needed, clone if not\n      let newState = {\n        ...state,\n        byAddress: {\n          ...state.byAddress,\n          [address]: {\n            byType: {\n              ...(state.byAddress[address] || { byType: {} }).byType\n            }\n          }\n        }\n      };\n\n      //now, let's add in the new type, if needed\n      newState.byAddress[address].byType = {\n        ...newState.byAddress[address].byType,\n        [typeIdentifier]: {\n          bySlotAddress: {\n            ...(\n              newState.byAddress[address].byType[typeIdentifier] || {\n                bySlotAddress: {}\n              }\n            ).bySlotAddress\n          }\n        }\n      };\n\n      let oldSlot =\n        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[\n          hexSlotAddress\n        ];\n      //yes, this looks strange, but we haven't changed it yet except to\n      //clone or create empty (and we don't want undefined!)\n      //now: is there something already there or no?  if no, we must add\n      if (oldSlot === undefined) {\n        let newSlot;\n        debug(\"parentAddress %o\", parentAddress);\n        if (\n          parentAddress !== undefined &&\n          newState.byAddress[address].byType[parentType] &&\n          newState.byAddress[address].byType[parentType].bySlotAddress[\n            parentAddress\n          ]\n        ) {\n          //if the parent is already present, use that instead of the given\n          //parent!\n          newSlot = {\n            ...slot,\n            path: newState.byAddress[address].byType[parentType].bySlotAddress[\n              parentAddress\n            ]\n          };\n        } else {\n          newSlot = slot;\n        }\n        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[\n          hexSlotAddress\n        ] = newSlot;\n      }\n      //if there's already something there, we don't need to do anything\n\n      return newState;\n\n    case actions.RESET:\n      return DEFAULT_PATHS;\n\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  assignments,\n  mappedPaths\n});\n\nconst reducer = combineReducers({\n  info,\n  proc\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\nimport * as Codec from \"@truffle/codec\";\n\nimport BN from \"bn.js\";\n\nconst DEFAULT_CONTEXTS = {\n  byContext: {}\n};\n\nfunction contexts(state = DEFAULT_CONTEXTS, action) {\n  switch (action.type) {\n    /*\n     * Adding a new context\n     */\n    case actions.ADD_CONTEXT:\n      let contextObject = { ...action };\n      delete contextObject.type; //this doesn't go in a context!\n      contextObject.payable = Codec.AbiData.Utils.abiHasPayableFallback(\n        contextObject.abi\n      );\n\n      return {\n        ...state,\n        byContext: {\n          ...state.byContext,\n          [contextObject.context]: contextObject\n        }\n      };\n\n    /*\n     * Default case\n     */\n    default:\n      return state;\n  }\n}\n\nconst info = combineReducers({\n  contexts\n});\n\nconst DEFAULT_TX = {\n  gasprice: new BN(0),\n  origin: Codec.Evm.Utils.ZERO_ADDRESS\n};\n\nfunction tx(state = DEFAULT_TX, action) {\n  switch (action.type) {\n    case actions.SAVE_GLOBALS:\n      let { gasprice, origin } = action;\n      return { gasprice, origin };\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_TX;\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_BLOCK = {\n  coinbase: Codec.Evm.Utils.ZERO_ADDRESS,\n  difficulty: new BN(0),\n  gaslimit: new BN(0),\n  number: new BN(0),\n  timestamp: new BN(0),\n  chainid: new BN(0),\n  basefee: new BN(0)\n};\n\nfunction block(state = DEFAULT_BLOCK, action) {\n  switch (action.type) {\n    case actions.SAVE_GLOBALS:\n      return action.block;\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_BLOCK;\n    default:\n      return state;\n  }\n}\n\nconst globals = combineReducers({\n  tx,\n  block\n});\n\nfunction blockHash(state = null, action) {\n  switch (action.type) {\n    case actions.SAVE_TX_IDENTIFICATION:\n      return action.blockHash;\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction txIndex(state = null, action) {\n  switch (action.type) {\n    case actions.SAVE_TX_IDENTIFICATION:\n      return action.txIndex;\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst txIdentification = combineReducers({\n  blockHash,\n  txIndex\n});\n\nfunction status(state = null, action) {\n  switch (action.type) {\n    case actions.SAVE_STATUS:\n      return action.status;\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction initialCall(state = null, action) {\n  switch (action.type) {\n    case actions.CALL:\n    case actions.CREATE:\n      //we only want to save the initial call, so return\n      //the current state if it's not null\n      if (state !== null) {\n        return state;\n      } else {\n        //we'll just store the action itself in the state\n        return action;\n      }\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_AFFECTED_INSTANCES = { byAddress: {} };\n\nfunction affectedInstances(state = DEFAULT_AFFECTED_INSTANCES, action) {\n  switch (action.type) {\n    case actions.ADD_AFFECTED_INSTANCE:\n      const { address, binary, context, creationBinary, creationContext } =\n        action;\n      return {\n        byAddress: {\n          ...state.byAddress,\n          [address]: {\n            address,\n            binary,\n            context,\n            creationBinary, //may be undefined\n            creationContext\n          }\n        }\n      };\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_AFFECTED_INSTANCES;\n    default:\n      return state;\n  }\n}\n\nconst transaction = combineReducers({\n  globals,\n  txIdentification,\n  status,\n  initialCall,\n  affectedInstances\n});\n\nfunction callstack(state = [], action) {\n  switch (action.type) {\n    case actions.CALL: {\n      const { address, data, storageAddress, sender, value } = action;\n      return state.concat([{ address, data, storageAddress, sender, value }]);\n    }\n\n    case actions.CREATE: {\n      const { binary, storageAddress, sender, value } = action;\n      return state.concat(\n        [{ binary, data: \"0x\", storageAddress, sender, value }]\n        //the empty data field is to make msg.data and msg.sig come out right\n      );\n    }\n\n    case actions.RETURN_CALL:\n    case actions.RETURN_CREATE:\n    case actions.FAIL:\n      //pop the stack... unless (HACK) that would leave it empty (this will\n      //only happen at the end when we want to keep the last one around)\n      return state.length > 1 ? state.slice(0, -1) : state;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n\n    default:\n      return state;\n  }\n}\n\nconst EMPTY_ACCOUNT = {\n  code: \"0x\",\n  context: null,\n  storage: {}\n};\n\nconst DEFAULT_CODEX = [\n  {\n    accounts: {\n      //we always include an account for the zero address;\n      //this is not actually used for the zero address, but\n      //rather is used to represent failed contract creations\n      //in cases where we can't determine what the address\n      //would have been.  So keep in mind that this does not\n      //actually represent the zero address.\n      [Codec.Evm.Utils.ZERO_ADDRESS]: EMPTY_ACCOUNT\n    }\n    //if we ever start keeping track of the self-destruct set,\n    //the log series, or various gas-related stuff, there may\n    //be more here in the future\n  }\n];\n\nfunction codex(state = DEFAULT_CODEX, action) {\n  let newState, topCodex, topCodexNoZero;\n\n  const updateFrameStorage = (frame, address, slot, value) => ({\n    ...frame,\n    accounts: {\n      ...frame.accounts,\n      [address]: {\n        code: \"0x\", //this will get overridden if it already exists!\n        context: null, //similarly!\n        ...frame.accounts[address], //may be undefined\n        storage: {\n          ...(frame.accounts[address] || {}).storage, //may be undefined\n          [slot]: value\n        }\n      }\n    }\n  });\n  //(note that {...undefined} just expands to {} and is OK)\n\n  const updateFrameCode = (frame, address, code, context) => {\n    let existingPage = frame.accounts[address] || { storage: {} };\n    return {\n      ...frame,\n      accounts: {\n        ...frame.accounts,\n        [address]: {\n          ...existingPage,\n          code: code,\n          context: context\n        }\n      }\n    };\n  };\n\n  const wipeZeroAccount = frame => ({\n    accounts: {\n      ...frame.accounts,\n      [Codec.Evm.Utils.ZERO_ADDRESS]: EMPTY_ACCOUNT\n    }\n  });\n\n  //later: may add \"force\" parameter\n  const safePop = array => (array.length > 2 ? array.slice(0, -1) : array);\n\n  //later: may add \"force\" parameter\n  //note: we don't need to wipe zero account when saving, because we'll never\n  //attempt to save the zero account in the first place\n  const safeSave = array =>\n    array.length > 2\n      ? array.slice(0, -2).concat([array[array.length - 1]])\n      : array;\n\n  switch (action.type) {\n    case actions.CALL:\n      debug(\"call action\");\n      debug(\"codex: %O\", state);\n      //on a call, we can just make a new stackframe by cloning the top\n      //stackframe; except we wipe the zero account, since the information\n      //it represents is stackframe-specific\n      topCodex = state[state.length - 1];\n      topCodexNoZero = wipeZeroAccount(topCodex);\n      //note there should already be an account for the address we're\n      //calling into, so we don't need to make one\n      return [...state, topCodexNoZero];\n\n    case actions.CREATE:\n      debug(\"create action\");\n      //on a create, make a new stackframe, then add a new page to the\n      //codex if necessary\n\n      //first, add a new stackframe by cloning the top one\n      //(and wiping the zero page)\n      topCodex = state[state.length - 1];\n      topCodexNoZero = wipeZeroAccount(topCodex);\n      newState = [...state, topCodexNoZero];\n      //now, do we need to add a new address to this stackframe?\n      if (topCodex.accounts[action.storageAddress] !== undefined) {\n        //if we don't\n        return newState;\n      }\n      //if we do\n      newState[newState.length - 1] = {\n        ...topCodex,\n        accounts: {\n          ...topCodex.accounts,\n          [action.storageAddress]: EMPTY_ACCOUNT\n        }\n      };\n      return newState;\n\n    case actions.STORE: {\n      debug(\"store action\");\n      //on a store, the relevant page should already exist, so we can just\n      //add or update the needed slot\n      const { address, slot, value } = action;\n      newState = state.slice(); //clone the state\n      topCodex = newState[newState.length - 1];\n      newState[newState.length - 1] = updateFrameStorage(\n        topCodex,\n        address,\n        slot,\n        value\n      );\n      return newState;\n    }\n\n    case actions.LOAD: {\n      debug(\"load action\");\n      //loads are a little more complicated -- usually we do nothing, but if\n      //it's an external load (there was nothing already there), then we want\n      //to update *every* stackframe\n      const { address, slot, value } = action;\n      if (address === Codec.Evm.Utils.ZERO_ADDRESS) {\n        //even though we now have a zero page, we still don't allow SLOADs to\n        //affect it.  firstly, because there will never be preexsting data on\n        //the zero page (it's only used for contract creations), so any SLOAD\n        //should only ever be of data that we already know (or that is zero).\n        //secondly, because the zero page represents something that is specific\n        //to a single stackframe, we definitely do *not* want to update every\n        //stackframe with its storage!\n        return state;\n      }\n      topCodex = state[state.length - 1];\n      if (topCodex.accounts[address].storage[slot] !== undefined) {\n        //if we already have a value in the *top* stackframe, update *no*\n        //stackframes; don't update the top (no need, it's just a load, not a\n        //store), don't update the rest (that would be wrong, you might be\n        //loading a value that will get reverted later)\n        return state;\n      } else {\n        //if we *don't* already have a value in the top stackframe, that means\n        //we're loading a value from a previous transaction!  That's not a\n        //value that will get reverted if this call fails, so update *every*\n        //stackframe\n        return state.map(frame =>\n          updateFrameStorage(frame, address, slot, value)\n        );\n      }\n    }\n\n    case actions.RETURN_CALL:\n      debug(\"return from call\");\n      //we want to pop the top while making the new top a copy of the old top;\n      //that is to say, we want to drop just the element *second* from the top\n      //NOTE: we don't ever go down to 1 element!\n      return safeSave(state);\n\n    case actions.RETURN_CREATE: {\n      debug(\"return from create\");\n      //we're going to do the same things in this case as in the usual return\n      //case, but first we need to record the code that was returned\n      const { address, code, context } = action;\n      newState = state.slice(); //clone the state\n      //NOTE: since this is only for RETURN_CREATE, and not FAIL, we shouldn't\n      //have to worry about accidentally getting a zero address here\n      newState[newState.length - 1] = updateFrameCode(\n        newState[newState.length - 1],\n        address,\n        code,\n        context\n      );\n      debug(\"newState: %O\", newState);\n      return safeSave(newState);\n    }\n\n    case actions.FAIL:\n      debug(\"fail action\");\n      //pop the stack\n      //NOTE: we don't ever go down to 1 element!\n      return safePop(state);\n\n    case actions.RESET:\n      debug(\"reset action\");\n      return [state[0]]; //leave the -1 frame on the stack\n\n    case actions.UNLOAD_TRANSACTION:\n      debug(\"unload action\");\n      return DEFAULT_CODEX;\n\n    case actions.ADD_INSTANCE: {\n      //add the instance to every frame\n      //(this is a little HACKy, but it *should* be fine)\n      debug(\"adding instance\");\n      const { address, binary, context } = action;\n      return state.map(frame =>\n        updateFrameCode(frame, address, binary, context)\n      );\n    }\n\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  callstack,\n  codex\n});\n\nfunction storageLookup(state = null, action) {\n  if (action.type === actions.SET_STORAGE_LOOKUP) {\n    return Boolean(action.status); //force Boolean to prevent undefined\n  } else {\n    return state;\n  }\n}\n\nfunction storageLookupSupported(state = null, action) {\n  if (action.type === actions.SET_STORAGE_LOOKUP_SUPPORT) {\n    return action.status;\n  } else {\n    return state;\n  }\n}\n\nconst application = combineReducers({\n  storageLookupSupported,\n  storageLookup\n});\n\nconst reducer = combineReducers({\n  info,\n  transaction,\n  proc,\n  application\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:sourcemapping:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nconst DEFAULT_SOURCES = {\n  byCompilationId: {}, //user sources\n  byContext: {} //internal sources\n};\n\n//This piece of state is organized as follows:\n//1. byId: contains all the sources, by ID.  straightforward.\n//2. byCompilationId: contains the IDs of the user sources,\n//organized by compilation ID and then index (this last part\n//takes the form of an array).\n//3. byContext: contains the IDs of the internal sources,\n//organized by context hash and then index (again, this\n//last part takes the form of an array, although a sparse\n//array be aware).\nfunction sources(state = DEFAULT_SOURCES, action) {\n  switch (action.type) {\n    /*\n     * Adding new sources\n     */\n    case actions.ADD_SOURCES:\n      //NOTE: this code assumes that we are only ever adding compilations or contexts\n      //wholesale, and never adding to existing ones!\n      return {\n        byCompilationId: {\n          ...state.byCompilationId,\n          ...Object.assign(\n            {},\n            ...Object.entries(action.sources.user).map(([id, compilation]) => ({\n              [id]: {\n                byIndex: compilation.map(source => source.id)\n              }\n            }))\n          )\n        },\n        byContext: {\n          ...state.byContext,\n          ...Object.assign(\n            {},\n            ...Object.entries(action.sources.internal).map(\n              ([hash, context]) => ({\n                [hash]: {\n                  byIndex: context.map(source => source.id)\n                }\n              })\n            )\n          )\n        },\n        byId: {\n          ...state.byId,\n          ...Object.assign(\n            {},\n            ...Object.values(action.sources.user)\n              .concat(Object.values(action.sources.internal))\n              .flat()\n              .map(source => (source ? { [source.id]: source } : {}))\n          )\n        }\n      };\n    /*\n     * Default case\n     */\n    default:\n      return state;\n  }\n}\n\nconst info = combineReducers({\n  sources\n});\n\nfunction functionDepthStack(state = [], action) {\n  switch (action.type) {\n    case actions.JUMP:\n      let newState = state.slice(); //clone the state\n      const delta = spelunk(action.jumpDirection);\n      let top = newState[newState.length - 1];\n      let belowTop = newState.length > 1 ? newState[newState.length - 2] : -1;\n      newState[newState.length - 1] = Math.max(top + delta, belowTop + 1);\n      return newState;\n\n    case actions.RESET:\n      return [0];\n\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n\n    case actions.EXTERNAL_CALL:\n      if (state.length === 0) {\n        return [0];\n      }\n      return [...state, state[state.length - 1] + 1];\n\n    case actions.EXTERNAL_RETURN:\n      //just pop the stack! unless, HACK, that would leave it empty\n      return state.length > 1 ? state.slice(0, -1) : state;\n\n    default:\n      return state;\n  }\n}\n\nfunction nextFrameIsPhantom(state = null, action) {\n  switch (action.type) {\n    case actions.CLEAR_PHANTOM_GUARD:\n      return false;\n    case actions.EXTERNAL_RETURN:\n      return false;\n    case actions.EXTERNAL_CALL:\n      return action.guard;\n    case actions.RESET:\n      return action.guard;\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction spelunk(jump) {\n  if (jump === \"i\") {\n    return 1;\n  } else if (jump === \"o\") {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nconst proc = combineReducers({\n  functionDepthStack,\n  nextFrameIsPhantom\n});\n\nconst reducer = combineReducers({\n  info,\n  proc\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:trace:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nfunction index(state = 0, action) {\n  switch (action.type) {\n    case actions.ADVANCE:\n      return state + 1;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return 0;\n\n    default:\n      return state;\n  }\n}\n\nfunction finished(state = false, action) {\n  switch (action.type) {\n    case actions.END_OF_TRACE:\n      return true;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return false;\n\n    default:\n      return state;\n  }\n}\n\nfunction steps(state = null, action) {\n  switch (action.type) {\n    case actions.SAVE_STEPS:\n      return action.steps;\n    case actions.UNLOAD_TRANSACTION:\n      debug(\"unloading\");\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction submoduleCount(state = 0, action) {\n  switch (action.type) {\n    case actions.SET_SUBMODULE_COUNT:\n      return action.count;\n    default:\n      return state;\n  }\n}\n\nconst transaction = combineReducers({\n  steps\n});\n\nconst proc = combineReducers({\n  index,\n  finished\n});\n\nconst application = combineReducers({\n  submoduleCount\n});\n\nconst reducer = combineReducers({\n  transaction,\n  proc,\n  application\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nfunction breakpoints(state = [], action) {\n  switch (action.type) {\n    case actions.ADD_BREAKPOINT:\n      //check for any existing identical breakpoints to avoid redundancy\n      if (\n        state.filter(\n          breakpoint =>\n            breakpoint.sourceId === action.breakpoint.sourceId &&\n            breakpoint.line === action.breakpoint.line &&\n            breakpoint.node === action.breakpoint.node //may be undefined\n        ).length > 0\n      ) {\n        //if it's already there, do nothing\n        return state;\n      } else {\n        //otherwise add it\n        return state.concat([action.breakpoint]);\n      }\n      break;\n\n    case actions.REMOVE_BREAKPOINT:\n      return state.filter(\n        breakpoint =>\n          breakpoint.sourceId !== action.breakpoint.sourceId ||\n          breakpoint.line !== action.breakpoint.line ||\n          breakpoint.node !== action.breakpoint.node //may be undefined\n      );\n      break;\n\n    case actions.REMOVE_ALL_BREAKPOINTS:\n      return [];\n\n    default:\n      return state;\n  }\n}\n\nfunction isStepping(state = false, action) {\n  switch (action.type) {\n    case actions.START_STEPPING:\n      debug(\"got step start action\");\n      return true;\n    case actions.DONE_STEPPING:\n      debug(\"got step stop action\");\n      return false;\n    default:\n      return state;\n  }\n}\n\nfunction stepIntoInternalSources(state = false, action) {\n  if (action.type === actions.SET_INTERNAL_STEPPING) {\n    return action.status;\n  } else {\n    return state;\n  }\n}\n\nconst reducer = combineReducers({\n  breakpoints,\n  stepIntoInternalSources,\n  isStepping\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:reducers\");\n\nimport { combineReducers } from \"redux\";\nimport { popNWhere } from \"lib/helpers\";\n\nimport * as actions from \"./actions\";\n\nfunction callstack(state = [], action) {\n  let newFrame;\n  switch (action.type) {\n    case actions.JUMP_IN:\n      const { location, functionNode, contractNode, sourceIsInternal } = action;\n      newFrame = {\n        type: \"internal\",\n        calledFromLocation: location,\n        address: state[state.length - 1].address,\n        isConstructor: state[state.length - 1].isConstructor,\n        functionName:\n          functionNode &&\n          (functionNode.nodeType === \"FunctionDefinition\" ||\n            functionNode.nodeType === \"YulFunctionDefinition\")\n            ? functionNode.name\n            : undefined,\n        contractName:\n          contractNode && contractNode.nodeType === \"ContractDefinition\"\n            ? contractNode.name\n            : undefined,\n        combineWithNextInternal: false,\n        sourceIsInternal\n        //note we don't currently account for getters because currently\n        //we can't; fallback, receive, constructors, & modifiers also remain\n        //unaccounted for at present\n        //(none of these things have associated jump-in markings!)\n      };\n      return [...state, newFrame];\n    case actions.JUMP_OUT:\n      let top = state[state.length - 1];\n      if (top && top.type === \"internal\") {\n        return state.slice(0, -1);\n      } else {\n        return state;\n      }\n    case actions.EXTERNAL_CALL:\n      newFrame = {\n        type: \"external\",\n        address: action.address,\n        calledFromLocation: action.location,\n        functionName: undefined,\n        contractName: action.context.contractName,\n        isConstructor: action.context.isConstructor,\n        combineWithNextInternal: action.combineWithNextInternal\n        //sourceIsInternal doesn't really apply here, so let's just omit it\n      };\n      return [...state, newFrame];\n    case actions.EXECUTE_RETURN:\n      return popNWhere(\n        state,\n        action.counter,\n        frame => frame.type === \"external\"\n      );\n    case actions.RESET:\n      return [state[0]];\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n    default:\n      //note that we don't do anything on EXTERNAL_RETURN!\n      //the callstack only changes on EXECUTE_RETURN!\n      return state;\n  }\n}\n\nfunction returnCounter(state = 0, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      return state + 1;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return 0;\n    default:\n      return state;\n  }\n}\n\nfunction lastPosition(state = null, action) {\n  switch (action.type) {\n    case actions.JUMP_IN:\n    case actions.JUMP_OUT:\n    case actions.EXTERNAL_CALL:\n    case actions.EXTERNAL_RETURN:\n    case actions.UPDATE_POSITION:\n    case actions.EXECUTE_RETURN:\n      const { location } = action;\n      if (\n        location === null ||\n        location.source.id === undefined ||\n        location.source.internal\n      ) {\n        //don't update for unmapped or internal!\n        //also don't update for null location\n        return state;\n      }\n      return location;\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction innerReturnPosition(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      //we want the innermost return, so don't update\n      //this if it's not presently null\n      return state || action.from;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction innerReturnStatus(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      //we want the innermost return, so don't update\n      //this if it's not presently null\n      return state === null ? action.status : state;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction innerErrorIndex(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      //we use index null to mean don't update\n      return action.index !== null ? action.index : state;\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  callstack,\n  returnCounter,\n  lastPosition,\n  innerReturnPosition,\n  innerReturnStatus,\n  innerErrorIndex\n});\n\nconst reducer = combineReducers({\n  proc\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:txlog:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\n//NOTE: even though we refer to nodes by JSON pointer,\n//these pointers are \"fake\" in that we don't actually\n//use them *as* JSON pointers; it's just a convenient\n//method of IDing them that also has a nice intuitive\n//meaning (you'll notice we don't actually import\n//json-pointer here or anywhere else in this submodule)\nconst DEFAULT_TX_LOG = {\n  byPointer: {\n    \"\": {\n      // \"\" is the root node\n      type: \"transaction\",\n      actions: []\n    }\n  }\n};\n\nfunction transactionLog(state = DEFAULT_TX_LOG, action) {\n  const { pointer, newPointer, step } = action;\n  const node = state.byPointer[pointer];\n  switch (action.type) {\n    case actions.RECORD_ORIGIN:\n      if (node.type === \"transaction\") {\n        return {\n          byPointer: {\n            ...state.byPointer,\n            [pointer]: {\n              ...node,\n              origin: action.address\n            }\n          }\n        };\n      } else {\n        debug(\"attempt to set origin of bad node type!\");\n        return state;\n      }\n\n    case actions.LOG_EVENT:\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: {\n            ...node,\n            actions: [...node.actions, newPointer]\n          },\n          [newPointer]: {\n            type: \"event\",\n            decoding: action.decoding,\n            raw: action.rawEventInfo,\n            step\n          }\n        }\n      };\n\n    case actions.STORE:\n      //this case will likely need to be redone when decoding is added\n      //(likely split into multiple cases)\n      //for now, there is no combining of different writes, but when decoding\n      //is added there will need to be!\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: {\n            ...node,\n            actions: [...node.actions, newPointer]\n          },\n          [newPointer]: {\n            type: \"write\",\n            raw: {\n              [action.rawSlot]: action.rawValue\n            },\n            steps: {\n              [action.rawSlot]: step\n            }\n          }\n        }\n      };\n    case actions.INTERNAL_CALL:\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: {\n            ...node,\n            actions: [...node.actions, newPointer]\n          },\n          [newPointer]: {\n            type: \"callinternal\",\n            actions: [],\n            beginStep: step,\n            waitingForFunctionDefinition: true\n          }\n        }\n      };\n    case actions.ABSORBED_CALL:\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: {\n            ...node,\n            absorbNextInternalCall: false\n          }\n        }\n      };\n    case actions.INTERNAL_RETURN:\n      //pop the top call from the stack if it's internal (and set its return values)\n      //if the top call is instead external, just set its return values if appropriate.\n      //(this is how we handle internal/external return absorption)\n      const modifiedNode = { ...node };\n      if (modifiedNode.type === \"callinternal\") {\n        modifiedNode.returnKind = \"return\";\n        modifiedNode.returnValues = action.variables;\n        delete modifiedNode.waitingForFunctionDefinition;\n      } else if (modifiedNode.type === \"callexternal\") {\n        if (modifiedNode.kind === \"function\") {\n          //don't set return variables for non-function external calls\n          modifiedNode.returnValues = action.variables;\n        }\n      } else {\n        debug(\"returninternal once tx done!\");\n      }\n      modifiedNode.endStep = step;\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: modifiedNode\n        }\n      };\n    case actions.INSTANT_EXTERNAL_CALL:\n    case actions.EXTERNAL_CALL:\n    case actions.INSTANT_CREATE:\n    case actions.CREATE: {\n      const instant =\n        action.type === actions.INSTANT_EXTERNAL_CALL ||\n        action.type === actions.INSTANT_CREATE;\n      let modifiedNode = {\n        ...node,\n        actions: [...node.actions, newPointer]\n      };\n      if (\n        modifiedNode.type === \"callexternal\" &&\n        modifiedNode.kind === \"library\"\n      ) {\n        //didn't identify it as function, so set it to message\n        modifiedNode.kind = \"message\";\n      }\n      const {\n        address,\n        binary, //only for creates\n        context,\n        value,\n        salt, //only for creates\n        isDelegate,\n        decoding,\n        calldata,\n        status\n      } = action;\n      let kind;\n      if (\n        action.type === actions.CREATE ||\n        action.type === actions.INSTANT_CREATE\n      ) {\n        //these don't have kind in the action, so we instead determine\n        //it this way\n        kind = context ? \"constructor\" : \"unknowncreate\";\n      } else {\n        kind = action.kind;\n      }\n      const contractName = context ? context.contractName : undefined;\n      let functionName, variables;\n      if (decoding.kind === \"function\" || decoding.kind === \"constructor\") {\n        functionName = decoding.abi.name;\n        variables = decoding.arguments;\n      }\n      let call = {\n        type: \"callexternal\",\n        address,\n        contextHash: context.context || null,\n        value,\n        kind,\n        isDelegate,\n        functionName,\n        contractName,\n        arguments: variables,\n        actions: [],\n        beginStep: step\n      };\n      if (kind === \"message\" || kind === \"library\") {\n        call.data = calldata;\n      } else if (kind === \"unknowncreate\") {\n        call.binary = binary;\n      }\n      if (kind === \"constructor\" || kind === \"unknowncreate\") {\n        call.salt = salt;\n      }\n      if (instant) {\n        call.returnKind = status ? \"return\" : \"revert\";\n        call.endStep = step;\n      } else {\n        //If kind === \"message\", set waiting to false.\n        //Why?  Well, because fallback functions and receive functions\n        //typically have their function definitions skipped over, so the next\n        //one we hit would instead be a function *called* from the fallback\n        //function, which is not what we want.\n        call.waitingForFunctionDefinition = kind !== \"message\";\n        //if kind is message or constructor, we don't want to absorb.\n        call.absorbNextInternalCall =\n          (kind === \"function\" || kind === \"library\") &&\n          action.absorbNextInternalCall;\n      }\n      //include raw data regardless\n      call.raw = {};\n      if (calldata) {\n        call.raw.calldata = calldata;\n      }\n      if (binary) {\n        call.raw.binary = binary;\n      }\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: modifiedNode,\n          [newPointer]: call\n        }\n      };\n    }\n    case actions.EXTERNAL_RETURN:\n    case actions.REVERT:\n    case actions.SELFDESTRUCT: {\n      //first: set the returnKind and other info\n      let modifiedNode = { ...node };\n      if (\n        modifiedNode.type === \"callexternal\" &&\n        modifiedNode.kind === \"library\"\n      ) {\n        //didn't identify it as function, so set it to message\n        modifiedNode.kind = \"message\";\n      }\n      switch (action.type) {\n        case actions.EXTERNAL_RETURN:\n          if (!modifiedNode.returnKind) {\n            modifiedNode.returnKind = \"return\";\n          }\n          break;\n        case actions.REVERT:\n          modifiedNode.returnKind = \"revert\";\n          modifiedNode.error = action.error;\n          break;\n        case actions.SELFDESTRUCT:\n          modifiedNode.returnKind = \"selfdestruct\";\n          modifiedNode.beneficiary = action.beneficiary;\n          break;\n      }\n      modifiedNode.endStep = step;\n      let newState = {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: modifiedNode\n        }\n      };\n      //now: pop all calls from stack until we pop an external call.\n      //we don't handle return values here since those are handled\n      //in returninternal (yay absorption)\n      let currentPointer;\n      for (\n        currentPointer = pointer;\n        currentPointer.replace(/\\/actions\\/\\d+$/, \"\") !== newPointer; //stop *before* the stop pointer\n        currentPointer = currentPointer.replace(/\\/actions\\/\\d+$/, \"\") //cut off end\n      ) {\n        debug(\"currentNode!\");\n        let currentNode = { ...newState.byPointer[currentPointer] }; //clone\n        if (!currentNode.returnKind) {\n          //set the return kind on any nodes popped along the way that don't have\n          //one already to note that they failed to return due to a call they made\n          //reverting\n          currentNode.returnKind = \"unwind\";\n          currentNode.endStep = step;\n        }\n        delete currentNode.waitingForFunctionDefinition;\n        debug(\"set currentNode!\");\n        newState.byPointer[currentPointer] = currentNode;\n      }\n      //now handle the external call.\n      //note that currentPointer now points to it.\n      debug(\"finalNode!\");\n      let finalNode = { ...newState.byPointer[currentPointer] }; //clone\n      //first let's set the returnKind if there isn't one already\n      //(in which case we can infer it was unwound).\n      if (!finalNode.returnKind) {\n        finalNode.returnKind = \"unwind\";\n      }\n      //now let's set its return variables if applicable.\n      if (\n        finalNode.kind === \"function\" &&\n        action.type === actions.EXTERNAL_RETURN &&\n        action.decodings\n      ) {\n        //functions get returnValues\n        const decoding = action.decodings.find(\n          decoding => decoding.kind === \"return\"\n        );\n        if (decoding) {\n          //we'll trust this method over the method resulting from an internal return,\n          //*if* it produces a valid return-value decoding.  if it doesn't, we ignore it.\n          finalNode.returnValues = decoding.arguments;\n        }\n      }\n      //and we'll set raw return data if applicable\n      //(we don't use codec here to increase robustness)\n      if (\n        finalNode.kind === \"message\" &&\n        action.type === actions.EXTERNAL_RETURN\n      ) {\n        finalNode.returnData = action.returnData;\n      }\n      //also, set immutables if applicable -- note that we do *not* attempt to set\n      //these the internal way, as we don't have a reliable way of doing that\n      if (\n        finalNode.kind === \"constructor\" &&\n        action.type === actions.EXTERNAL_RETURN &&\n        action.decodings\n      ) {\n        const decoding = action.decodings.find(\n          decoding => decoding.kind === \"bytecode\"\n        );\n        if (decoding && decoding.immutables) {\n          finalNode.returnImmutables = decoding.immutables;\n        }\n      }\n      //and of course set the end step\n      finalNode.endStep = step;\n      //finally, delete internal info\n      delete finalNode.waitingForFunctionDefinition;\n      delete finalNode.absorbNextInternalCall;\n      debug(\"set finalNode!\");\n      newState.byPointer[currentPointer] = finalNode;\n      return newState;\n    }\n    case actions.IDENTIFY_FUNCTION_CALL: {\n      const { functionNode, contractNode, variables } = action;\n      const functionName = functionNode.name || undefined; //replace \"\" with undefined\n      const contractName =\n        contractNode && contractNode.nodeType === \"ContractDefinition\"\n          ? contractNode.name\n          : null;\n      let modifiedNode = {\n        ...node,\n        waitingForFunctionDefinition: false\n      };\n      //note: I don't handle the following three fields in the object spread above\n      //because I don't want undefined or null counting against it\n      if (!modifiedNode.functionName) {\n        modifiedNode.functionName = functionName;\n      }\n      if (!modifiedNode.contractName) {\n        modifiedNode.contractName = contractName;\n      }\n      if (!modifiedNode.arguments) {\n        modifiedNode.arguments = variables;\n      }\n      if (\n        modifiedNode.type === \"callexternal\" &&\n        modifiedNode.kind === \"library\"\n      ) {\n        modifiedNode.kind = \"function\";\n        delete modifiedNode.data;\n      }\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: modifiedNode\n        }\n      };\n    }\n    case actions.RESET: //we'll reset everything and re-put initial action afterwards\n      //...well, almost everything.  we'll leave the origin in place.\n      return {\n        byPointer: {\n          \"\": {\n            type: \"transaction\",\n            origin: state.byPointer[\"\"].origin, //keep origin\n            actions: []\n          }\n        }\n      };\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_TX_LOG;\n    default:\n      return state;\n  }\n}\n\nfunction currentNodePointer(state = \"\", action) {\n  switch (action.type) {\n    case actions.INTERNAL_CALL:\n    case actions.EXTERNAL_CALL:\n    case actions.CREATE:\n    case actions.INTERNAL_RETURN:\n    case actions.EXTERNAL_RETURN:\n    case actions.REVERT:\n    case actions.SELFDESTRUCT:\n      //note that instant calls/creates are not included!\n      return action.newPointer;\n    case actions.RESET: //we'll reset everything and re-put initial action afterwards\n    case actions.UNLOAD_TRANSACTION:\n      return \"\";\n    default:\n      //includes events & stores\n      return state;\n  }\n}\n\n//this is a stack of the pointers to external calls.\n//note: not to the frames below them!\nfunction pointerStack(state = [], action) {\n  switch (action.type) {\n    case actions.EXTERNAL_CALL:\n    case actions.CREATE:\n      //note that instant calls & creates are not included!\n      return [...state, action.newPointer];\n    case actions.EXTERNAL_RETURN:\n    case actions.REVERT:\n    case actions.SELFDESTRUCT:\n      return state.slice(0, -1);\n    case actions.RESET: //we'll reset everything and re-put initial action afterwards\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n    default:\n      //includes events & stores\n      return state;\n  }\n}\n\nfunction initialCall(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_CALL:\n    case actions.CREATE:\n      //we only want to save the initial call, so return\n      //the current state if it's not null\n      //(we can skip instant case here, initial call is never instant)\n      if (state !== null) {\n        return state;\n      } else {\n        //we'll just store the action itself in the state\n        return action;\n      }\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  transactionLog,\n  currentNodePointer,\n  pointerStack\n});\n\nconst transaction = combineReducers({\n  initialCall\n});\n\nconst reducer = combineReducers({\n  proc,\n  transaction\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport data from \"lib/data/reducers\";\nimport evm from \"lib/evm/reducers\";\nimport sourcemapping from \"lib/sourcemapping/reducers\";\nimport trace from \"lib/trace/reducers\";\nimport controller from \"lib/controller/reducers\";\nimport stacktrace from \"lib/stacktrace/reducers\";\nimport txlog from \"lib/txlog/reducers\";\n\nimport * as actions from \"./actions\";\n\nfunction ready(state = false, action) {\n  switch (action.type) {\n    case actions.READY:\n      debug(\"readying\");\n      return true;\n\n    case actions.WAIT:\n      return false;\n\n    default:\n      return state;\n  }\n}\n\nfunction lastLoadingError(state = null, action) {\n  switch (action.type) {\n    case actions.ERROR:\n      debug(\"error: %o\", action.error);\n      return action.error;\n\n    case actions.WAIT:\n      return null;\n\n    default:\n      return state;\n  }\n}\n\nfunction transaction(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_TRANSACTION:\n      return action.transaction;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction receipt(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_RECEIPT:\n      return action.receipt;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction block(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_BLOCK:\n      return action.block;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction lightMode(state = false, action) {\n  switch (action.type) {\n    case actions.SET_LIGHT_MODE:\n      return true;\n    case actions.SET_FULL_MODE:\n      return false;\n    default:\n      return state;\n  }\n}\n\nconst session = combineReducers({\n  ready,\n  lastLoadingError,\n  transaction,\n  receipt,\n  block,\n  lightMode\n});\n\nconst reduceState = combineReducers({\n  session,\n  data,\n  txlog,\n  evm,\n  sourcemapping,\n  stacktrace,\n  trace,\n  controller\n});\n\nexport default reduceState;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session\");\n\nimport * as Abi from \"@truffle/abi-utils\";\nimport * as Codec from \"@truffle/codec\";\nimport { keccak256, stableKeccak256 } from \"lib/helpers\";\n\nimport configureStore from \"lib/store\";\n\nimport * as controller from \"lib/controller/actions\";\nimport * as actions from \"./actions\";\nimport data from \"lib/data/selectors\";\nimport txlog from \"lib/txlog/selectors\";\nimport stacktrace from \"lib/stacktrace/selectors\";\nimport session from \"lib/session/selectors\";\nimport * as dataSagas from \"lib/data/sagas\";\nimport * as controllerSagas from \"lib/controller/sagas\";\nimport * as sagas from \"./sagas\";\nimport controllerSelector from \"lib/controller/selectors\";\n\nimport { createNestedSelector } from \"reselect-tree\";\n\nimport ast from \"lib/ast/selectors\";\nimport trace from \"lib/trace/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport sourcemapping from \"lib/sourcemapping/selectors\";\n\nimport rootSaga from \"./sagas\";\nimport reducer from \"./reducers\";\n\nimport { Shims } from \"@truffle/compile-common\";\n\n/**\n * Debugger Session\n */\nexport default class Session {\n  /**\n   * @param {Array<Compilations>} compilations\n   * @param {Web3Provider} provider - web3 provider\n   * txHash parameter is now optional!\n   * @private\n   */\n  constructor(compilations, provider, moduleOptions, txHash) {\n    /**\n     * @private\n     */\n    const { store, sagaMiddleware } = configureStore(reducer, rootSaga, [\n      moduleOptions\n    ]);\n    this._store = store;\n    this._sagaMiddleware = sagaMiddleware;\n\n    const { contexts, sources, contracts } = Session.normalize(compilations);\n\n    // record contracts\n    this._store.dispatch(actions.recordContracts(contexts, sources, contracts));\n\n    //set up the ready listener\n    this._ready = new Promise((accept, reject) => {\n      const unsubscribe = this._store.subscribe(() => {\n        if (this.view(session.status.ready)) {\n          debug(\"ready!\");\n          unsubscribe();\n          accept();\n        } else if (this.view(session.status.errored)) {\n          debug(\"error!\");\n          unsubscribe();\n          reject(this.view(session.status.error));\n        }\n      });\n    });\n\n    //note that txHash is now optional\n    this._store.dispatch(actions.start(provider, txHash));\n  }\n\n  async ready() {\n    await this._ready;\n  }\n\n  async readyAgainAfterLoading(sessionAction) {\n    return new Promise((accept, reject) => {\n      let hasStartedWaiting = false;\n      debug(\"reready listener set up\");\n      const unsubscribe = this._store.subscribe(() => {\n        debug(\"reready?\");\n        if (hasStartedWaiting) {\n          if (this.view(session.status.ready)) {\n            debug(\"reready!\");\n            unsubscribe();\n            accept(true);\n          } else if (this.view(session.status.errored)) {\n            unsubscribe();\n            debug(\"error!\");\n            reject(this.view(session.status.error));\n          }\n        } else {\n          if (this.view(session.status.waiting)) {\n            debug(\"started waiting\");\n            hasStartedWaiting = true;\n          }\n          return;\n        }\n      });\n      this.dispatch(sessionAction);\n    });\n  }\n\n  /**\n   * Split up artifacts into \"contexts\" and \"sources\", dividing artifact\n   * data into appropriate buckets.\n   *\n   * Multiple contracts can be defined in the same source file, but have\n   * different bytecodes.\n   *\n   * (NOTE: now that this takes compilations, the splitting is largely already\n   * done.  However, there's still remaining work to do.)\n   *\n   * @private\n   */\n  static normalize(compilations) {\n    let contexts = [];\n    let sources = {\n      user: {}, //by compilation\n      internal: {} //by context\n    };\n    let contracts = {}; //other info such as ABIs\n\n    //we're actually going to ignore the passed-in IDs and make our own.\n    //note we'll set contextHash to null for user sources, and only set it\n    //for internal sources.\n    const makeSourceId = (compilationId, contextHash, index) =>\n      stableKeccak256({ compilationId, contextHash, index });\n\n    for (const compilation of compilations) {\n      if (compilation.unreliableSourceOrder) {\n        throw new Error(\n          `Error: Compilation ${compilation.id} has unreliable source order.`\n        );\n      }\n      const compiler = compilation.compiler; //note: we'll prefer one listed on contract or source\n      const settings = compilation.settings; //same note\n      sources.user[compilation.id] = [];\n      contracts[compilation.id] = {};\n      for (let index in compilation.sources) {\n        //not the recommended way to iterate over an array,\n        //but the order doesn't matter here so it's safe\n        index = Number(index); //however due to the use of in we must explicitly convert to number\n        let source = compilation.sources[index];\n        if (!source) {\n          continue; //just for safety (in case there are gaps)\n        }\n        let ast = source.ast;\n        if (ast && !ast.nodeType) {\n          ast = undefined; //HACK: remove Vyper asts for now\n        }\n        sources.user[compilation.id][index] = {\n          ...source,\n          ast,\n          compiler: source.compiler || compiler,\n          settings: source.settings || settings,\n          compilationId: compilation.id,\n          index,\n          id: makeSourceId(compilation.id, null, index),\n          internal: false\n        };\n      }\n\n      for (let contract of compilation.contracts) {\n        let {\n          contractName,\n          bytecode: binary,\n          sourceMap,\n          deployedBytecode: deployedBinary,\n          deployedSourceMap,\n          immutableReferences,\n          abi,\n          compiler,\n          settings,\n          primarySourceId,\n          generatedSources,\n          deployedGeneratedSources\n        } = contract;\n        debug(\"contractName: %s\", contractName);\n\n        //hopefully we can get rid of this step eventually, but not yet\n        if (typeof binary === \"object\") {\n          binary = Shims.NewToLegacy.forBytecode(binary);\n        }\n        if (typeof deployedBinary === \"object\") {\n          deployedBinary = Shims.NewToLegacy.forBytecode(deployedBinary);\n        }\n\n        let primarySourceIndex;\n        if (primarySourceId !== undefined) {\n          //I'm assuming this finds it! it had better!\n          primarySourceIndex = compilation.sources.findIndex(\n            source => source && source.id === primarySourceId\n          );\n        }\n        //otherwise leave it undefined\n        let primaryLanguage;\n        if (primarySourceIndex !== undefined) {\n          primaryLanguage = compilation.sources[primarySourceIndex].language;\n        }\n        //leave undefined if can't locate primary source\n\n        //now: we need to find the contract node.\n        //note: ideally we'd hold this off till later, but that would break the\n        //direction of the evm/sourcemapping dependence, so we do it now\n        const contractNode = Codec.Compilations.Utils.getContractNode(\n          contract,\n          compilation\n        );\n\n        const contractId = contractNode ? contractNode.id : undefined;\n        const contractKind = contractNode\n          ? contractNode.contractKind\n          : undefined;\n        const linearizedBaseContracts = contractNode\n          ? contractNode.linearizedBaseContracts\n          : undefined;\n        abi = Abi.normalize(abi); //let's handle this up front\n\n        debug(\"contractName %s\", contractName);\n        debug(\"sourceMap %o\", sourceMap);\n        debug(\"compiler %o\", compiler);\n        debug(\"abi %o\", abi);\n\n        if (contractId) {\n          contracts[compilation.id][contractId] = {\n            compilationId: compilation.id,\n            contractId,\n            abi,\n            //set context hashes temporarily to null; they'll be set for real below\n            //if they exist\n            deployedContext: null,\n            constructorContext: null\n            //things to consider adding in the future:\n            //primarySource, contractName, compiler, contractKind,\n            //linearizedBaseContracts, primaryLanguage\n          };\n        }\n\n        //note: simpleShimSourceMap does not handle the case where we can't just extract\n        //the Solidity-style source map\n        sourceMap = Codec.Compilations.Utils.simpleShimSourceMap(sourceMap);\n        deployedSourceMap =\n          Codec.Compilations.Utils.simpleShimSourceMap(deployedSourceMap);\n\n        if (binary && binary != \"0x\") {\n          //NOTE: we take hash as *string*, not as bytes, because the binary may\n          //contain link references!\n          const contextHash = keccak256({\n            type: \"string\",\n            value: binary\n          });\n          contexts.push({\n            context: contextHash,\n            contractName,\n            binary,\n            sourceMap,\n            primarySource: primarySourceIndex,\n            abi,\n            compiler,\n            settings,\n            compilationId: compilation.id,\n            contractId,\n            contractKind,\n            linearizedBaseContracts,\n            primaryLanguage,\n            isConstructor: true\n          });\n          if (generatedSources) {\n            sources.internal[contextHash] = [];\n            for (let index in generatedSources) {\n              index = Number(index); //it comes out as a string due to in, so let's fix that\n              const source = generatedSources[index];\n              // VSCode extension breaks w/o this check\n              if (source) {\n                sources.internal[contextHash][index] = {\n                  ...source,\n                  compiler: source.compiler || compiler,\n                  settings: source.settings || settings,\n                  compilationId: compilation.id,\n                  index,\n                  id: makeSourceId(compilation.id, contextHash, index),\n                  internal: true,\n                  internalFor: contextHash\n                };\n              }\n            }\n          }\n          if (contractId) {\n            contracts[compilation.id][contractId].constructorContext =\n              contextHash;\n          }\n        }\n\n        if (deployedBinary && deployedBinary != \"0x\") {\n          //NOTE: we take hash as *string*, not as bytes, because the binary may\n          //contain link references!\n          const contextHash = keccak256({\n            type: \"string\",\n            value: deployedBinary\n          });\n          contexts.push({\n            context: contextHash,\n            contractName,\n            binary: deployedBinary,\n            sourceMap: deployedSourceMap,\n            primarySource: primarySourceIndex,\n            immutableReferences,\n            abi,\n            compiler,\n            settings,\n            compilationId: compilation.id,\n            contractId,\n            contractKind,\n            linearizedBaseContracts,\n            primaryLanguage,\n            isConstructor: false\n          });\n          if (deployedGeneratedSources) {\n            sources.internal[contextHash] = [];\n            for (let index in deployedGeneratedSources) {\n              index = Number(index); //it comes out as a string due to in, so let's fix that\n              const source = deployedGeneratedSources[index];\n              // VSCode extension breaks w/o this check\n              if (source) {\n                sources.internal[contextHash][index] = {\n                  ...source,\n                  compiler: source.compiler || compiler,\n                  settings: source.settings || settings,\n                  compilationId: compilation.id,\n                  index,\n                  id: makeSourceId(compilation.id, contextHash, index),\n                  internal: true,\n                  internalFor: contextHash\n                };\n              }\n            }\n          }\n          if (contractId) {\n            contracts[compilation.id][contractId].deployedContext = contextHash;\n          }\n        }\n      }\n    }\n\n    //now: turn contexts from array into object\n    contexts = Object.assign(\n      {},\n      ...contexts.map(context => ({\n        [context.context]: {\n          ...context\n        }\n      }))\n    );\n\n    //normalize contexts\n    //HACK: the type of contexts doesn't actually match!!\n    //fortunately it's good enough to work\n    contexts = Codec.Contexts.Utils.normalizeContexts(contexts);\n\n    return { contexts, sources, contracts };\n  }\n\n  get state() {\n    return this._store.getState();\n  }\n\n  view(selector) {\n    return selector(this.state);\n  }\n\n  async dispatch(action) {\n    this._store.dispatch(action);\n\n    return true;\n  }\n\n  /**\n   * @private\n   * Allows running any saga -- for internal use only!\n   * Using this could seriously screw up the debugger state if you\n   * don't know what you're doing!\n   */\n  async _runSaga(saga, ...args) {\n    return await this._sagaMiddleware.run(saga, ...args).toPromise();\n  }\n\n  async interrupt() {\n    await this.dispatch(actions.interrupt());\n    await this.dispatch(controller.interrupt());\n  }\n\n  async doneStepping(stepperAction) {\n    return new Promise(resolve => {\n      let hasStarted = false;\n      const unsubscribe = this._store.subscribe(() => {\n        const isStepping = this.view(controllerSelector.isStepping);\n\n        if (isStepping && !hasStarted) {\n          hasStarted = true;\n          return;\n        }\n\n        if (!isStepping && hasStarted) {\n          unsubscribe();\n          resolve(true);\n        }\n      });\n      this.dispatch(stepperAction);\n    });\n  }\n\n  //returns true on success, false on already loaded; throws on failure\n  async load(txHash, loadOptions = {}) {\n    if (this.view(session.status.loaded)) {\n      return false;\n    }\n    return await this.readyAgainAfterLoading(\n      actions.loadTransaction(txHash, loadOptions)\n    );\n  }\n\n  //returns true on success, false on already unloaded\n  async unload() {\n    if (!this.view(session.status.loaded)) {\n      return false;\n    }\n    debug(\"unloading\");\n    await this._runSaga(sagas.unload);\n    return true;\n  }\n\n  //Note: count is an optional argument; default behavior is to advance 1\n  async advance(count) {\n    return await this.doneStepping(controller.advance(count));\n  }\n\n  async stepNext() {\n    return await this.doneStepping(controller.stepNext());\n  }\n\n  async stepOver() {\n    return await this.doneStepping(controller.stepOver());\n  }\n\n  async stepInto() {\n    return await this.doneStepping(controller.stepInto());\n  }\n\n  async stepOut() {\n    return await this.doneStepping(controller.stepOut());\n  }\n\n  async reset() {\n    let loaded = this.view(session.status.loaded);\n    if (!loaded) {\n      return;\n    }\n    return await this._runSaga(controllerSagas.reset);\n  }\n\n  //Run the debugger till the end\n  async runToEnd() {\n    return await this.dispatch(controller.runToEnd());\n  }\n\n  //NOTE: breakpoints is an OPTIONAL argument for if you want to supply your\n  //own list of breakpoints; leave it out to use the internal one (as\n  //controlled by the functions below)\n  async continueUntilBreakpoint(breakpoints) {\n    return await this.doneStepping(\n      controller.continueUntilBreakpoint(breakpoints)\n    );\n  }\n\n  async addBreakpoint(breakpoint) {\n    return await this.dispatch(controller.addBreakpoint(breakpoint));\n  }\n\n  async removeBreakpoint(breakpoint) {\n    return await this.dispatch(controller.removeBreakpoint(breakpoint));\n  }\n\n  async removeAllBreakpoints() {\n    return await this.dispatch(controller.removeAllBreakpoints());\n  }\n\n  async setInternalStepping(active) {\n    return await this.dispatch(controller.setInternalStepping(active));\n  }\n\n  //deprecated -- decode is now *always* ready!\n  async decodeReady() {\n    return true;\n  }\n\n  async variable(name) {\n    const definitions = this.view(data.current.identifiers.definitions);\n    const refs = this.view(data.current.identifiers.refs);\n    const compilationId = this.view(data.current.compilationId);\n    debug(\"name: %s\", name);\n    debug(\"refs: %O\", refs);\n    debug(\"definitions: %o\", definitions);\n\n    return await this._runSaga(\n      dataSagas.decode,\n      definitions[name],\n      refs[name],\n      compilationId\n    );\n  }\n\n  async variables() {\n    if (!this.view(session.status.loaded)) {\n      return {};\n    }\n    let definitions = this.view(data.current.identifiers.definitions);\n    let refs = this.view(data.current.identifiers.refs);\n    let compilationId = this.view(data.current.compilationId);\n    let decoded = {};\n    for (let [identifier, ref] of Object.entries(refs)) {\n      if (identifier in definitions) {\n        decoded[identifier] = await this._runSaga(\n          dataSagas.decode,\n          definitions[identifier],\n          ref,\n          compilationId\n        );\n      }\n    }\n    return decoded;\n  }\n\n  async returnValue() {\n    if (\n      !this.view(session.status.loaded) ||\n      !this.view(evm.current.step.isHalting)\n    ) {\n      return null;\n    }\n    return await this._runSaga(dataSagas.decodeReturnValue);\n  }\n\n  callstack() {\n    if (!this.view(session.status.loaded)) {\n      return null;\n    }\n    return this.view(stacktrace.current.report);\n  }\n\n  stacktrace() {\n    if (!this.view(session.status.loaded)) {\n      return null;\n    }\n    return this.view(stacktrace.current.finalReport);\n  }\n\n  connect() {\n    return this; //for compatibility\n  }\n\n  async addExternalCompilations(compilations) {\n    const { contexts, sources, contracts } = Session.normalize(compilations);\n    return await this.dispatch(\n      actions.addCompilations(sources, contexts, contracts)\n    );\n  }\n\n  async startFullMode() {\n    return await this.dispatch(actions.startFullMode());\n  }\n\n  get selectors() {\n    return createNestedSelector({\n      ast,\n      data,\n      txlog,\n      trace,\n      evm,\n      sourcemapping,\n      stacktrace,\n      session,\n      controller: controllerSelector\n    });\n  }\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger\");\n\nimport Session from \"./session\";\n\nimport { createNestedSelector } from \"reselect-tree\";\n\nimport dataSelector from \"./data/selectors\";\nimport txlogSelector from \"./txlog/selectors\";\nimport astSelector from \"./ast/selectors\";\nimport traceSelector from \"./trace/selectors\";\nimport evmSelector from \"./evm/selectors\";\nimport sourcemappingSelector from \"./sourcemapping/selectors\";\nimport sessionSelector from \"./session/selectors\";\nimport stacktraceSelector from \"./stacktrace/selectors\";\nimport controllerSelector from \"./controller/selectors\";\n\nimport { Compilations } from \"@truffle/codec\";\n\nconst Debugger = {\n  /**\n   * Instantiates a Debugger for a given transaction hash.\n   * Throws on failure.  If you want a more failure-tolerant method,\n   * use forProject and then do a session.load inside a try.\n   *\n   * @param {String} txHash - transaction hash with leading \"0x\"\n   * @param {{contracts: Array<Artifact>, files: Array<String>, provider: Web3Provider, compilations: Array<Compilation>}} options -\n   * @return {Debugger} instance\n   */\n  forTx: async function (txHash, options = {}) {\n    let { contracts, files, provider, compilations, lightMode, storageLookup } =\n      options;\n    if (!compilations) {\n      compilations = Compilations.Utils.shimArtifacts(contracts, files);\n    }\n    let session = new Session(\n      compilations,\n      provider,\n      { lightMode, storageLookup },\n      txHash\n    );\n\n    await session.ready();\n\n    return session;\n  },\n\n  /*\n   * Instantiates a Debugger for a given project (with no transaction loaded)\n   *\n   * @param {{contracts: Array<Artifact>, files: Array<String>, provider: Web3Provider, compilations: Array<Compilation>}} options -\n   * @return {Debugger} instance\n   */\n  forProject: async function (options = {}) {\n    let { contracts, files, provider, compilations, lightMode } = options;\n    if (!compilations) {\n      compilations = Compilations.Utils.shimArtifacts(contracts, files);\n    }\n    let session = new Session(compilations, provider, {\n      lightMode\n    });\n\n    await session.ready();\n\n    return session;\n  },\n\n  /**\n   * Exported selectors\n   *\n   * See individual selector docs for full listing\n   *\n   * @example\n   * Debugger.selectors.ast.current.tree\n   *\n   * @example\n   * Debugger.selectors.sourcemapping.current.instruction\n   *\n   * @example\n   * Debugger.selectors.trace.steps\n   */\n  get selectors() {\n    return createNestedSelector({\n      ast: astSelector,\n      data: dataSelector,\n      txlog: txlogSelector,\n      trace: traceSelector,\n      evm: evmSelector,\n      sourcemapping: sourcemappingSelector,\n      stacktrace: stacktraceSelector,\n      session: sessionSelector,\n      controller: controllerSelector\n    });\n  }\n};\n\nexport default Debugger;\n","\"use strict\";\nclass TruffleError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n        this.stack = \"\";\n    }\n}\nmodule.exports = TruffleError;\n//# sourceMappingURL=index.js.map","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(529);\n"],"names":["root","factory","exports","module","define","amd","global","colors","themes","util","ansiStyles","styles","defineProps","Object","defineProperties","newLineRegex","RegExp","supportsColor","enabled","enable","disable","stripColors","strip","str","replace","stylize","style","styleMap","open","close","matchOperatorsRe","build","_styles","builder","applyStyle","apply","arguments","__proto__","proto","ret","grey","gray","keys","forEach","key","closeRe","TypeError","escapeStringRegexp","get","this","concat","args","Array","prototype","slice","call","map","arg","constructor","String","inspect","join","newLinesPresent","indexOf","nestedStyles","i","length","code","match","setTheme","theme","out","console","log","sequencer","exploded","split","trap","zalgo","maps","america","zebra","rainbow","random","name","init","text","options","result","a","b","c","d","e","f","g","h","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","toLowerCase","chars","rand","Math","floor","soul","all","up","down","mid","randomNumber","range","isChar","character","bool","filter","counts","size","arr","index","heComes","addProperty","color","func","__defineGetter__","stringPrototypeBlacklist","prop","red","magenta","themePropApplicator","applyTheme","letter","white","blue","rainbowColors","available","round","inverse","codes","reset","bold","dim","italic","underline","hidden","strikethrough","black","green","yellow","cyan","brightRed","brightGreen","brightYellow","brightBlue","brightMagenta","brightCyan","brightWhite","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","bgGray","bgGrey","bgBrightRed","bgBrightGreen","bgBrightYellow","bgBrightBlue","bgBrightMagenta","bgBrightCyan","bgBrightWhite","blackBG","redBG","greenBG","yellowBG","blueBG","magentaBG","cyanBG","whiteBG","val","flag","argv","terminatorPos","process","prefix","test","pos","os","hasFlag","env","forceColor","getSupportLevel","stream","level","isTTY","min","platform","osRelease","release","Number","versions","node","some","sign","CI_NAME","TEAMCITY_VERSION","version","parseInt","TERM_PROGRAM_VERSION","TERM_PROGRAM","TERM","hasBasic","has256","has16m","translateLevel","FORCE_COLOR","stdout","stderr","defineProperty","value","emptyWorkflowCompileResult","promoteCompileResult","compilations","contracts","flatMap","compilation","__importDefault","mod","__esModule","CompileError","colors_1","error_1","default","message","fancy_message","trim","super","__createBinding","create","k2","undefined","desc","getOwnPropertyDescriptor","writable","configurable","enumerable","__setModuleDefault","__importStar","hasOwnProperty","__exportStar","Compilations","Errors","Sources","Shims","forContract","contract","contractName","contract_name","sourcePath","source","sourceMap","deployedSourceMap","legacyAST","ast","abi","metadata","bytecode","deployedBytecode","compiler","devdoc","userdoc","immutableReferences","generatedSources","deployedGeneratedSources","db","forBytecode","linkReferences","bytes","linkReference","characterOffset","Error","characterLength","offset","push","offsets","repeat","forContracts","values","reduce","linkId","start","substring","unlinked_binary","NewToLegacy","LegacyToNew","collectSources","path","getPortableSourcePath","replacement","sep","replaceRootDirectory","rootDirectory","endsWith","startsWith","originalSources","originalTargets","baseDirectory","entries","originalSourcePath","_","isAbsolute","contents","sources","targets","includes","originalSourcePaths","accumulator","assign","Debugger","require","isDeliberatelySkippedNodeType","nodeType","prefixName","fn","makePath","sourceId","pointer","popNWhere","array","numToRemove","predicate","newArray","pop","keccak256","stableKeccak256","obj","type","makeAssignment","idObj","ref","id","isCallMnemonic","op","isCreateMnemonic","isSelfDestructMnemonic","ADVANCE","STEP_NEXT","STEP_OVER","STEP_INTO","STEP_OUT","INTERRUPT","RUN_TO_END","CONTINUE","ADD_BREAKPOINT","REMOVE_BREAKPOINT","REMOVE_ALL_BREAKPOINTS","SET_INTERNAL_STEPPING","START_STEPPING","DONE_STEPPING","START","LOAD_TRANSACTION","UNLOAD_TRANSACTION","READY","ready","WAIT","ERROR","RECORD_CONTRACTS","SAVE_TRANSACTION","SAVE_RECEIPT","SAVE_BLOCK","SET_LIGHT_MODE","SET_FULL_MODE","START_FULL_MODE","ADD_COMPILATIONS","PAST_END_OF_TRACE","depth","error","gas","memory","stack","storage","gasCost","pc","createSelectorTree","state","trace","proc","loaded","createLeaf","steps","finished","finishedOrUnloaded","transaction","stepsRemaining","step","next","nextOfSameDepth","application","submoduleCount","ZERO_WORD","determineFullContext","address","binary","instances","search","contexts","contextId","isConstructor","Boolean","context","createStepSelectors","base","programCounter","isCall","isShortCall","isShortCallMnemonic","isDelegateCallBroad","isDelegateCallMnemonicBroad","isDelegateCallStrict","isDelegateCallMnemonicStrict","isStaticCall","isStaticCallMnemonic","isCreate","isSelfDestruct","isCreate2","isStore","isLoad","touchesStorage","stores","loads","isPop","isLog","topicCount","isJump","valueStored","callAddress","createBinary","padEnd","callData","short","argOffset","callValue","calls","delegates","isStatic","createValue","storageAffected","salt","callContext","logData","logTopics","reverse","word","evm","storageLookup","storageLookupSupported","info","byContext","binaries","globals","tx","block","blockHash","txIdentification","txIndex","status","initialCall","startingContext","affectedInstances","byAddress","current","callstack","isIR","settings","viaIR","param","createdAddress","create2Address","storageAddress","isInstantCallOrCreate","creates","contextChange","isContextChange","currentDepth","nextDepth","isNormalHalting","isHalting","isExceptionalHalting","returnStatus","isInstaCall","remaining","finalStatus","returnValue","valueLoaded","beneficiary","currentAddress","codex","accounts","contextRequiresPhantomStackframes","data","selector","hasFallbackOrReceive","abiEntry","primaryLanguage","includePrerelease","createMultistepSelectors","stepSelector","instruction","modifierDepth","file","findOverlappingRange","functions","sourceRange","pointerAndNode","contractNode","sourcemapping","bottomStackframeRequiresPhantomFrame","sourceIds","compilationId","contextHash","userSources","internalSources","byCompilationId","byIndex","allSources","ids","humanReadableSourceMap","functionDepthStack","nextFrameIsPhantom","functionDepth","callRequiresPhantomFrame","instructions","instructionAtProgramCounter","isSourceRangeFinalRaw","changesContext","isSourceRangeFinal","isFinal","currentSource","nextSource","internal","functionsByProgramCounter","isMultiline","lines","line","end","onYulFunctionDefinitionWhileEntering","nextPointer","willJump","jumpDirection","jump","willCall","isInstant","willReturn","nextUserStep","find","overlapFunctions","views","byId","identity","generateReport","rawStack","location","frame","combineWithNextInternal","sourceIsInternal","combinedFrame","calledFromLocation","locations","shift","names","functionName","report","nameInfo","Panic","panic","custom","strippedLocation","stacktrace","initialCallCombinesWithNextJumpIn","returnCounter","lastPosition","innerReturnPosition","innerReturnStatus","innerErrorIndex","updateIndex","willJumpIn","willJumpOut","callCombinesWithNextJumpIn","revertString","rawRevertMessage","revertDecodings","kind","decoding","revertStringInfo","asString","Buffer","from","asHex","toString","asBN","positionWillChange","nextLocation","currentLocation","lastLocation","oldLocation","finalReport","findAncestorOfType","types","scopes","parentId","definition","modifierForInvocation","invocation","rawId","modifierName","referencedDeclaration","baseName","rawNode","nodes","debuggerContextToDecoderContext","contractId","contractKind","payable","fallbackAbi","fallback","item","receive","NOW_DEFINITION","src","typeDescriptions","typeIdentifier","typeString","MSG_DEFINITION","TX_DEFINITION","BLOCK_DEFINITION","atLastInstructionForSourceRange","final","byAstRef","inlined","astRef","scope","userDefinedTypesByCompilation","userDefinedTypes","referenceDeclarations","typesByCompilation","contractAllocationInfo","byAstId","deployedContext","constructorContext","taggedOutputs","mappingKeys","mappedPaths","byType","bySlotAddress","slot","blockNumber","number","bySourceId","allocations","calldata","returndata","event","assignments","words","eventdata","eventtopics","mapping","specials","sender","variable","sourceIndex","language","internalSourceFor","internalFor","newScope","linearizedBaseContractsFromBase","linearizedBaseContracts","variables","visibility","constant","mutability","exportedSymbols","raw","allAllocations","transformedAllocations","allocation","members","member","memberAllocation","bareLetsInYulAreHit","contractForBytecode","fallbackOutputForContext","fallbackDefinition","returnParameters","parameters","function","inModifier","inFunctionOrModifier","internalFunctionsTable","byPC","fallbackBase","errorLocation","innerLocation","errorNode","astId","errorId","errorCall","expression","eventId","eventNode","eventCall","aboutToModify","nextInvocation","argument","modifierInvocation","modifierArgumentIndex","invocationPointer","difference","rawIndex","modifierBeingInvoked","identifiers","cur","msg","builtin","now","definitions","thisDefinition","identifier","builtins","solidityVersionHasNoNow","sections","refs","local","stackframe","returnAllocation","constructorAllocations","functionAllocations","contractHasFallbackOutput","output","currentCallIsCreate","invalid","astNode","inInternalSourceOrYul","txlog","transactionLog","byPointer","origin","absorbFirstInternalCall","currentNodePointer","pointerStack","waitingForFunctionDefinition","waitingForInternalCallToAbsorb","absorbNextInternalCall","nextActionPointer","actions","internalReturnPointer","externalReturnPointer","onFunctionDefinition","isNextInternal","currentFunctionIsAsExpected","txlogNode","currentFunction","rawStorageSlot","rawStorageValue","rawEventInfo","topics","returnData","inputParameterAllocations","functionDefinition","locateParameters","outputParameterAllocations","tie","flattedEvents","returnKind","lastCall","getFlattedEvents","codeAddress","subNode","subNodeStatus","isDelegate","top","reverseParameters","results","currentPosition","parameter","to","unshift","session","creationBinary","creationContext","creationContextId","primarySource","constructorArgs","receipt","readyOrError","waiting","lastLoadingError","isError","success","errored","lightMode","SAVE_STEPS","TICK","TOCK","END_OF_TRACE","SET_SUBMODULE_COUNT","setSubmoduleCount","count","SCOPE","DECLARE","declare","scopeAstRef","ASSIGN","MAP_PATH_AND_ASSIGN","mapPathAndAssign","parentType","DEFINE_TYPE","DEFINE_TAGGED_OUTPUT","ADD_CONTRACTS","ALLOCATE","ADD_CONTEXT","ADD_INSTANCE","addInstance","ADD_AFFECTED_INSTANCE","addAffectedInstance","SAVE_GLOBALS","SAVE_TX_IDENTIFICATION","SAVE_STATUS","CALL","CREATE","RETURN_CALL","RETURN_CREATE","FAIL","STORE","LOAD","load","SET_STORAGE_LOOKUP","SET_STORAGE_LOOKUP_SUPPORT","INIT_WEB3","INSPECT","FETCH_BINARY","FETCH_STORAGE","RECEIVE_BINARY","RECEIVE_STORAGE","RECEIVE_STORAGE_FAIL","RECEIVE_TRACE","RECEIVE_CALL","receiveCall","gasprice","ERROR_WEB3","Web3Adapter","provider","web3","async","txHash","currentProvider","promisify","send","bind","jsonrpc","method","Date","params","enableMemory","disableStorage","structLogs","eth","getTransaction","getTransactionReceipt","blockNumberOrHash","getBlock","getChainId","hashedSlot","getCode","padHexString","hexString","padStart","fetchTransactionInfo","adapter","getTrace","put","getReceipt","chainId","difficultyOrMixHash","mixHash","prevRandao","numericMixHash","isZero","difficulty","solidityBlock","coinbase","miner","gaslimit","gasLimit","timestamp","chainid","basefee","baseFeePerGas","input","gasPrice","hash","transactionIndex","contractAddress","inspectTransaction","action","take","obtainBinaries","addresses","tasks","fork","getDeployedCode","obtainStorage","task","race","failure","receiveStorageErrorHandler","slotAsHex","getExistingStorage","eq","saga","takeEvery","select","waitingForSubmodules","signalTickSagaCompletion","recordStorage","slotAsPrefixlessHex","requestCode","requestStorage","currentStorage","begin","tickSaga","callstackAndCodexSaga","currentCall","returnedBinary","returnedContext","storedValue","loadedValue","supported","isStorageLookupSupported","nodeId","yulScope","yulDeclare","scopePointer","preambleAssignments","modifier","currentIndex","parametersLeft","adjustment","assignParameters","nextModifier","returnSuffixes","returnVariables","vars","parameterSuffixes","bareLetSuffixes","outerIndex","declaration","body","statements","innerIndex","suffixes","position","suffix","assignment","fallbackInputDefinition","varId","parentPointer","parent","sourceAndPointer","literalAssignments","baseExpression","fetchBasePath","keyDefinition","indexValue","indexDefinition","currentAssignments","indexReference","decode","splicedDefinition","indexConstantDeclaration","indexConstantDefinition","operator","subExpression","decodeMappingKeyCore","decodeMappingKeySaga","indexExpression","storageAllocations","hashPath","muln","structType","memberAllocations","memberName","clone","variablesAndMappingsSaga","literal","forModifier","baseNode","fullId","baseAssignment","referencedId","currentContext","decoder","done","response","request","decodeReturnValue","decodeCall","decodeCurrent","decodeLog","recordAllocations","memoryAllocations","abiAllocations","calldataAllocations","returndataAllocations","eventAllocations","stateAllocations","INTERNAL_CALL","ABSORBED_CALL","INTERNAL_RETURN","internalReturn","newPointer","EXTERNAL_CALL","externalCall","INSTANT_EXTERNAL_CALL","INSTANT_CREATE","EXTERNAL_RETURN","SELFDESTRUCT","REVERT","IDENTIFY_FUNCTION_CALL","LOG_EVENT","RECORD_ORIGIN","decodings","rawData","astMatchesTxLog","outputAllocations","decodedValue","instant","callKind","absorb","rawInfo","rawSlot","rawValue","inputAllocations","functionNode","updateTransactionLogSaga","ADD_SOURCES","JUMP","guard","CLEAR_PHANTOM_GUARD","functionDepthSaga","JUMP_IN","JUMP_OUT","EXECUTE_RETURN","UPDATE_POSITION","positionUpdated","counter","nextParent","nextSourceIsInternal","nextContext","nextAddress","stacktraceSaga","anyNonSkippedInRange","sourceStart","sourceLength","sourceEnd","AST","isOldStyleAssembly","isSkippedNodeType","controller","executionContext","onBaseConstructorDefinition","breakpoints","resolver","breakpoint","adjustedBreakpoint","lineLengths","lineStarts","isStepping","stepIntoInternalSources","STEP_SAGAS","startingDepth","startingLocation","startingNode","breakpointHit","currentSourceId","currentLine","currentStart","currentLength","startedInUserSource","lastUserSourceId","lastUserLine","lastUserStart","lastUserLength","previousLine","previousStart","previousLength","previousSourceId","exec","interrupt","starting","allowInternal","upcoming","walk","handleEnter","isArray","child","yulWalk","handleYul","handleExit","visitAll","basePointer","findYulScopePointer","handleYulEnter","_parentId","handleYulExit","relativePointer","relativeParentPointer","LOAD_SAGAS","processTransaction","recordContexts","recordSources","listenersToActivate","listener","increment","listenerSaga","loadOptions","err","creations","selfdestructs","callAddresses","Set","selfDestructAddresses","createdBinaries","add","returnStep","returnStack","nonCallStartIndex","recordInstance","fetchTx","moduleOptions","mainApps","otherApps","apps","app","forkListeners","affectedInstanceOnly","DEFAULT_SCOPES","DEFAULT_ALLOCATIONS","DEFAULT_CONTRACTS","combineReducers","GLOBAL_ASSIGNMENTS","special","DEFAULT_ASSIGNMENTS","DEFAULT_PATHS","hexSlotAddress","parentAddress","newState","newSlot","DEFAULT_CONTEXTS","contextObject","DEFAULT_TX","DEFAULT_BLOCK","DEFAULT_AFFECTED_INSTANCES","EMPTY_ACCOUNT","DEFAULT_CODEX","topCodex","topCodexNoZero","updateFrameStorage","updateFrameCode","existingPage","wipeZeroAccount","safeSave","DEFAULT_SOURCES","user","flat","delta","belowTop","max","newFrame","DEFAULT_TX_LOG","beginStep","modifiedNode","returnValues","endStep","currentPointer","currentNode","finalNode","immutables","returnImmutables","Session","store","sagaMiddleware","reducer","sagaArgs","initialState","composeEnhancers","compose","createStore","applyMiddleware","run","_store","_sagaMiddleware","normalize","dispatch","_ready","Promise","accept","reject","unsubscribe","subscribe","view","sessionAction","hasStartedWaiting","static","makeSourceId","unreliableSourceOrder","primarySourceIndex","deployedBinary","primarySourceId","findIndex","getState","toPromise","stepperAction","resolve","hasStarted","readyAgainAfterLoading","_runSaga","doneStepping","active","decoded","connect","selectors","createNestedSelector","forTx","files","forProject","TruffleError","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","Symbol","toStringTag"],"sourceRoot":""}